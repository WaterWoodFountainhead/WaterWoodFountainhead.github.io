<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Fountainhead</title>
    <description>Blog</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 27 Jun 2019 19:19:51 +0800</pubDate>
    <lastBuildDate>Thu, 27 Jun 2019 19:19:51 +0800</lastBuildDate>
    <generator>Jekyll v3.8.5</generator>
    
      <item>
        <title>[Unp]Chapter 3</title>
        <description>&lt;h1 id=&quot;ipv4套接字地址结构&quot;&gt;IPv4套接字地址结构&lt;/h1&gt;

&lt;p&gt;它以sockaddr_in命名，定义在&amp;lt;netinet/in.h&amp;gt;头文件中。如下是它的POSIX定义：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_3/UNP3.2.1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;关于套接字地址结构的一般性说明：&lt;/p&gt;

&lt;p&gt;1）长度字段sin_len是为增加对OSI协议的支持而随4.3BSD-Reno添加的。不过，POSIX规范也不要求有这个成员。该成员的数据类型uint8_t是典型的，符合POSIX的系统都提供这种形式的数据类型。即使有长度字段，我们也无须设置和检查它，除非涉及路由套接字。它是由处理来自不同协议族的套接字地址结构的例程（例如路由表处理代码）在内核中使用的。&lt;/p&gt;

&lt;p&gt;2）POSIX规范只需要这个结构中的3个字段：sin_family、sin_addr和sin_port。对于符合POSIX的实现来说，定义额外的结构字段是可以接受的，这对于网际套接字地址结构来说也是正常的。几乎所有的实现都增加了sin_zero字段，所以所有的套接字地址结构大小都至少是16字节（因为sin_zero是一个带有8个元素长度的char类型的数组）。&lt;/p&gt;

&lt;p&gt;sin_addr字段：in_addr_t数据类型必须是一个至少32位的无符号整数类型。&lt;/p&gt;

&lt;p&gt;sin_port字段：in_port_t必须是一个至少16位的无符号整数类型。&lt;/p&gt;

&lt;p&gt;sin_family字段：sa_family_t数据类型可以是任何无符号整数类型。在支持长度字段的实现中，sa_family_t数据类型通常是一个8位的无符号整数，而在不支持长度字段的实现中，它则是一个16位的无符号整数。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;3，IPv4地址和TCP或UDP端口号在套接字地址结构中总是以网络字节序来存储。&lt;/p&gt;

&lt;p&gt;4，32位IPv4地址存在两种不同的访问方法。第一种：&lt;strong&gt;.sin_addr&lt;/strong&gt; 按 &lt;strong&gt;in_addr&lt;/strong&gt;结构引用其中的32位IPv4地址。第二种：&lt;strong&gt;.sin_addr.s_addr&lt;/strong&gt; 将按 &lt;strong&gt;in_addr_t&lt;/strong&gt;（通常是一个无符号的32位整数）引用同一个32位IPv4地址。&lt;/p&gt;

&lt;p&gt;5，sin_zero字段未曾使用，不过在填写这种套接字地址结构时，我们要把该字段置为0。尤其是，当捆绑一个非通配的IPv4地址时，该字段必须为0。&lt;/p&gt;

&lt;p&gt;6，套接字地址结构仅在给定主机上使用：虽然结构中的某些字段（例如IP地址和端口号）用在不同主机之间的通信中，但是结构本身并不在主机之间传递。因为不同的主机中的地址结构有可能会不同。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;通用套接字地址结构&quot;&gt;通用套接字地址结构&lt;/h1&gt;

&lt;p&gt;在任何套接字函数处理来自所支持的任何协议族的套接字地址结构的指针的时候，会引发一个问题（如何声明函数参数来容纳不同的指针类型？）。&lt;/p&gt;

&lt;p&gt;当然，ANSI C用 void * 解决了通用指针类型的问题。不过在这之前（1982年）采取的办法是在&amp;lt;sys/socket.h&amp;gt;头文件中定义一个通用的套接字地址结构：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_3/UNP3.2.2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;由于套接字函数是在ANSI C之前定义的，因此套接字函数被定义为——以指向某个通用套接字地址结构的一个指针作为其参数之一。这正如bind函数的ANSI C函数原型所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_3/UNP3.2.3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;因此，这就要求对套接字地址结构的指针参数进行类型强制转换，变成指向某个通用套接字地址结构的指针，例如：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_3/UNP3.2.4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;从应用层和内核角度看待此情况的强制转换的意义：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;从应用程序开发人员的观点看，这些通用套接字地址结构的唯一用途就是对指向特定于协议的套接字地址结构的指针执行类型强制转换。&lt;/p&gt;

&lt;p&gt;从内核的角度看，使用指向通用套接字地址结构的指针另有原因：内核必须取调用者的指针，把它类型强制转换为 **struct sockaddr * ** 类型，然后检查其中sa_family字段的值来确定这个结构的真实类型。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;ipv6-套接字地址结构&quot;&gt;IPv6 套接字地址结构&lt;/h1&gt;

&lt;p&gt;IPv6套接字地址结构在&amp;lt;netinet/in.h&amp;gt;头文件中定义，如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_3/UNP3.2.5.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1，如果系统支持套接字地址结构中的长度字段，那么SIN6_LEN常值必须定义。&lt;/p&gt;

&lt;p&gt;2，IPv6的地址族是AF_INET6，而IPv4的地址族是AF_INET。&lt;/p&gt;

&lt;p&gt;3，结构中字段的先后顺序做过编排。如果 sockaddr_in6 套接字地址结构本身是64位对齐的，那么128位的 sin6_addr 字段也是64位对齐的。在一些64位处理机上，如果64位数据存储在某个64位边界位置，那么对它的访问将得到优化处理。&lt;/p&gt;

&lt;p&gt;4，sin6_flowinfo 字段分成两个字段：（1）低序20位是流标（flow label）。（2）高序12位保留。&lt;/p&gt;

&lt;p&gt;5，对于具备范围的地址（scoped address），sin6_scope_id字段标识其范围（scope），最常见的是链路局部地址（link-local address）的接口索引（interface index）。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;新的通用套接字地址结构&quot;&gt;新的通用套接字地址结构&lt;/h1&gt;

&lt;p&gt;作为IPv6套接字API的一部分而定义的新的通用套接字地址结构克服了现有struct sockaddr的一些缺点。&lt;/p&gt;

&lt;p&gt;新的struct sockaddr_storage足以容纳系统所支持的任何套接字地址结构。sockaddr_storage结构在&amp;lt;netinet/in.h&amp;gt;头文件中定义，如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_3/UNP3.2.6.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;新的通用套接字（sockaddr_storage）与旧的（sockaddr）之间的区别：&lt;/p&gt;

&lt;p&gt;1，如果系统支持的任何套接字地址结构有对齐需要，那么sockaddr_storage能够满足最苛刻的对齐要求。&lt;/p&gt;

&lt;p&gt;2，sockaddr_storage足够大，能够容纳系统支持的任何套接字地址结构。
注意，除了ss_family和ss_len外（如果有的话），sockaddr_storage结构中的其他字段对用户来说是透明的。sockaddr_storage结构必须类型强制转换成（或复制到）适合ss_family字段所给出指针类型的套接字地址结构中，才能访问其他字段。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;套接字地址结构的比较&quot;&gt;套接字地址结构的比较&lt;/h1&gt;

&lt;p&gt;5种套接字地址结构进行比较：IPv4、IPv6、Unix域、数据链路和存储。（Unix域和数据链路以后会提到）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_3/UNP3.2.7.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;前两种套接字地址结构是固定长度的。Unix域结构和数据链路结构是可变长度的，为了处理长度可变的结构，我们把一个指针（它指向套接字地址结构）作为参数传递给套接字函数时，也把该套接字地址结构的长度作为另一个参数传递给它。&lt;/p&gt;

&lt;p&gt;我们在每种长度固定的结构下方给出了这种结构的字节数长度。&lt;/p&gt;

&lt;p&gt;不过，Unix域（sockaddr_un）结构本身并非长度可变的，但是其中的信息（即结构中的路径名）却是长度可变的。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;值结果参数&quot;&gt;值—结果参数&lt;/h1&gt;

&lt;p&gt;当一个套接字地址结构的指针作为一个套接字函数的参数时，结构的长度也会作为一个参数来传递，不过其传递方式取决于该结构的传递方向：是从进程到内核，还是从内核到进程。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;从进程到内核：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;有3个函数——bind、connect和sendto。这些函数的一个参数是指向某个套接字地址结构的指针，另一个参数是该结构的整数大小，例如：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_3/UNP3.3.1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这样内核知道到底需要从进程复制多少数据进来，如图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_3/UNP3.3.2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;从内核到进程：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;有4个函数——accept、recvfrom、getsockname 和 getpeername。这四个函数的其中两个参数是指向套接字地址结构和指向该结构长度的指针，例如：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_3/UNP3.3.3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;label style=&quot;color:red&quot;&gt;将长度以指针传递给内核的原因是：&lt;/label&gt;&lt;/p&gt;

&lt;p&gt;当函数被调用时，结构大小是一个值（value），它告诉内核该结构的大小，这样内核在写该结构时不至于越界；当函数返回时，结构大小又是一个结果（result），它告诉进程内核在该结构中究竟存储了多少信息。这种类型的参数称为值—结果（value-result）参数。&lt;/p&gt;

&lt;p&gt;如图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_3/UNP3.3.4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;除这四个函数外，还有其他 值—结果参数相关的函数：&lt;/p&gt;

&lt;p&gt;1，select函数中间的3个参数。&lt;/p&gt;

&lt;p&gt;2，getsockopt函数的长度参数。&lt;/p&gt;

&lt;p&gt;3，ifconf结构中的ifc_len字段。&lt;/p&gt;

&lt;p&gt;4，sysctl函数两个长度参数中的第一个。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;字节排序函数&quot;&gt;字节排序函数&lt;/h1&gt;

&lt;p&gt;由于历史的原因和POSIX规范的规定，套接字地址结构中的某些字段必须按照网络字节序进行维护。因此我们要关注如何在&lt;a href=&quot;https://waterwoodfountainhead.github.io/unp/2019/06/26/Unp-Nouns.html&quot;&gt;主机字节序和网络字节序(nouns第14条)&lt;/a&gt;之间相互转换。这两种字节序之间的转换使用以下4个函数：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_3/UNP3.4.1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;h代表host，n代表network，s代表short，l代表long。（short和long这两个称谓是出自4.2BSD的Digital VAX实现的历史产物。）我们应该把s视为一个16位的值（例如TCP或UDP端口号），把l视为一个32位的值（例如IPv4地址）。&lt;/p&gt;

&lt;p&gt;当使用这些函数时，我们并不关心主机字节序和网络字节序的真实值。在那些与网际协议所用字节序（大端）相同的系统中，这四个函数通常被定义为空宏。&lt;/p&gt;

&lt;p&gt;于此同时，我们也应该了解下&lt;a href=&quot;https://waterwoodfountainhead.github.io/unp/2019/06/26/Unp-Nouns.html&quot;&gt;因特网标准的两条重要约定(nouns第15条)&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;字节操纵函数&quot;&gt;字节操纵函数&lt;/h1&gt;

&lt;p&gt;名字以b（表示字节）开头的第一组函数起源于4.2BSD，几乎所有现今支持套接字函数的系统仍然提供它们。名字以mem（表示内存）开头的第二组函数起源于ANSI C标准，支持ANSIC函数库的所有系统都提供它们。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4.2BSD&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_3/UNP3.5.1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Bzero函数：它把目标字节串中指定数目的字节置为0。我们可以使用该函数来把一个套接字地址结构初始化为0。&lt;/p&gt;

&lt;p&gt;Bcopy函数 ：它将指定数目的字节从源字节串移到目标字节串。&lt;/p&gt;

&lt;p&gt;Bcmp函数：它比较两个任意的字节串，若相同则返回值为0，否则返回值为非0。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ANSI C函数&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_3/UNP3.5.2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Memset函数：它把目标字节串指定数目的字节置为值c。&lt;/p&gt;

&lt;p&gt;Memcpy函数：它类似bcopy，不过两个指针参数的顺序是相反的。&lt;strong&gt;注意&lt;/strong&gt;：当源字节串与目标字节串重叠时，bcopy能够正确处理，但是memcpy的操作结果却不可知。这种情形下必须改用ANSI C的memmove函数。memcpy的赋值顺序（从左往右）：dest = src 。&lt;/p&gt;

&lt;p&gt;Memcmp函数：它比较两个任意的字节串，若相同则返回0，否则返回一个非0值，是大于0还是小于0则取决于第一个不等的字节。注意：比较操作是在假设两个不等的字节均为无符号字符（unsigned char）的前提下完成的。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;两组地址转换函数&quot;&gt;两组地址转换函数&lt;/h1&gt;

&lt;p&gt;有两组函数可以在ASCII字符串（人类偏爱的格式）与网络字节序的二进制值（这是存放在套接字地址结构中的值）之间转换网际地址。&lt;/p&gt;

&lt;p&gt;（1）inet_aton、inet_addr 和 inet_ntoa在点分十进制数串（例如“206.168.112.96”）与它长度为32位的网络字节序二进制值间转换IPv4地址。&lt;/p&gt;

&lt;p&gt;（2）两个较新的函数inet_pton 和 inet_ntop对于IPv4地址和IPv6地址都适用。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;inet_aton、inet_addr 和 inet_ntoa 函数&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_3/UNP3.6.1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;inet_aton 函数：它将strptr所指C字符串转换成一个32位的网络字节序二进制值，并通过指针addrptr来存储。若成功则返回1，否则返回0。它有一个特性：如果addrptr指针为空，那么该函数仍然对输入的字符串执行有效性检查，但是不存储任何结果。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://waterwoodfountainhead.github.io/unp/2019/06/26/Unp-Nouns.html&quot;&gt;inet_addr 函数已被废弃(nouns第16条)。&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;inet_ntoa 函数：它将一个32位的网络字节序二进制IPv4地址转换成相应的点分十进制数串。由该函数的返回值所指向的字符串驻留在静态内存中。这意味着该函数是不可重入的。最后，它的参数是以结构的值传递的，这是很罕见的。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;inet_pton 和 inet_ntop 函数&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_3/UNP3.7.1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;函数名中p和n分别代表表达（presentation）和数值（numeric）。&lt;/p&gt;

&lt;p&gt;地址的表达格式通常是ASCII字符串，数值格式则是存放到套接字地址结构中的二进制值。&lt;/p&gt;

&lt;p&gt;这两个函数的family参数既可以是AF_INET，也可以是AF_INET6。如果以不被支持的地址族作为family参数，这两个函数就都返回一个错误，并将errno置为EAFNOSUPPORT。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;inet_pton 函数：它尝试转换由strptr指针所指的字符串，并通过addrptr指针存放二进制结果。若成功则返回值为1，否则如果对所指定的family而言输入的字符串不是有效的表达格式，那么返回值为0。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;inet_ntop 函数：它进行相反的转换，从数值格式（addrptr）转换到表达格式（strptr）。len参数是目标存储单元的大小，以免该函数溢出其调用者的缓冲区。为有助于指定这个大小，在&amp;lt;netinet/in.h&amp;gt;头文件中有如下定义：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_3/UNP3.7.2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;关于inet_ntop的参数：&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;（1）如果len参数太小，不足以容纳表达格式结果（包括结尾的空字符），那么返回一个空指针，并置errno为ENOSPC。&lt;/p&gt;

&lt;p&gt;（2）它的strptr参数不可以是一个空指针。调用者必须为目标存储单元分配内存并指定其大小。调用成功时，这个指针就是该函数的返回值。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总结inet_aton、inet_addr 和 inet_ntoa 、inet_pton 和 inet_ntop 函数&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_3/UNP3.7.3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 27 Jun 2019 10:00:00 +0800</pubDate>
        <link>http://localhost:4000/unp/2019/06/27/Unp-Chapter-3.html</link>
        <guid isPermaLink="true">http://localhost:4000/unp/2019/06/27/Unp-Chapter-3.html</guid>
        
        
        <category>unp</category>
        
      </item>
    
      <item>
        <title>[Unp]Chapter 2</title>
        <description>&lt;h1 id=&quot;tcp连接终止&quot;&gt;TCP连接终止&lt;/h1&gt;

&lt;p&gt;讲TIME_WAIT前，我们需要了解下&lt;a href=&quot;https://waterwoodfountainhead.github.io/unp/2019/06/26/Unp-Nouns.html&quot;&gt;迷途(Nouns第12条)&lt;/a&gt;和TCP连接终止的过程，如图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_2/UNP2.6.1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;TCP的终结需要4个分节：&lt;/p&gt;

&lt;p&gt;（1）客户端首先调用close，我们称该端执行主动关闭（active close）。该端的TCP于是发送一个FIN分节，表示数据发送完毕。&lt;/p&gt;

&lt;p&gt;（2）接收到这个FIN的对端执行被动关闭（passive close）。这个FIN由TCP确认。服务端接收FIN意味着服务端的应用进程在相应连接上再无额外数据可接收。&lt;/p&gt;

&lt;p&gt;（3）一段时间后，接收到这个文件结束符的应用进程将调用close关闭它的套接字。这导致它的TCP也发送一个FIN。&lt;/p&gt;

&lt;p&gt;（4）接收这个最终FIN的客户端的TCP（即执行主动关闭的那一端）确认这个FIN。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;time_wait状态&quot;&gt;TIME_WAIT状态&lt;/h1&gt;

&lt;p&gt;先介绍下TIME_WAIT状态：这个状态的持续时间是最长分节生命期（maximum segment lifetime，MSL）的两倍，有时候称之为2MSL。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;那么，TIME_WAIT状态有什么作用呢？&lt;/p&gt;

&lt;p&gt;(1) 可靠地实现TCP全双工连接的终止；&lt;/p&gt;

&lt;p&gt;假设最终的ACK丢失了来解释。服务器将重新发送它的最终那个FIN，因此客户必须维护状态信息，以允许它重新发送最终那个ACK。要是客户不维护状态信息，它将响应以一个RST（另外一种类型的TCP分节），该分节将被服务器解释成一个错误。如果TCP打算执行所有必要的工作以彻底终止某个连接上两个方向的数据流（即全双工关闭），那么它必须正确处理连接终止序列4个分节中任何一个分节丢失的情况。&lt;/p&gt;

&lt;p&gt;这也说明了执行主动关闭的那一端(客户端)由于要重传最后一个ACK，所以是处于TIME_WAIT状态。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;(2) 允许老的重复分节在网络中消逝。&lt;/p&gt;

&lt;p&gt;有时候一个连接可能会在关闭后，又在相同的ip地址和端口之间建立一个连接。因此TCP必须防止这个连接的老的重复分组在该连接已终止后再现，以免被误解成属于同一连接的某个新的化身。&lt;/p&gt;

&lt;p&gt;为此，TCP将不给处于TIME_WAIT状态的连接发起新的化身。既然TIME_WAIT状态的持续时间是MSL的2倍，这就足以让某个方向上的分组最多存活MSL秒即被丢弃，另一个方向上的应答最多存活MSL秒也被丢弃。通过实施这个规则，我们就能保证每成功建立一个TCP连接时，来自该连接先前化身的老的重复分组都已在网络中消逝了。&lt;/p&gt;
</description>
        <pubDate>Wed, 26 Jun 2019 16:00:00 +0800</pubDate>
        <link>http://localhost:4000/unp/2019/06/26/Unp-Chapter-2.html</link>
        <guid isPermaLink="true">http://localhost:4000/unp/2019/06/26/Unp-Chapter-2.html</guid>
        
        
        <category>unp</category>
        
      </item>
    
      <item>
        <title>[Unp]Nouns</title>
        <description>&lt;p&gt;1，&lt;strong&gt;路由器&lt;/strong&gt;是广域网的设备。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;2，&lt;strong&gt;因特网&lt;/strong&gt;是当今最大的广域网。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;3，TCP/IP协议概况&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/NOUNS/NOUNS_3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;4，&lt;strong&gt;RFC&lt;/strong&gt;——所有网际协议由一个或多个称为请求评注（Request for Comments，RFC）的文档定义，第三条内容里面的协议就是它们的正式规范。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;5，&lt;strong&gt;IPv4/IPv6主机&lt;/strong&gt; 或 &lt;strong&gt;双栈主机&lt;/strong&gt; 表示同时支持IPv4和IPv6的主机。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;6，&lt;strong&gt;被动打开（passive open）&lt;/strong&gt;，通常通过调用socket、bind和listen这3个函数来完成。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;7，&lt;strong&gt;主动打开（active open）&lt;/strong&gt;，通过调用connect发起。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;8，&lt;strong&gt;SYN&lt;/strong&gt;，一个同步分节。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;9，&lt;strong&gt;ACK&lt;/strong&gt;，一个确认分节。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;10，&lt;strong&gt;主动关闭（active close）&lt;/strong&gt;，某个应用进程首先调用close，称该端执行主动关闭。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;11，&lt;strong&gt;MSL&lt;/strong&gt;，它是任何IP数据报能够在因特网中存活的最长时间。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;12，&lt;strong&gt;迷途&lt;/strong&gt;，通常是路由异常的结果。&lt;/p&gt;

&lt;p&gt;例如：某个路由器崩溃或某两个路由器之间的某个链路断开时，路由协议需花数秒钟到数分钟的时间才能稳定并找出另一条通路。在这段时间内有可能发生路由循环（路由器A把分组发送给路由器B，而B再把它们发送回A），我们关心的分组可能就此陷入这样的循环。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;13，&lt;strong&gt;网际套接字地址结构&lt;/strong&gt;，它是IPv4套接字地址结构，它以sockaddr_in命名。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;14，&lt;strong&gt;小端（little-endian）&lt;/strong&gt;字节序，是将低序字节存储在起始地址的方法；&lt;strong&gt;大端（big-endian）&lt;/strong&gt;字节序，是将高序字节存储在起始地址的方法。如图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/NOUNS/NOUNS_14.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;主机字节序&lt;/strong&gt;，是某个给定系统所用的字节序的名称。&lt;/p&gt;

&lt;p&gt;由于网络协议必须制定一个网络字节序（network byte order），其中网际协议使用大端字节序来传送这些多字节整数。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;15，&lt;strong&gt;因特网标准的两个重要约定&lt;/strong&gt;：1）大多数因特网标准使用八位组（octet）这个术语而不是使用字节来表示8位的量。2）另一约定是位序。如图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/NOUNS/NOUNS_15.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;它表示按照在线缆上出现的顺序排列4个字节（32个位），最左边的位是最早出现的最高有效位。注意位序的编号从0开始，分配给最高有效位的编号位0。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;16，&lt;strong&gt;inet_addr函数被废弃的原因&lt;/strong&gt;：它进行相同的转换，返回值为32位的网络字节序二进制值。但是，该函数存在两个问题：&lt;/p&gt;

&lt;p&gt;1）当出错时该函数返回 INADDR_NONE常值（通常是一个32位均为1的值）。这意味着点分十进制数串255.255.255.255（这是IPv4的有限广播地址）不能由该函数处理，因为它的二进制值被用来当作该函数的失败返回值。&lt;/p&gt;

&lt;p&gt;2）一些手册页面声明该函数出错时返回-1而不是INADDR_NONE。这样在对该函数的返回值（一个无符号的值）和一个负常值（-1）进行比较时可能会发生问题，具体取决于C编译器。&lt;/p&gt;

</description>
        <pubDate>Wed, 26 Jun 2019 15:00:00 +0800</pubDate>
        <link>http://localhost:4000/unp/2019/06/26/Unp-Nouns.html</link>
        <guid isPermaLink="true">http://localhost:4000/unp/2019/06/26/Unp-Nouns.html</guid>
        
        
        <category>unp</category>
        
      </item>
    
      <item>
        <title>[Apue]Linux-Sync、Fsync and Fdatasync</title>
        <description>&lt;h1 id=&quot;在linux操作系统上怎样保证对文件的更新内容成功持久化到硬盘&quot;&gt;在Linux操作系统上，怎样保证对文件的更新内容成功持久化到硬盘？&lt;/h1&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;1--write不够需要fsync&quot;&gt;1.  write不够，需要fsync&lt;/h2&gt;

&lt;p&gt;一般情况下，对硬盘（或者其他持久存储设备）文件的write操作，更新的只是内存中的页缓存（page cache）。但是脏页面不会立即更新到硬盘中，而是由操作系统统一调度，如，由专门的flusher内核线程在满足一定条件时（如一定时间间隔、内存中的脏页达到一定比例）内将脏页面同步到硬盘上（放入设备的IO请求队列）。&lt;/p&gt;

&lt;p&gt;因为write调用不会等到硬盘IO完成之后才返回，因此如果OS在write调用之后、硬盘同步之前崩溃，则数据可能丢失。虽然这样的时间窗口很小，但是对于需要保证事务的持久化（durability）和一致性（consistency）的数据库程序来说，write()所提供的“松散的异步语义”是不够的，通常需要OS提供的同步IO（synchronized-IO）原语来保证：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unistd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fsync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;fsync的功能是确保文件fd所有已修改的内容已经正确同步到硬盘上，该调用会阻塞等待直到设备报告IO完成。&lt;/p&gt;

&lt;p&gt;注意：如果采用内存映射文件的方式进行文件IO（使用mmap，将文件的page cache直接映射到进程的地址空间，通过写内存的方式修改文件），也有类似的系统调用来确保修改的内容完全同步到硬盘之上：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;incude&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sys&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mman&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;msync需要指定同步的地址区间，如此细粒度的控制似乎比fsync更加高效（因为应用程序通常知道自己的脏页位置），但实际上（Linux）kernel中有着十分高效的数据结构，能够很快地找出文件的脏页，使得fsync只会同步文件的修改内容。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;2--fsync的性能问题与fdatasync&quot;&gt;2.  fsync的性能问题，与fdatasync&lt;/h2&gt;

&lt;p&gt;除了同步文件的修改内容（脏页），fsync还会同步文件的描述信息（metadata，包括size、访问时间st_atime &amp;amp; st_mtime等等），因为文件的数据和metadata通常存在硬盘的不同地方，因此fsync至少需要两次IO写操作，fsync的man page这样说：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Unfortunately fsync() will always initialize two write operations : one for the newly written data and another one in order to update the modification time stored in the inode.
If the modification time is not a part of the transaction concept fdatasync() can be used to avoid unnecessary inode disk write operations.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;多余的一次IO操作，有多么昂贵呢？根据Wikipedia的数据，当前硬盘驱动的平均寻道时间（Average seek time）大约是3~15ms，7200RPM硬盘的平均旋转延迟（Average rotational latency）大约为4ms，因此一次IO操作的耗时大约为10ms左右。这个数字意味着什么？下文还会提到。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Posix同样定义了fdatasync，放宽了同步的语义以提高性能：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unistd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fdatasync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Fdatasync的功能与fsync类似，但是仅仅在必要的情况下才会同步metadata，因此可以减少一次IO写操作。那么，什么是“必要的情况”呢？根据man page中的解释：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;fdatasync does not flush modified metadata unless that metadata is needed in order to allow a subsequent data retrieval to be corretly handled.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;举例来说，文件的尺寸（st_size）如果变化，是需要立即同步的，否则OS一旦崩溃，即使文件的数据部分已同步，由于metadata没有同步，依然读不到修改的内容。而最后访问时间(atime) /修改时间(mtime)是不需要每次都同步的，只要应用程序对这两个时间戳没有苛刻的要求，基本无伤大雅。&lt;/p&gt;

&lt;p&gt;注意：open时的参数O_SYNC/O_DSYNC有着和fsync/fdatasync类似的语义：使每次write都会阻塞等待硬盘IO完成。（实际上，Linux对O_SYNC/O_DSYNC做了相同处理，没有满足Posix的要求，而是都实现了fdatasync的语义）相对于fsync/fdatasync，这样的设置不够灵活，应该很少使用。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;3-使用fdatasync优化日志同步&quot;&gt;3. 使用fdatasync优化日志同步&lt;/h2&gt;

&lt;p&gt;文章开头时已提到，为了满足事务要求，数据库的日志文件是常常需要同步IO的。由于需要同步等待硬盘IO完成，所以事务的提交操作常常十分耗时，成为性能的瓶颈。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在Berkeley DB下，如果开启了AUTO_COMMIT（所有独立的写操作自动具有事务语义）并使用默认的同步级别（日志完全同步到硬盘才返回），写一条记录的耗时大约为5~10ms级别，基本和一次IO操作（10ms）的耗时相同。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我们已经知道，在同步上fsync是低效的。但是如果需要使用fdatasync减少对metadata的更新，则需要确保文件的尺寸在write前后没有发生变化。日志文件天生是追加型（append-only）的，总是在不断增大，似乎很难利用好fdatasync。且看Berkeley DB是怎样处理日志文件的：&lt;/p&gt;

&lt;blockquote&gt;

  &lt;p&gt;&lt;br /&gt;1.每个log文件固定为10MB大小，从1开始编号，名称格式为“log.%010d”
&lt;br /&gt;2.每次log文件创建时，先写文件的最后1个page，将log文件扩展为10MB大小
&lt;br /&gt;3.向log文件中追加记录时，由于文件的尺寸不发生变化，使用fdatasync可以大大优化写log的效率
&lt;br /&gt;4.如果一个log文件写满了，则新建一个log文件，也只有一次同步metadata的开销&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;转至：
&lt;a href=&quot;https://blog.csdn.net/cywosp/article/details/8767327&quot;&gt;《linux 同步IO: sync、fsync与fdatasync》&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 24 Jun 2019 00:40:32 +0800</pubDate>
        <link>http://localhost:4000/apue/2019/06/24/Apue-Linux-Sync-Fsync-and-Fdatasync.html</link>
        <guid isPermaLink="true">http://localhost:4000/apue/2019/06/24/Apue-Linux-Sync-Fsync-and-Fdatasync.html</guid>
        
        
        <category>apue</category>
        
      </item>
    
      <item>
        <title>[Apue]Chapter 3</title>
        <description>&lt;h1 id=&quot;文件描述符&quot;&gt;文件描述符&lt;/h1&gt;
&lt;p&gt;概念：所有打开的文件都通过文件描述符，它是一个非负整数。&lt;/p&gt;

&lt;p&gt;原理 ：当打开一个现有文件或创建一个新文件时，内核向进程返回一个文件描述符。当读写一个文件时，使用open或creat返回的文件描述符标识该文件，将其作为参数传给read或write。&lt;/p&gt;

&lt;p&gt;补充：每个进程创建的时候都会打开三个文件：stdin(描述符0)，stdout(描述符1)和stderr(描述符2)。这三个文件对应符号常量 STDIN_FILENO、STDOUT_ FILENO、STDERR_ FILENO。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;函数open-和-openat&quot;&gt;函数Open 和 Openat&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/images/Apue/APUE_3/Unix3.3.1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;( “…”参数表示剩下的参数是可变的)&lt;/p&gt;

&lt;p&gt;作用：调用Open或Openat函数可以打开或创建一个文件。不过，Openat的出现是希望解决两个问题：&lt;/p&gt;

&lt;p&gt;（1）让线程可以使用相对路径名打开目录中的文件，而不局限于只能打开当前工作目录。&lt;/p&gt;

&lt;p&gt;（2）避免TOCTTOU错误，也称time-of-check-to-time-of-use (两个函数调用，其中一个的调用依赖另外一个调用的结果，那么这是不好的。)&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;函数creat&quot;&gt;函数Creat&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/images/Apue/APUE_3/Unix3.4.1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;作用：调用creat函数创建一个新文件，并用只写方式打开。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;函数close&quot;&gt;函数Close&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/images/Apue/APUE_3/Unix3.5.1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;作用：调用close函数关闭进程中一个打开的文件。关闭一个文件时还会释放该进程加在该文件上的所有记录锁。&lt;/p&gt;

&lt;p&gt;需要注意的是，内核中的资源不会被立刻释放掉，假设有一个或多个进程的多个文件文件描述符指向同一个内核的资源，那么只有当最后一个文件描述符被close时，内核的资源才会被释放。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;函数lseek&quot;&gt;函数Lseek&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/images/Apue/APUE_3/Unix3.6.1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;作用：调用lseek可以显示地为一个打开文件设置偏移量。&lt;/p&gt;

&lt;p&gt;由于Lseek只将当前的文件偏移量记录在内核中，所以并不会引起任何I/O操作。而且，偏移量是可以大于文件的当前长度。如果在偏移量后写入字节将加长该文件，就会在文件中构成一个空洞，没有被实际写入文件的所有字节由0 表示。空洞是否占用硬盘空间是由文件系统决定的。因为lseek使用的偏移量是用off_t类型表示的，所以实现需要根据各自平台选择大小合适的数据类型。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;函数read&quot;&gt;函数Read&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/images/Apue/APUE_3/Unix3.7.1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;作用：调用read函数从打开文件中读数据。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;函数write&quot;&gt;函数Write&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/images/Apue/APUE_3/Unix3.8.1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;作用：调用 write 函数向打开文件写数据。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;由于wirte是文件I/O，文件I/O是一种带有缓冲区的操作函数，而在实际的操作过程中，势必会出现阻塞与非阻塞(网络)相关的问题：&lt;/p&gt;

&lt;p&gt;write函数首先将进程需要发送的数据先放在进程缓冲区中，然后向socket的发送缓冲区进行拷贝。但是，可能会出现这样情况，即当进程缓冲区中的数据量大于此时发送缓冲区中所能接受的数据量时，若此时处于阻塞模式，应用进程将会被挂起，直到进程缓冲区中的数据全部拷贝到发送缓冲区中，注意此时内核也不会返回write函数，因此，在阻塞模式下，若write函数正常返回，这也并不代表数据已经完成被对方进程接收，至多只能说明数据已经被发送缓冲区完全接受；若是处于非阻塞模式，此时write操作将会失败，内核会立即返回EAGAIN错误，有时候在某些地方说会返回EWOULDBLOCK错误，其实它们都一样，只是分别用于不同的系统，前者主要是出现于GNU系统，后者主要出现在类BSD系统。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;文件共享&quot;&gt;文件共享&lt;/h1&gt;

&lt;p&gt;Unix系统支持在不同进程间共享打开文件。内核用三种数据结构来表示打开文件，如图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Apue/APUE_3/Unix3.10.1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;（1）：文件描述符表，它里面包含 标志(文件描述符标志)和文件指针(指向一个文件表项的指针)。&lt;/p&gt;

&lt;p&gt;（2）：文件表，它里面包含 文件状态标志(读，写，添写，同步和非阻塞等)，当前文件偏移量和v节点指针(指向该文件v节点表项的指针)。&lt;/p&gt;

&lt;p&gt;（3）：v节点表项，它里面包含文件类型和对此文件进行各种操作函数的指针。同时，它还包含i节点。这些信息的作用是在打开文件时从磁盘上读入内存。注意，Linux没有使用v节点。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;如果两个独立的进程各自打开了同一文件，文件关系如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Apue/APUE_3/Unix3.10.2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;之所以每个进程都能获得自己的进程和文件表项，是因为可以使每个进程都有自己对该文件的当前偏移量。文件描述符标志只应用于一个进程的一个描述符;而文件状态标志则应用于指向给定的文件表项的任何进程中的所有描述符。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;对上图的进一步说明：&lt;/p&gt;

&lt;p&gt;（1）A进程每次写入后，在文件表项中的当前文件偏移量将会增加(由写入的字节数决定)。如果这导致当前文件偏移量超出了当前文件超度，那么该文件将会加长。&lt;/p&gt;

&lt;p&gt;（2）如果用具有追加写标志的文件执行写操作时，对应标志(O_APPEND) 会被设置到文件表项的文件状态标志中。当进行写操作时，文件表项的当前文件偏移量会被设置为i节点表项中的当前文件长度。&lt;/p&gt;

&lt;p&gt;（3）如果一个文件用lseek函数定位到文件当前的尾端，那么文件表项的当前文件偏移量会被设置为i节点表项中的当前文件长度。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;原子操作&quot;&gt;原子操作&lt;/h1&gt;

&lt;p&gt;原子操作（atomic operation）指的是由多步组成的一个操作。如果该操作原子地执行，则要么执行完所有步骤，要么一步也不执行，不可能只执行所有步骤的一个子集。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;XSI扩展允许原子性地定位并执行I/O——Pread和Pwrite：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Apue/APUE_3/Unix3.11.1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;调用praed相当于调用lseek后调用read，注意：（Pwrite与Pread类似）&lt;/p&gt;

&lt;p&gt;（1）调用pread时，无法中断其定位和读操作。&lt;/p&gt;

&lt;p&gt;（2）不更新当前文件偏移量，也就是从固定位置读取。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;函数dup和dup2&quot;&gt;函数Dup和Dup2&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/images/Apue/APUE_3/Unix3.12.1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;作用：可用来复制一个现有的文件描述符。如下图所示：（Dup后的文件数据结构）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Apue/APUE_3/Unix3.12.2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;注意：调用dup函数等同于先调用&lt;label style=&quot;color:red&quot;&gt;fcntl(fd, F_DUPFD, 0)&lt;/label&gt; ，而调用 dup2 等同于调用 &lt;label style=&quot;color:red&quot;&gt;close(fd2)&lt;/label&gt; 和 &lt;label style=&quot;color:red&quot;&gt;fcntl(fd, F_DUPFD, fd2)&lt;/label&gt; 。 Dup2 是一个原子操作，它与 funtl 有一些不同的 ettno 。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;函数syncfsync和fdatasync&quot;&gt;函数Sync、Fsync和Fdatasync&lt;/h1&gt;

&lt;p&gt;首先要引入一个概念：延迟写，即，传统的UNIX实现在内核中设有缓冲区高速缓存或页面高速缓存，大多数磁盘I/O都通过缓冲进行。&lt;/p&gt;

&lt;p&gt;我们将数据写入文件时，内核通常先将该数据复制到其中一个缓冲区中。如果该缓冲区尚未写满，则并不将其排入输出队列。而是等待其写满或者当内核需要重用该缓冲区以便存放其他磁盘块数据时，再将该缓冲排入输出队列，然后待其到达队首时，才进行实际的I/O操作。&lt;/p&gt;

&lt;p&gt;延迟写减少了磁盘读写次数，但是却降低了文件内容的更新速度，使得欲写到文件中的数据在一段时间内并没有写到磁盘上。当系统发生故障时，这种延迟可能造成文件更新内容的丢失。为了保证磁盘上实际文件系统与缓冲区高速缓存中内容的一致性，UNIX系统提供了Sync、Fsync和Fdatasync三个函数。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Apue/APUE_3/Unix3.13.1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;sync 只是将所有修改过的块缓冲区排入写队列，然后就返回，它并不等待实际写磁盘操作结束。&lt;/p&gt;

&lt;p&gt;一般情况下，名为 update 的系统守护进程周期性地调用（一般每隔 30 秒） sync 函数。这就保证了定期冲洗（flush）内核的块缓冲区。命令 sync(1)也调用 sync 函数。&lt;/p&gt;

&lt;p&gt;Fsync 函数只对由文件描述符 fd 指定的一个文件起作用，并且等待写磁盘操作结束才返回。Fsync 可用于数据库这样的应用程序，这种应用程序需要确保修改过的块立即写到磁盘上。&lt;/p&gt;

&lt;p&gt;Fdatasync 函数类似于 fsync，但它只影响文件的数据部分。而除数据外， fsync 还会同步更新文件的属性。我经过查阅资料后，由于篇幅原因，因此自己另整理了一份：（点击下面标题进入）&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://waterwoodfountainhead.github.io/apue/2019/06/23/Apue-Linux-Sync-Fsync-and-Fdatasync.html&quot;&gt;《深刻探讨Sync、Fsync和Fdatasync》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;函数fcntl&quot;&gt;函数Fcntl&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/images/Apue/APUE_3/Unix3.14.1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;作用：(关于cmd参数的详解见APUE p66)&lt;/p&gt;

&lt;p&gt;（1）复制一个已有的描述符（cmd = F_DUPFD 或 F_DUPFD_CLOEXEC）。&lt;/p&gt;

&lt;p&gt;（2）获取/设置文件描述符标志（cmd = F_GETFD 或 F_SETFD）。&lt;/p&gt;

&lt;p&gt;（3）获取/设置文件状态标志（cmd = F_GETFL 或 F_SETFL）。&lt;/p&gt;

&lt;p&gt;（4）获取/设置异步 I/O 所有权（cmd = F_GETOWN 或 F_SETOWN）。&lt;/p&gt;

&lt;p&gt;（5）获取/设置记录锁（cmd = F_GETLK、 F_SETLK 或 F_SETLKW）。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;关于同步写和延迟写&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当支持同步写时，系统时间和时钟时间会显著增加。如果同步写所用的系统时间不比延迟写增加的多时，要么操作系统对延迟写和同步写操作的工作量相同;要么 O_SYNC 标志并没有起到期望的作用，在这种情况下，Linux 操作系统并不允许我们用 fcntl 设置 O_SYNC 标志，而是显示失败但没有返回出错（如果在文件打开时能指定该标志，我们应该遵重这个标志的）。&lt;/p&gt;

&lt;p&gt;同步写比延迟写所消耗的时间增加了很多，而且在同步写后再调用函数 fsync 并不产生测量结果上的显著差别。不过，在延迟写后增加一个 fsync 函数调用，测量结果的差别也不大。其可能原因是，在向某个文件写入新数据时，操作系统已经将以前写入的数据都冲洗到了磁盘上，所以在调用函数 fsync 时只需要做很少的工作。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;函数ioctl&quot;&gt;函数ioctl&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/images/Apue/APUE_3/Unix3.15.1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;作用：它是设备驱动程序中设备控制接口函数，一个字符设备驱动通常会实现设备打开、关闭、读、写等功能，在一些需要细分的情境下，如果需要扩展新的功能，通常以增设 ioctl() 命令的方式实现。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;对于用户态程序的ioctl&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在实际应用中，ioctl 最常见的 errorno 值为 ENOTTY（error not a typewriter），顾名思义，即第一个参数 fd 指向的不是一个字符设备，不支持 ioctl 操作，这时候应该检查前面的 open 函数是否出错或者设备路径是否正确。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;对于驱动程序的ioctl&lt;/strong&gt;
&lt;img src=&quot;/images/Apue/APUE_3/Unix3.15.2.png&quot; alt=&quot;&quot; /&gt;
unlocked_ioctl，顾名思义，应该在无大内核锁（BKL）的情况下调用；compat_ioctl，compat 全称 compatible（兼容的），主要目的是为 64 位系统提供 32 位 ioctl 的兼容方法，也是在无大内核锁的情况下调用。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;devfd-目录&quot;&gt;/dev/fd 目录&lt;/h1&gt;

&lt;p&gt;概念：/dev/fd文件主要由shell使用，它允许作为路径名被程序作为参数调用。打开文件/dev/fd/n 等效于复制描述符n (假设描述符n是打开的)。&lt;/p&gt;

&lt;p&gt;如果你在一个程序调用creat，并且路径名参数是&lt;label style=&quot;color:red&quot;&gt;/dev/fd/1&lt;/label&gt;。虽然，程序可以工作，但是，你一定要小心。你在 Linux 上这么做必须非常小心，因为 Linux 实现使用指向实际文件的符号链接，所以在&lt;label style=&quot;color:red&quot;&gt;/dev/fd&lt;/label&gt;文件上使用 creat 会导致底层文件被截断。&lt;label style=&quot;color:red&quot;&gt;/dev/fd&lt;/label&gt; 在Linux实现中是个例外，它把文件描述符映射成指向底层物理文件的符号链接。&lt;/p&gt;
</description>
        <pubDate>Mon, 24 Jun 2019 00:38:32 +0800</pubDate>
        <link>http://localhost:4000/apue/2019/06/24/Apue-Chapter-3.html</link>
        <guid isPermaLink="true">http://localhost:4000/apue/2019/06/24/Apue-Chapter-3.html</guid>
        
        
        <category>apue</category>
        
      </item>
    
      <item>
        <title>[Other]First Blog</title>
        <description>&lt;p&gt;祝愿我自己的质量博文越来越多！
&lt;img src=&quot;/images/Other/MyImages.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 20 Jun 2019 00:38:32 +0800</pubDate>
        <link>http://localhost:4000/other/2019/06/20/First-Blog.html</link>
        <guid isPermaLink="true">http://localhost:4000/other/2019/06/20/First-Blog.html</guid>
        
        
        <category>other</category>
        
      </item>
    
  </channel>
</rss>
