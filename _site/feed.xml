<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Fountainhead</title>
    <description>Blog</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 27 Jun 2019 00:42:56 +0800</pubDate>
    <lastBuildDate>Thu, 27 Jun 2019 00:42:56 +0800</lastBuildDate>
    <generator>Jekyll v3.8.5</generator>
    
      <item>
        <title>[Unp]Nouns</title>
        <description>&lt;p&gt;1，&lt;strong&gt;路由器&lt;/strong&gt;是广域网的设备。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;2，&lt;strong&gt;因特网&lt;/strong&gt;是当今最大的广域网。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;3，TCP/IP协议概况&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/NOUNS/NOUNS_3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;4，&lt;strong&gt;RFC&lt;/strong&gt;——所有网际协议由一个或多个称为请求评注（Request for Comments，RFC）的文档定义，第三条内容里面的协议就是它们的正式规范。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;5，&lt;strong&gt;IPv4/IPv6主机&lt;/strong&gt; 或 &lt;strong&gt;双栈主机&lt;/strong&gt; 表示同时支持IPv4和IPv6的主机。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;6，&lt;strong&gt;被动打开（passive open）&lt;/strong&gt;，通常通过调用socket、bind和listen这3个函数来完成。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;7，&lt;strong&gt;主动打开（active open）&lt;/strong&gt;，通过调用connect发起。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;8，&lt;strong&gt;SYN&lt;/strong&gt;，一个同步分节。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;9，&lt;strong&gt;ACK&lt;/strong&gt;，一个确认分节。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;10，&lt;strong&gt;主动关闭（active close）&lt;/strong&gt;，某个应用进程首先调用close，称该端执行主动关闭。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;11，&lt;strong&gt;MSL&lt;/strong&gt;，它是任何IP数据报能够在因特网中存活的最长时间。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;12，&lt;strong&gt;迷途&lt;/strong&gt;，通常是路由异常的结果。&lt;/p&gt;

&lt;p&gt;例如：某个路由器崩溃或某两个路由器之间的某个链路断开时，路由协议需花数秒钟到数分钟的时间才能稳定并找出另一条通路。在这段时间内有可能发生路由循环（路由器A把分组发送给路由器B，而B再把它们发送回A），我们关心的分组可能就此陷入这样的循环。&lt;/p&gt;
</description>
        <pubDate>Wed, 26 Jun 2019 15:00:00 +0800</pubDate>
        <link>http://localhost:4000/unp/2019/06/26/Unp-Nouns.html</link>
        <guid isPermaLink="true">http://localhost:4000/unp/2019/06/26/Unp-Nouns.html</guid>
        
        
        <category>unp</category>
        
      </item>
    
      <item>
        <title>[Apue]Linux-Sync、Fsync and Fdatasync</title>
        <description>&lt;h1 id=&quot;在linux操作系统上怎样保证对文件的更新内容成功持久化到硬盘&quot;&gt;在Linux操作系统上，怎样保证对文件的更新内容成功持久化到硬盘？&lt;/h1&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;1--write不够需要fsync&quot;&gt;1.  write不够，需要fsync&lt;/h2&gt;

&lt;p&gt;一般情况下，对硬盘（或者其他持久存储设备）文件的write操作，更新的只是内存中的页缓存（page cache）。但是脏页面不会立即更新到硬盘中，而是由操作系统统一调度，如，由专门的flusher内核线程在满足一定条件时（如一定时间间隔、内存中的脏页达到一定比例）内将脏页面同步到硬盘上（放入设备的IO请求队列）。&lt;/p&gt;

&lt;p&gt;因为write调用不会等到硬盘IO完成之后才返回，因此如果OS在write调用之后、硬盘同步之前崩溃，则数据可能丢失。虽然这样的时间窗口很小，但是对于需要保证事务的持久化（durability）和一致性（consistency）的数据库程序来说，write()所提供的“松散的异步语义”是不够的，通常需要OS提供的同步IO（synchronized-IO）原语来保证：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unistd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fsync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;fsync的功能是确保文件fd所有已修改的内容已经正确同步到硬盘上，该调用会阻塞等待直到设备报告IO完成。&lt;/p&gt;

&lt;p&gt;注意：如果采用内存映射文件的方式进行文件IO（使用mmap，将文件的page cache直接映射到进程的地址空间，通过写内存的方式修改文件），也有类似的系统调用来确保修改的内容完全同步到硬盘之上：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;incude&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sys&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mman&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;msync需要指定同步的地址区间，如此细粒度的控制似乎比fsync更加高效（因为应用程序通常知道自己的脏页位置），但实际上（Linux）kernel中有着十分高效的数据结构，能够很快地找出文件的脏页，使得fsync只会同步文件的修改内容。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;2--fsync的性能问题与fdatasync&quot;&gt;2.  fsync的性能问题，与fdatasync&lt;/h2&gt;

&lt;p&gt;除了同步文件的修改内容（脏页），fsync还会同步文件的描述信息（metadata，包括size、访问时间st_atime &amp;amp; st_mtime等等），因为文件的数据和metadata通常存在硬盘的不同地方，因此fsync至少需要两次IO写操作，fsync的man page这样说：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Unfortunately fsync() will always initialize two write operations : one for the newly written data and another one in order to update the modification time stored in the inode.
If the modification time is not a part of the transaction concept fdatasync() can be used to avoid unnecessary inode disk write operations.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;多余的一次IO操作，有多么昂贵呢？根据Wikipedia的数据，当前硬盘驱动的平均寻道时间（Average seek time）大约是3~15ms，7200RPM硬盘的平均旋转延迟（Average rotational latency）大约为4ms，因此一次IO操作的耗时大约为10ms左右。这个数字意味着什么？下文还会提到。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Posix同样定义了fdatasync，放宽了同步的语义以提高性能：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unistd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fdatasync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Fdatasync的功能与fsync类似，但是仅仅在必要的情况下才会同步metadata，因此可以减少一次IO写操作。那么，什么是“必要的情况”呢？根据man page中的解释：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;fdatasync does not flush modified metadata unless that metadata is needed in order to allow a subsequent data retrieval to be corretly handled.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;举例来说，文件的尺寸（st_size）如果变化，是需要立即同步的，否则OS一旦崩溃，即使文件的数据部分已同步，由于metadata没有同步，依然读不到修改的内容。而最后访问时间(atime) /修改时间(mtime)是不需要每次都同步的，只要应用程序对这两个时间戳没有苛刻的要求，基本无伤大雅。&lt;/p&gt;

&lt;p&gt;注意：open时的参数O_SYNC/O_DSYNC有着和fsync/fdatasync类似的语义：使每次write都会阻塞等待硬盘IO完成。（实际上，Linux对O_SYNC/O_DSYNC做了相同处理，没有满足Posix的要求，而是都实现了fdatasync的语义）相对于fsync/fdatasync，这样的设置不够灵活，应该很少使用。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;3-使用fdatasync优化日志同步&quot;&gt;3. 使用fdatasync优化日志同步&lt;/h2&gt;

&lt;p&gt;文章开头时已提到，为了满足事务要求，数据库的日志文件是常常需要同步IO的。由于需要同步等待硬盘IO完成，所以事务的提交操作常常十分耗时，成为性能的瓶颈。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在Berkeley DB下，如果开启了AUTO_COMMIT（所有独立的写操作自动具有事务语义）并使用默认的同步级别（日志完全同步到硬盘才返回），写一条记录的耗时大约为5~10ms级别，基本和一次IO操作（10ms）的耗时相同。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我们已经知道，在同步上fsync是低效的。但是如果需要使用fdatasync减少对metadata的更新，则需要确保文件的尺寸在write前后没有发生变化。日志文件天生是追加型（append-only）的，总是在不断增大，似乎很难利用好fdatasync。且看Berkeley DB是怎样处理日志文件的：&lt;/p&gt;

&lt;blockquote&gt;

  &lt;p&gt;&lt;br /&gt;1.每个log文件固定为10MB大小，从1开始编号，名称格式为“log.%010d”
&lt;br /&gt;2.每次log文件创建时，先写文件的最后1个page，将log文件扩展为10MB大小
&lt;br /&gt;3.向log文件中追加记录时，由于文件的尺寸不发生变化，使用fdatasync可以大大优化写log的效率
&lt;br /&gt;4.如果一个log文件写满了，则新建一个log文件，也只有一次同步metadata的开销&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;转至：
&lt;a href=&quot;https://blog.csdn.net/cywosp/article/details/8767327&quot;&gt;《linux 同步IO: sync、fsync与fdatasync》&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 24 Jun 2019 00:40:32 +0800</pubDate>
        <link>http://localhost:4000/apue/2019/06/24/Apue-Linux-Sync-Fsync-and-Fdatasync.html</link>
        <guid isPermaLink="true">http://localhost:4000/apue/2019/06/24/Apue-Linux-Sync-Fsync-and-Fdatasync.html</guid>
        
        
        <category>apue</category>
        
      </item>
    
      <item>
        <title>[Apue]Chapter 3</title>
        <description>&lt;h1 id=&quot;文件描述符&quot;&gt;文件描述符&lt;/h1&gt;
&lt;p&gt;概念：所有打开的文件都通过文件描述符，它是一个非负整数。&lt;/p&gt;

&lt;p&gt;原理 ：当打开一个现有文件或创建一个新文件时，内核向进程返回一个文件描述符。当读写一个文件时，使用open或creat返回的文件描述符标识该文件，将其作为参数传给read或write。&lt;/p&gt;

&lt;p&gt;补充：每个进程创建的时候都会打开三个文件：stdin(描述符0)，stdout(描述符1)和stderr(描述符2)。这三个文件对应符号常量 STDIN_FILENO、STDOUT_ FILENO、STDERR_ FILENO。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;函数open-和-openat&quot;&gt;函数Open 和 Openat&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/images/Apue/APUE_3/Unix3.3.1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;( “…”参数表示剩下的参数是可变的)&lt;/p&gt;

&lt;p&gt;作用：调用Open或Openat函数可以打开或创建一个文件。不过，Openat的出现是希望解决两个问题：&lt;/p&gt;

&lt;p&gt;（1）让线程可以使用相对路径名打开目录中的文件，而不局限于只能打开当前工作目录。&lt;/p&gt;

&lt;p&gt;（2）避免TOCTTOU错误，也称time-of-check-to-time-of-use (两个函数调用，其中一个的调用依赖另外一个调用的结果，那么这是不好的。)&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;函数creat&quot;&gt;函数Creat&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/images/Apue/APUE_3/Unix3.4.1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;作用：调用creat函数创建一个新文件，并用只写方式打开。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;函数close&quot;&gt;函数Close&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/images/Apue/APUE_3/Unix3.5.1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;作用：调用close函数关闭进程中一个打开的文件。关闭一个文件时还会释放该进程加在该文件上的所有记录锁。&lt;/p&gt;

&lt;p&gt;需要注意的是，内核中的资源不会被立刻释放掉，假设有一个或多个进程的多个文件文件描述符指向同一个内核的资源，那么只有当最后一个文件描述符被close时，内核的资源才会被释放。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;函数lseek&quot;&gt;函数Lseek&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/images/Apue/APUE_3/Unix3.6.1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;作用：调用lseek可以显示地为一个打开文件设置偏移量。&lt;/p&gt;

&lt;p&gt;由于Lseek只将当前的文件偏移量记录在内核中，所以并不会引起任何I/O操作。而且，偏移量是可以大于文件的当前长度。如果在偏移量后写入字节将加长该文件，就会在文件中构成一个空洞，没有被实际写入文件的所有字节由0 表示。空洞是否占用硬盘空间是由文件系统决定的。因为lseek使用的偏移量是用off_t类型表示的，所以实现需要根据各自平台选择大小合适的数据类型。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;函数read&quot;&gt;函数Read&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/images/Apue/APUE_3/Unix3.7.1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;作用：调用read函数从打开文件中读数据。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;函数write&quot;&gt;函数Write&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/images/Apue/APUE_3/Unix3.8.1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;作用：调用 write 函数向打开文件写数据。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;由于wirte是文件I/O，文件I/O是一种带有缓冲区的操作函数，而在实际的操作过程中，势必会出现阻塞与非阻塞(网络)相关的问题：&lt;/p&gt;

&lt;p&gt;write函数首先将进程需要发送的数据先放在进程缓冲区中，然后向socket的发送缓冲区进行拷贝。但是，可能会出现这样情况，即当进程缓冲区中的数据量大于此时发送缓冲区中所能接受的数据量时，若此时处于阻塞模式，应用进程将会被挂起，直到进程缓冲区中的数据全部拷贝到发送缓冲区中，注意此时内核也不会返回write函数，因此，在阻塞模式下，若write函数正常返回，这也并不代表数据已经完成被对方进程接收，至多只能说明数据已经被发送缓冲区完全接受；若是处于非阻塞模式，此时write操作将会失败，内核会立即返回EAGAIN错误，有时候在某些地方说会返回EWOULDBLOCK错误，其实它们都一样，只是分别用于不同的系统，前者主要是出现于GNU系统，后者主要出现在类BSD系统。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;文件共享&quot;&gt;文件共享&lt;/h1&gt;

&lt;p&gt;Unix系统支持在不同进程间共享打开文件。内核用三种数据结构来表示打开文件，如图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Apue/APUE_3/Unix3.10.1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;（1）：文件描述符表，它里面包含 标志(文件描述符标志)和文件指针(指向一个文件表项的指针)。&lt;/p&gt;

&lt;p&gt;（2）：文件表，它里面包含 文件状态标志(读，写，添写，同步和非阻塞等)，当前文件偏移量和v节点指针(指向该文件v节点表项的指针)。&lt;/p&gt;

&lt;p&gt;（3）：v节点表项，它里面包含文件类型和对此文件进行各种操作函数的指针。同时，它还包含i节点。这些信息的作用是在打开文件时从磁盘上读入内存。注意，Linux没有使用v节点。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;如果两个独立的进程各自打开了同一文件，文件关系如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Apue/APUE_3/Unix3.10.2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;之所以每个进程都能获得自己的进程和文件表项，是因为可以使每个进程都有自己对该文件的当前偏移量。文件描述符标志只应用于一个进程的一个描述符;而文件状态标志则应用于指向给定的文件表项的任何进程中的所有描述符。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;对上图的进一步说明：&lt;/p&gt;

&lt;p&gt;（1）A进程每次写入后，在文件表项中的当前文件偏移量将会增加(由写入的字节数决定)。如果这导致当前文件偏移量超出了当前文件超度，那么该文件将会加长。&lt;/p&gt;

&lt;p&gt;（2）如果用具有追加写标志的文件执行写操作时，对应标志(O_APPEND) 会被设置到文件表项的文件状态标志中。当进行写操作时，文件表项的当前文件偏移量会被设置为i节点表项中的当前文件长度。&lt;/p&gt;

&lt;p&gt;（3）如果一个文件用lseek函数定位到文件当前的尾端，那么文件表项的当前文件偏移量会被设置为i节点表项中的当前文件长度。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;原子操作&quot;&gt;原子操作&lt;/h1&gt;

&lt;p&gt;原子操作（atomic operation）指的是由多步组成的一个操作。如果该操作原子地执行，则要么执行完所有步骤，要么一步也不执行，不可能只执行所有步骤的一个子集。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;XSI扩展允许原子性地定位并执行I/O——Pread和Pwrite：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Apue/APUE_3/Unix3.11.1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;调用praed相当于调用lseek后调用read，注意：（Pwrite与Pread类似）&lt;/p&gt;

&lt;p&gt;（1）调用pread时，无法中断其定位和读操作。&lt;/p&gt;

&lt;p&gt;（2）不更新当前文件偏移量，也就是从固定位置读取。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;函数dup和dup2&quot;&gt;函数Dup和Dup2&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/images/Apue/APUE_3/Unix3.12.1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;作用：可用来复制一个现有的文件描述符。如下图所示：（Dup后的文件数据结构）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Apue/APUE_3/Unix3.12.2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;注意：调用dup函数等同于先调用&lt;label style=&quot;color:red&quot;&gt;fcntl(fd, F_DUPFD, 0)&lt;/label&gt; ，而调用 dup2 等同于调用 &lt;label style=&quot;color:red&quot;&gt;close(fd2)&lt;/label&gt; 和 &lt;label style=&quot;color:red&quot;&gt;fcntl(fd, F_DUPFD, fd2)&lt;/label&gt; 。 Dup2 是一个原子操作，它与 funtl 有一些不同的 ettno 。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;函数syncfsync和fdatasync&quot;&gt;函数Sync、Fsync和Fdatasync&lt;/h1&gt;

&lt;p&gt;首先要引入一个概念：延迟写，即，传统的UNIX实现在内核中设有缓冲区高速缓存或页面高速缓存，大多数磁盘I/O都通过缓冲进行。&lt;/p&gt;

&lt;p&gt;我们将数据写入文件时，内核通常先将该数据复制到其中一个缓冲区中。如果该缓冲区尚未写满，则并不将其排入输出队列。而是等待其写满或者当内核需要重用该缓冲区以便存放其他磁盘块数据时，再将该缓冲排入输出队列，然后待其到达队首时，才进行实际的I/O操作。&lt;/p&gt;

&lt;p&gt;延迟写减少了磁盘读写次数，但是却降低了文件内容的更新速度，使得欲写到文件中的数据在一段时间内并没有写到磁盘上。当系统发生故障时，这种延迟可能造成文件更新内容的丢失。为了保证磁盘上实际文件系统与缓冲区高速缓存中内容的一致性，UNIX系统提供了Sync、Fsync和Fdatasync三个函数。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Apue/APUE_3/Unix3.13.1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;sync 只是将所有修改过的块缓冲区排入写队列，然后就返回，它并不等待实际写磁盘操作结束。&lt;/p&gt;

&lt;p&gt;一般情况下，名为 update 的系统守护进程周期性地调用（一般每隔 30 秒） sync 函数。这就保证了定期冲洗（flush）内核的块缓冲区。命令 sync(1)也调用 sync 函数。&lt;/p&gt;

&lt;p&gt;Fsync 函数只对由文件描述符 fd 指定的一个文件起作用，并且等待写磁盘操作结束才返回。Fsync 可用于数据库这样的应用程序，这种应用程序需要确保修改过的块立即写到磁盘上。&lt;/p&gt;

&lt;p&gt;Fdatasync 函数类似于 fsync，但它只影响文件的数据部分。而除数据外， fsync 还会同步更新文件的属性。我经过查阅资料后，由于篇幅原因，因此自己另整理了一份：（点击下面标题进入）&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://waterwoodfountainhead.github.io/apue/2019/06/23/Apue-Linux-Sync-Fsync-and-Fdatasync.html&quot;&gt;《深刻探讨Sync、Fsync和Fdatasync》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;函数fcntl&quot;&gt;函数Fcntl&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/images/Apue/APUE_3/Unix3.14.1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;作用：(关于cmd参数的详解见APUE p66)&lt;/p&gt;

&lt;p&gt;（1）复制一个已有的描述符（cmd = F_DUPFD 或 F_DUPFD_CLOEXEC）。&lt;/p&gt;

&lt;p&gt;（2）获取/设置文件描述符标志（cmd = F_GETFD 或 F_SETFD）。&lt;/p&gt;

&lt;p&gt;（3）获取/设置文件状态标志（cmd = F_GETFL 或 F_SETFL）。&lt;/p&gt;

&lt;p&gt;（4）获取/设置异步 I/O 所有权（cmd = F_GETOWN 或 F_SETOWN）。&lt;/p&gt;

&lt;p&gt;（5）获取/设置记录锁（cmd = F_GETLK、 F_SETLK 或 F_SETLKW）。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;关于同步写和延迟写&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当支持同步写时，系统时间和时钟时间会显著增加。如果同步写所用的系统时间不比延迟写增加的多时，要么操作系统对延迟写和同步写操作的工作量相同;要么 O_SYNC 标志并没有起到期望的作用，在这种情况下，Linux 操作系统并不允许我们用 fcntl 设置 O_SYNC 标志，而是显示失败但没有返回出错（如果在文件打开时能指定该标志，我们应该遵重这个标志的）。&lt;/p&gt;

&lt;p&gt;同步写比延迟写所消耗的时间增加了很多，而且在同步写后再调用函数 fsync 并不产生测量结果上的显著差别。不过，在延迟写后增加一个 fsync 函数调用，测量结果的差别也不大。其可能原因是，在向某个文件写入新数据时，操作系统已经将以前写入的数据都冲洗到了磁盘上，所以在调用函数 fsync 时只需要做很少的工作。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;函数ioctl&quot;&gt;函数ioctl&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/images/Apue/APUE_3/Unix3.15.1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;作用：它是设备驱动程序中设备控制接口函数，一个字符设备驱动通常会实现设备打开、关闭、读、写等功能，在一些需要细分的情境下，如果需要扩展新的功能，通常以增设 ioctl() 命令的方式实现。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;对于用户态程序的ioctl&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在实际应用中，ioctl 最常见的 errorno 值为 ENOTTY（error not a typewriter），顾名思义，即第一个参数 fd 指向的不是一个字符设备，不支持 ioctl 操作，这时候应该检查前面的 open 函数是否出错或者设备路径是否正确。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;对于驱动程序的ioctl&lt;/strong&gt;
&lt;img src=&quot;/images/Apue/APUE_3/Unix3.15.2.png&quot; alt=&quot;&quot; /&gt;
unlocked_ioctl，顾名思义，应该在无大内核锁（BKL）的情况下调用；compat_ioctl，compat 全称 compatible（兼容的），主要目的是为 64 位系统提供 32 位 ioctl 的兼容方法，也是在无大内核锁的情况下调用。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;devfd-目录&quot;&gt;/dev/fd 目录&lt;/h1&gt;

&lt;p&gt;概念：/dev/fd文件主要由shell使用，它允许作为路径名被程序作为参数调用。打开文件/dev/fd/n 等效于复制描述符n (假设描述符n是打开的)。&lt;/p&gt;

&lt;p&gt;如果你在一个程序调用creat，并且路径名参数是&lt;label style=&quot;color:red&quot;&gt;/dev/fd/1&lt;/label&gt;。虽然，程序可以工作，但是，你一定要小心。你在 Linux 上这么做必须非常小心，因为 Linux 实现使用指向实际文件的符号链接，所以在&lt;label style=&quot;color:red&quot;&gt;/dev/fd&lt;/label&gt;文件上使用 creat 会导致底层文件被截断。&lt;label style=&quot;color:red&quot;&gt;/dev/fd&lt;/label&gt; 在Linux实现中是个例外，它把文件描述符映射成指向底层物理文件的符号链接。&lt;/p&gt;
</description>
        <pubDate>Mon, 24 Jun 2019 00:38:32 +0800</pubDate>
        <link>http://localhost:4000/apue/2019/06/24/Apue-Chapter-3.html</link>
        <guid isPermaLink="true">http://localhost:4000/apue/2019/06/24/Apue-Chapter-3.html</guid>
        
        
        <category>apue</category>
        
      </item>
    
      <item>
        <title>[Other]First Blog</title>
        <description>&lt;p&gt;祝愿我自己的质量博文越来越多！
&lt;img src=&quot;/images/Other/MyImages.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 20 Jun 2019 00:38:32 +0800</pubDate>
        <link>http://localhost:4000/other/2019/06/20/First-Blog.html</link>
        <guid isPermaLink="true">http://localhost:4000/other/2019/06/20/First-Blog.html</guid>
        
        
        <category>other</category>
        
      </item>
    
  </channel>
</rss>
