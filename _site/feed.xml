<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Fountainhead</title>
    <description>Blog</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 18 Jul 2019 12:03:00 +0800</pubDate>
    <lastBuildDate>Thu, 18 Jul 2019 12:03:00 +0800</lastBuildDate>
    <generator>Jekyll v3.8.5</generator>
    
      <item>
        <title>[Apue]Chapter 10 - c</title>
        <description>&lt;h1 id=&quot;信号集&quot;&gt;信号集&lt;/h1&gt;

&lt;p&gt;信号集（signal set）是一个能表示多个信号的数据类型。&lt;/p&gt;

&lt;p&gt;一般而言，不能用整型量中的一位代表一种信号，也就是说，不能用一个整型变量表示信号集&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;POSIX.1定义数据类型 sigset_t，它可以包含一个信号集，并且定义了下列 5个处理信号集的函数。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Apue/APUE_10/APUE_10_9.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;函数 sigemptyset 初始化由 set 指向的信号集，清除其中所有信号。&lt;/p&gt;

&lt;p&gt;函数 sigfillset 初始化由 set 指向的信号集，使其包括所有信号。&lt;/p&gt;

&lt;p&gt;函数 sigaddset 将一个信号添加到已有的信号集中。&lt;/p&gt;

&lt;p&gt;函数 sigdelset 则从信号集中删除一个信号。&lt;/p&gt;

&lt;p&gt;函数 sigismember 判断给定的信号（signo 参数），是否时信号集中（set 参数）的一个成员。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（1）&lt;/strong&gt;所有应用程序在使用信号集前，要对该信号集调用 sigemptyset 或 sigfillset 一次。&lt;/p&gt;

&lt;p&gt;这是因为 C编译程序 把 不赋初值的外部变量和静态变量都初始化为0。一旦初始化了一个信号集，以后就可以在该信号集中操作（增、删）特定的信号。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（2）&lt;/strong&gt;所有以信号集作为参数的函数，信号集参数通常以指针的形式传递。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;函数-sigprocmask&quot;&gt;函数 sigprocmask&lt;/h1&gt;

&lt;p&gt;调用函数 sigprocmask 可以检测 或 更改，或 同时进行检测和更改进程的信号屏蔽字。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Apue/APUE_10/APUE_10_10.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;参数：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（1）&lt;/strong&gt;参数 oset&lt;/p&gt;

&lt;p&gt;如果它是非空指针，那么进程的当前信号屏蔽字通过 oset 返回。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（2）&lt;/strong&gt;参数 set&lt;/p&gt;

&lt;p&gt;a，如果 set 参数是一个非空指针，那么 how 参数表示如何修改当前信号屏蔽字。下图说明了 how 参数可选的值。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Apue/APUE_10/APUE_10_11.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;SIG_BLOCK 是或操作，而SIG_SETMASK 则是赋值操作。注意，不能阻塞 SIGKILL 和 SIGSTOP 信
号。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;b，如果 set 参数是一个空指针，那么不改变该进程的信号屏蔽字， how 参数的值也没有意义。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;在调用 sigprocmask 函数后，如果有任何（未决的、不再阻塞的）信号，那么在 sigprocmask 函数返回前，至少要把其中的一个信号发送给该进程。&lt;/p&gt;

&lt;p&gt;sigprocmask 函数 仅为单线程定义的。处理多线程进程中的信号屏蔽字，需要使用另一个函数。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;函数-sigpending&quot;&gt;函数 sigpending&lt;/h1&gt;

&lt;p&gt;sigpending 函数返回一个信号集，对于调用进程而言，其中的各个信号是阻塞的、不能传送的。因此，该信号当前是未决的。该信号集通过 set 参数返回。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Apue/APUE_10/APUE_10_12.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;函数-sigaction&quot;&gt;函数 sigaction&lt;/h1&gt;

&lt;p&gt;sigaction 函数的功能是：检查 或 修改 （或 检查并修改）与指定信号相关联的处理动作。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Apue/APUE_10/APUE_10_13.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;参数 signo 是要检测或修改其具体动作的信号编号。&lt;/p&gt;

&lt;p&gt;如果 act 指针参数非空，那么就要修改信号的动作。&lt;/p&gt;

&lt;p&gt;如果 oact 指针参数非空，那么系统经由 oact 指针返回该信号的上一个动作。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;参数 act 和 参数 oact 使用的结构内容，如下：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Apue/APUE_10/APUE_10_14.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Tue, 16 Jul 2019 00:59:32 +0800</pubDate>
        <link>http://localhost:4000/apue/2019/07/16/Apue-Chapter-10-c.html</link>
        <guid isPermaLink="true">http://localhost:4000/apue/2019/07/16/Apue-Chapter-10-c.html</guid>
        
        
        <category>apue</category>
        
      </item>
    
      <item>
        <title>[Apue]Chapter 10 - b</title>
        <description>&lt;h1 id=&quot;函数-signal&quot;&gt;函数 signal&lt;/h1&gt;

&lt;p&gt;UNIX 系统信号机制最简单的接口是 signal 函数。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Apue/APUE_10/APUE_10_2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;signo 返回值是一个函数地址，该函数的参数是整型。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
signal 函数参数：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;signo 参数是信号名(SIGXXXX)。signo 是一个整型数。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;func 是函数指针。func 的值是常量 SIG_IGN、常量SIG_DFL ，或着是 当接收到这个信号后，要调用的函数的地址。
&lt;br /&gt;&lt;br /&gt;
如果制定SIG_IGN，则向内核表示忽略此信号（SIGKILL 和 SIGSTOP 不能被忽略）。
&lt;br /&gt;&lt;br /&gt;
如果制定SIG_DFL，则表示，接收到这个信号后的动作是系统默认动作。
&lt;br /&gt;&lt;br /&gt;
当func 参数是函数的地址时，那么在信号发生时，调用该函数。我们称这种处理为 ‘捕捉该信号”；称这个函数为 “信号处理函数” 或 ”信号捕捉函数“。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;不可靠的信号&quot;&gt;不可靠的信号&lt;/h1&gt;

&lt;p&gt;不可靠的信号是指，信号可能会丢失。一个信号发生了，但进程却可能一直不知道这一点。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;早期版本有一个问题：在进程每次接收到信号，然后进行处理时，将该信号动作重置为默认值。
例如：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Apue/APUE_10/APUE_10_3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;这段代码的一个问题是：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;从信号发生后，一直到信号处理程序调用 signal 函数，这中间有一个时间窗口。在此段时间中，可能会发生另一次中断信号。第二个信号会造成执行默认动作，而对中断信号的默认动作是终止该进程。这种类型的程序段在大多数情况下会正常工作，使得我们认为它们是正确无误的，而实际上却并非如此。&lt;/p&gt;

&lt;p&gt;我们可以对每种信号只捕捉一次，从而回避这一点。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;早期版本的另外一个问题：在进程不希望某种信号发生时，它不能关闭该信号。例如：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Apue/APUE_10/APUE_10_4.png&quot; alt=&quot;它捕捉一个信号，然后设置一个表示该信号已发生的标志&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;这段代码的含义：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;进程调用 pause 函数使自己休眠，直到捕捉到一个信号后苏醒。当捕捉到信号时，信号处理程序将标志 sig_int_flag 设置为非 0 值。从信号处理程序返回后，内核自动将该进程唤醒，它检测到该标志为非 0，然后执行它所需做的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;这段代码的问题是：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在检测sig_int_flag 之后、调用 pause 之前会产生一个时间窗口。如果在这段时间内发生信号，那么此进程在调用 pause 时，可能将永久休眠（假定此信号不会再次产生）。于是，这次发生的信号也就丢失了。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;中断的系统调用&quot;&gt;中断的系统调用&lt;/h1&gt;

&lt;p&gt;早期Unix 系统的一个特性是：如果进程在执行一个低速系统调用，在阻塞期间捕捉到一个信号，则该低速系统调用就被中断，不再继续执行。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;低速系统调用是可能会让进程永远阻塞的一类系统调用，包括：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;如果某些类型文件的数据不存在，则读操作可能会使调用者永远阻塞。这里的某些类型文件指，读管道、终端设备和网络设备。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果这些数据不能被相同的类型文件立即接受，那么写操作可能会使调用者永远阻塞。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在某种条件发生之前，打开某些类型文件，这可能会发生阻塞。比如，打开一个终端设备时，需要先等待与它连接的调制解调器的应答。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;pause 函数 和 wait 函数。按照pause 的定义，它使调用进程休眠，直到捕捉到一个信号苏醒。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;某些进程间通信函数。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;在这些低速系统调用中，有一个值得注意的例外：与磁盘 I/O 有关的系统调用。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;虽然读、写一个磁盘文件可能暂时阻塞调用者，但是除非发生硬件错误，I/O 操作总会很快返回，并且使调用者不再处于阻塞状态。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;为了帮助应用程序不必处理被中断的系统调用，4.2BSD 引进了（某些被中断系统调用的）自动重启动。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;引入自动重启动功能的一个理由是&lt;/strong&gt;：有时用户不知道使用的输入、输出设备是否是低速设备。如果在程序中捕捉信号，而且系统并不提供重启动功能， 则对每次读、写系统调用就要进行是否出错返回的测试；如果是被中断的，则再调用读、写系统调用&lt;/p&gt;

&lt;p&gt;自动重启动的系统调用有：ioctl、read、readv、write、writev、wait 和 waitpid。前5个函数只有对低速设备进行操作时，才会被信号中断。而wait 和 waitpid 在捕捉到信号时，总是被中断。&lt;/p&gt;

&lt;p&gt;因为这种自动重启动的处理方式也会带来问题，某些应用程序不希望这些函数被中断后重启动。因此，4.3BSD 允许进程基于每个信号禁用此功能。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;可重入函数&quot;&gt;可重入函数&lt;/h1&gt;

&lt;p&gt;不可重入的例子：&lt;/p&gt;

&lt;p&gt;进程捕捉到信号，对该信号进行处理时，进程正在执行的正常指令序列就会被临时中断（信号处理程序）。它会先执行该信号处理程序中的指令。如果进程正在malloc，从其堆中分配存储空间。而此时，进程捕捉到信号，从而先执行信号处理程序。因为进程调用了malloc，那么这种情况下会发生什么事情呢？&lt;/p&gt;

&lt;p&gt;这可能会对进程造成破坏。因为malloc 通常为它分配的存储空间维护一个链表，而插入信号处理程序时，进程可能正在更改此链表。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
又例如，若进程正在执行getpwnam这种将其结果存放在静态存储单元中的函数，其间插入执行信号处理程序，它又调用这样的函数，则返回给正常调用者的信息 可能会被 返回给信号处理程序的信息 覆盖。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;可重入的函数如下表：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Apue/APUE_10/APUE_10_5.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;大多数函数是不可重入的原因是：&lt;/p&gt;

&lt;p&gt;（a）它们使用静态数据结构。&lt;/p&gt;

&lt;p&gt;（b）它们调用 malloc 或 free。&lt;/p&gt;

&lt;p&gt;（c）它们是标准 I/O 函数。标准 I/O 库的很多实现都以不可重入的方式使用全剧数据结构。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;注意：&lt;/p&gt;

&lt;p&gt;（1）即使信号处理程序调用的是可重入函数，但是由于每个县城只有一个 errno 变量，因此信号处理程序会修改原先值。&lt;/p&gt;

&lt;p&gt;（2）可重入函数列表中没有 longjmp 和 siglongjmp 的原因是：因为主例程以非可重入方式正在更新一个数据结构时，它可能产生信号。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;sigcld-语义&quot;&gt;SIGCLD 语义&lt;/h1&gt;

&lt;p&gt;SIGCLD 和 SIGCHLD 这两个信号很容易混淆。&lt;/p&gt;

&lt;p&gt;SIGCLD 是 System V 的一个信号名，而SIGCHLD 是 BSD 的信号，它们两个的语音不相同。POSIX.1 采用 BSD 的SIGCHLD 信号。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;SIGCLD&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果用 signal 或 sigset 设置信号配置，则基于 SVR4 的系统继承了这一具有问题色彩的传统（即兼容性限制）。对于 SIGCLD 的早期处理方式是：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（1）&lt;/strong&gt;如果进程将该信号的配置设置为 SIG_IGN ，那么调用进程的子进程将不会产生僵死进程。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;这与 SIG_DFL 信号的默认动作 “忽略” 不同。&lt;/p&gt;

&lt;p&gt;子进程在终止时，将它的状态丢弃。如果调用进程继续调用一个 wait 函数，那么它将阻塞到所有子进程终止，最后该 wait 会返回-1，并将它 errno 设置为 ECHILD。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（2）&lt;/strong&gt;如果将 SIGCLD 的配置设置为捕捉，那么内核会立即检查是否有子进程准备好 被等待。如果是的话，那么调用 SIGCD 处理程序。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;SIGCHLD&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;POSIX.1 未说明在 SIGCHLD 被忽略时应产生的后果，所以这种行为是允许的。 Single UNIX Specification 的 XSI 扩展选项要求对于 SIGCHLD 支持这种行为。&lt;/p&gt;

&lt;p&gt;在 4.4BSD 中，如果 SIGCHLD 的配置设置为忽略， 那么总是产生僵死进程。如果要避免僵死进程，那么必须等待子进程。&lt;br /&gt;在 SVR4 中，如果调用 signal 或 sigset 将 SIGCHLD 的配置设置为忽略，那么决不会产生僵死进程。&lt;/p&gt;

&lt;p&gt;使用 sigaction 可设置 SA_NOCLDWAIT 标志（见图 10-6）以避免进程僵死。本书讨论的 4
种平台都支持这一点。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;可靠信号术语和语义&quot;&gt;可靠信号术语和语义&lt;/h1&gt;

&lt;p&gt;当造成信号的事件发生时，为进程产生一个信号 （或 向进程发送一个信号）。当一个信号产生时，内核通常在进程表中，以某种形式设置一个标志。&lt;/p&gt;

&lt;p&gt;当对信号采取了这种动作时，我们说，这是向进程&lt;strong&gt;递送&lt;/strong&gt;了一个信号。&lt;br /&gt;在信号产生（generation）和 递送（delivery）之间的时间间隔内，称信号是&lt;strong&gt;未决的&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;事件，它可以是硬件异常（如 除以0）、软件条件（如 alarm 定时期超时）、终端产生的信号 或 调用 kill 函数。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;进程可以选用 “阻塞信号递送”。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果进程&lt;strong&gt;产生&lt;/strong&gt;了一个阻塞信号，对该信号的动作是系统默认动作 或 捕捉该信号，那么此进程将该信号保持为&lt;strong&gt;未决状态&lt;/strong&gt;。这将会持续到此进程对该信号解除阻塞，或者 对此信号的动作更改为忽略。&lt;/p&gt;

&lt;p&gt;内核在&lt;strong&gt;发送&lt;/strong&gt;一个被阻塞的信号给进程时，才决定对信号的处理方式。因此，在信号发送到进程之前，仍可以改变对该信号的动作。进程可以调用 sigpending 函数来判断哪些信号是设置为阻塞，并且处于未决状态的。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;在进程解除对某个信号的阻塞之前，如果这个信号发生了多次，那么会发生什么呢？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;POSIX.1 允许系统发送该信号一次 或 多次。如果发送该信号多次，则称 这些信号进行了排队。但是，除了支持 POSIX.1 实时扩展的系统，否则大多数 UNIX 并不对信号排队，而是只递送这种信号一次。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如果有多个信号要发送给一个进程，那么会发生什么呢？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;POSIX.1 并没有规定这些信号的发送顺序。但是 POSIX.1 基础部分建议：在其他信号之前，发送与进程当前状态有关的信号，如 SIGSEGV。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;每个进程都有一个信号屏蔽字（signal mask），它规定了，当前要阻塞发送到该进程的信号集。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;对于每种可能会阻塞的信号，该屏蔽字中，都有一位与之对应。&lt;br /&gt;对于某种信号，如果它的对应位已设置，则它当前是被阻塞的。&lt;/p&gt;

&lt;p&gt;进程可以调用 sigprocmask 来检测和更改它当前信号屏蔽字。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;信号集&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;由于信号编号可能会超过一个整型所包含的二进制位数，因此，POSIX.1 定义了一个新数据类型 sigset_t。&lt;/p&gt;

&lt;p&gt;这个新数据类型可以容纳一个信号集，而信号屏蔽字就可以存放在信号集中。（此数据类型就是信号集的实现）&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;函数-kill-和-raise&quot;&gt;函数 kill 和 raise&lt;/h1&gt;

&lt;p&gt;kill 函数将信号发送给进程 （或 进程组）。raise 函数则允许进程向自身发送信号。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Apue/APUE_10/APUE_10_6.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;kill 的 pid 参数有以下 4 种不同的情况：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;pid &amp;gt; 0&lt;/strong&gt; &lt;br /&gt; 将该信号发送给进程ID为 pid参数 的进程。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;pid == 0&lt;/strong&gt; &lt;br /&gt; 将该信号发送给一些进程。这些进程与发送进程属于同一进程组，而且发送进程有权限向这些进程发送信号。&lt;br /&gt; &lt;br /&gt; 注意，这些进程不包括实现定义的系统进程集。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;pid &amp;lt; 0&lt;/strong&gt; &lt;br /&gt; 将该信号发送给一些进程。这些进程的进程组ID等于 pid 参数绝对值，而且发送进程有权限向这些进程发送信号。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;pid = -1&lt;/strong&gt; &lt;br /&gt; 将该信号发送给一些进程。这些进程是发送进程有权限向它们发送信号的。&lt;br /&gt; &lt;br /&gt; 注意，这些进程不包括系统进程集中的进程。（与 pid == 0 的注意事项一样。）&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;函数-alarm-和-pause&quot;&gt;函数 alarm 和 pause&lt;/h1&gt;

&lt;p&gt;使用alarm 函数可以设置一个定时器（闹钟时间），在将来的某个时刻，这个定时器会超时。当这个定时期超时时，内核产生 SIGALRM 信号。如果忽略 或 不捕捉此信号，那么它的默认动作时终止调用该alarm 函数的进程。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Apue/APUE_10/APUE_10_7.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;参数 seconds 的值是产生信号 SIGALRM 的条件，该条件是需要经过的时钟秒数。&lt;/p&gt;

&lt;p&gt;当这一时刻达到时，信号由内核产生。由于进程调度的延迟，所以还需要一个时间间隔才能让进程得到控制，使得进程能够处理该信号。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;每个进程只能有一个闹钟时间&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果在调用 alarm时，之前已经为该进程注册了闹钟时间，并且还没有超时。那么，该闹钟时间剩余的值将会作为本次调用 alarm 函数的返回值，并且，以前注册的闹钟时间被新值代替。&lt;/p&gt;

&lt;p&gt;如果以前注册的闹钟时间还没有超时，并且本次 alarm 函数的 seconds 参数为0。那么，取消以前的闹钟时间，之前剩余的值作为 alarm 函数的返回值。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;虽然，SIGALRM 的默认动作是终止进程，但是大多数使用闹钟的进程捕捉此信号。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当我们想捕捉 SIGALRM 信号时，必须在调用 alarm 函数之前，安装该信号的处理程序。&lt;/p&gt;

&lt;p&gt;如果我们先调用 alarm 函数，在安装 SIGALRM 处理程序之前，已经接收到 SIGALRM 信号。那么进程将终止。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;pause 函数&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;它会让调用进程挂起，直到捕捉到一个信号。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Apue/APUE_10/APUE_10_8.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;只有执行了一个信号处理程序，并且从此程序返回时，pause才返回。这种情况下，pause 返回 -1，errno 设置为 EINTR。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://waterwoodfountainhead.github.io/apue/2019/07/15/Apue-Chapter-10-c.html&quot;&gt;进入下一篇：《Chapter 10 - c》&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Tue, 16 Jul 2019 00:50:32 +0800</pubDate>
        <link>http://localhost:4000/apue/2019/07/16/Apue-Chapter-10-b.html</link>
        <guid isPermaLink="true">http://localhost:4000/apue/2019/07/16/Apue-Chapter-10-b.html</guid>
        
        
        <category>apue</category>
        
      </item>
    
      <item>
        <title>[Apue]Chapter 10 - a</title>
        <description>&lt;h1 id=&quot;信号概念&quot;&gt;信号概念&lt;/h1&gt;

&lt;p&gt;信号是软件中断。信号提供了一种处理异步事件的方法。&lt;/p&gt;

&lt;p&gt;每个信号都有一个名字。这些名字都以3个字符SIG开头。&lt;/p&gt;

&lt;p&gt;在头文件&lt;signal.h&gt;中，信号名都被定义为正整数常量（信号编号）。不存在编号为0的信号。不过，kill 函数对信号编号0有特殊应用。POSIX.1 将此种信号编号值称为空信号。&lt;/signal.h&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;有很多条件可以产生信号:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;当用户按下某些终端键时，使终端产生的信号。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;硬件异常产生信号：除数为0、无效的内存引用等。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;进程调用 kill(2) 函数，可以将任意信号发送给另一个进程(或 进程组)。&lt;br /&gt;&lt;br /&gt;&lt;strong&gt;不过，它是有限制的：&lt;/strong&gt;接受信号的进程和发送信号的进程，它们的所有者必须相同。或者，发送信号的进程的所有者是超级用户。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;用户可以用 kill(1) 命令将信号发送给其他进程。此命令只是 kill函数的接口。它常用于终止一个失控的后台进程。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当检测到某种软件条件已经发生，并将其通知有关进程时，也会产生信号。这里指的不是硬件产生条件(比如，除以0)，而是软件条件。例如：SIGURG——在网络连接上传来带外的数据时产生，等等。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;进程不能测试一个变量来判断是否发生了一个信号，而是告诉内核进行处理。&lt;strong&gt;在某个信号出现时，可以告诉内核按下列3种方式之一进行处理：&lt;/strong&gt;（称为信号的处理，或与信号相关的动作）&lt;/p&gt;

&lt;p&gt;（1）忽略此信号。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;有两种信号不能被忽略——SIGKILL 和 SIGSTOP。原因是，它们向内核和超级用户提供了让进程终止(或 停止) 的可靠方法。&lt;/p&gt;

&lt;p&gt;如果忽略某些硬件异常所产生的信号，进程的运行行为是为定义的。比如：非法内存引用 或 除以0。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;（2）捕捉信号。&lt;/p&gt;

&lt;p&gt;为了捕捉信号，要通知内核在某种信号发生时，调用一个用户函数。在用户函数中，可以执行用户自己对这种事件的处理。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;（3）执行系统默认动作。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;对大多数信号而言，它们的系统默认动是终止该进程。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;下图列出所有信号的名字，说明了那些系统支持此信号，还有说明了这些信号的系统默认动作。&lt;/p&gt;

&lt;p&gt;列表中的点号表示这个信号定义为基本 POSIX.1规范部分。“XSI” 表示该信号定义在XSI扩展部分。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Apue/APUE_10/APUE_10_1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图中，一部分信号的默认动作是“终止+core”，这会产生一个core文件。那么，如何避免产生core文件呢？&lt;/p&gt;

&lt;p&gt;（a）进程是设置用户ID的，而且当前用户并非程序文件的所有者。&lt;/p&gt;

&lt;p&gt;（b）进程是设置组ID的，并且当前用户并非该程序文件的所有者。&lt;/p&gt;

&lt;p&gt;（c）用户没有写当前工作目录的权限。&lt;/p&gt;

&lt;p&gt;（d）文件已存在，而且用户对该文件设有写权限。&lt;/p&gt;

&lt;p&gt;（e）文件太大。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;上图中，SIGBUS——硬件故障   是对应实现定义的硬件故障。APUE p272 - 276页（实际页数为p252 - 256页）将进一步详细说明一些信号。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://waterwoodfountainhead.github.io/apue/2019/07/15/Apue-Chapter-10-b.html&quot;&gt;进入下一篇：《Chapter 10 - b》&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 16 Jul 2019 00:38:32 +0800</pubDate>
        <link>http://localhost:4000/apue/2019/07/16/Apue-Chapter-10-a.html</link>
        <guid isPermaLink="true">http://localhost:4000/apue/2019/07/16/Apue-Chapter-10-a.html</guid>
        
        
        <category>apue</category>
        
      </item>
    
      <item>
        <title>[Unp]Chapter 5</title>
        <description>&lt;p&gt;#&lt;/p&gt;

&lt;p&gt;讲TIME_WAIT前，我们需要了解下&lt;a href=&quot;https://waterwoodfountainhead.github.io/unp/2019/06/26/Unp-Nouns.html&quot;&gt;迷途(Nouns第12条)&lt;/a&gt;和TCP连接终止的过程，如图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_2/UNP2.6.1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;TCP的终结需要4个分节：&lt;/p&gt;

&lt;p&gt;（1）客户端首先调用close，我们称该端执行主动关闭（active close）。该端的TCP于是发送一个FIN分节，表示数据发送完毕。&lt;/p&gt;

&lt;p&gt;（2）接收到这个FIN的对端执行被动关闭（passive close）。这个FIN由TCP确认。服务端接收FIN意味着服务端的应用进程在相应连接上再无额外数据可接收。&lt;/p&gt;

&lt;p&gt;（3）一段时间后，接收到这个文件结束符的应用进程将调用close关闭它的套接字。这导致它的TCP也发送一个FIN。&lt;/p&gt;

&lt;p&gt;（4）接收这个最终FIN的客户端的TCP（即执行主动关闭的那一端）确认这个FIN。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;time_wait状态&quot;&gt;TIME_WAIT状态&lt;/h1&gt;

&lt;p&gt;先介绍下TIME_WAIT状态：这个状态的持续时间是最长分节生命期（maximum segment lifetime，MSL）的两倍，有时候称之为2MSL。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;那么，TIME_WAIT状态有什么作用呢？&lt;/p&gt;

&lt;p&gt;(1) 可靠地实现TCP全双工连接的终止；&lt;/p&gt;

&lt;p&gt;假设最终的ACK丢失了来解释。服务器将重新发送它的最终那个FIN，因此客户必须维护状态信息，以允许它重新发送最终那个ACK。要是客户不维护状态信息，它将响应以一个RST（另外一种类型的TCP分节），该分节将被服务器解释成一个错误。如果TCP打算执行所有必要的工作以彻底终止某个连接上两个方向的数据流（即全双工关闭），那么它必须正确处理连接终止序列4个分节中任何一个分节丢失的情况。&lt;/p&gt;

&lt;p&gt;这也说明了执行主动关闭的那一端(客户端)由于要重传最后一个ACK，所以是处于TIME_WAIT状态。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;(2) 允许老的重复分节在网络中消逝。&lt;/p&gt;

&lt;p&gt;有时候一个连接可能会在关闭后，又在相同的ip地址和端口之间建立一个连接。因此TCP必须防止这个连接的老的重复分组在该连接已终止后再现，以免被误解成属于同一连接的某个新的化身。&lt;/p&gt;

&lt;p&gt;为此，TCP将不给处于TIME_WAIT状态的连接发起新的化身。既然TIME_WAIT状态的持续时间是MSL的2倍，这就足以让某个方向上的分组最多存活MSL秒即被丢弃，另一个方向上的应答最多存活MSL秒也被丢弃。通过实施这个规则，我们就能保证每成功建立一个TCP连接时，来自该连接先前化身的老的重复分组都已在网络中消逝了。&lt;/p&gt;
</description>
        <pubDate>Tue, 02 Jul 2019 10:00:00 +0800</pubDate>
        <link>http://localhost:4000/unp/2019/07/02/Unp-Chapter-5.html</link>
        <guid isPermaLink="true">http://localhost:4000/unp/2019/07/02/Unp-Chapter-5.html</guid>
        
        
        <category>unp</category>
        
      </item>
    
      <item>
        <title>[Unp]Chapter 4</title>
        <description>&lt;h1 id=&quot;概述&quot;&gt;概述&lt;/h1&gt;

&lt;p&gt;下图给出在一对TCP客户与服务器进程之间发生的一些典型事件的时间表。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_4/UNP4.1.1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;socket-函数&quot;&gt;socket 函数&lt;/h1&gt;

&lt;p&gt;为了执行网络I/O，进程必须做的第一件事情就是调用socket函数，指定通信协议类型（使用IPv4的TCP、使用IPv6的UDP、Unix域字节流协议等）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_4/UNP4.2.1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;family参数&lt;/strong&gt;：它指明协议族，它是下图所示的某个常值。该参数也往往被称为协议域。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_4/UNP4.2.2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;type参数&lt;/strong&gt;：指明套接字类型，它是下图中所示的某个常值。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_4/UNP4.2.3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;protocol参数&lt;/strong&gt;：应设为下图所示的某个协议类型常值，或者设为0，以选择所给定family和type组合的系统默认值。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_4/UNP4.2.4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;不过，并非所有套接字 family 与 type 的组合都是有效的，下图给出了一些有效的组合和对应的真正协议。其中标为“是”的项也是有效的，但还没有找到便捷的缩略词。而空白项则是无效组合。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_4/UNP4.2.5.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;对比 AF_xxx 和 PF_xxx&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;AF_ 前缀表示地址族，PF_ 前缀表示协议族。&lt;/p&gt;

&lt;p&gt;头文件&amp;lt;sys/socket.h&amp;gt;中为一给定协议定义的 PF_ 值总是与此协议的 AF_ 值相等。尽管这种相等关系并不一定永远成立。为与现存代码保持一致，我们仅使用 AF_ 常值，不过，在调用 socket 时，我们可能会碰到 PF_ 值。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;connect-函数&quot;&gt;connect 函数&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_4/UNP4.3.1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;（1）sockfd是由socket函数返回的套接字描述符，第二个、第三个参数分别是一个指向套接字地址结构的指针和该结构的大小。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;（2）客户在调用函数connect前不必非得调用bind函数（我们在下一节介绍该函数），因为如果需要的话，内核会确定源IP地址，并选择一个临时端口作为源端口。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;（3）如果是TCP套接字，调用connect函数仅在连接建立成功或出错时才返回，其中出错返回可能有以下几种情况：&lt;/p&gt;

&lt;p&gt;①若TCP客户没有收到SYN分节的响应，则返回ETIMEDOUT错误。当我们调用connect函数时，4.4BSD内核发送一个SYN，若无响应则等待6s后再发送一个，若仍无响应则等待24s后再发送一个（TCPv2第828页）。若总共等了75s后，它仍未收到响应则返回本错误。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;②若对客户的SYN的响应是RST（表示复位），则表明该服务器主机在我们指定的端口上没有进程在等待与之连接（例如服务器进程也许没在运行）。这是一种硬错误（hard error），客户一接收到RST就马上返回ECONNREFUSED错误。&lt;/p&gt;

&lt;p&gt;RST是TCP在发生错误时发送的一种TCP分节。产生RST的三个条件是：目的地为某端口的SYN到达，然而该端口上没有正在监听的服务器（如前所述）；TCP想取消一个已有连接；TCP接收到一个根本不存在的连接上的分节。（TCPv1第246～250页有更详细的信息。）&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;③若客户发出的SYN在中间的某个路由器上引发了一个“destination unreachable”（目的地不可达）ICMP错误，则认为是一种软错误（soft error）。&lt;/p&gt;

&lt;p&gt;客户主机内核保存该消息，并按第一种情况中所述的时间间隔继续发送SYN。若在某个规定的时间（4.4BSD规定75s）后仍未收到响应，则把保存的消息（即ICMP错误）作为EHOSTUNREACH或ENETUNREACH错误返回给进程。&lt;/p&gt;

&lt;p&gt;还有两种情形也是有可能的：一是按照本地系统的转发表，根本没有到达远程系统的路径；二是connect调用根本不等待就返回。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;通过一个例子更好的理解上面三种情况：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;首先指定本地主机（127.0.0.1），它正在运行对应的时间获取服务器程序，我们观察正常的输出：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_4/UNP4.3.2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;接着指定本地子网（192.168.1/24）上其主机ID（100）并不存在的一个IP地址，这样当客户主机发出ARP请求（要求那个不存在的主机响应以其硬件地址）时，它将永远收不到ARP响应：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_4/UNP4.3.3.png&quot; alt=&quot;（err_sys函数以直观可读的字符串消息表示了ETIMEDOUT错误的含义）&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然后，我们指定一个没有运行时间获取服务器程序的主机（其实是一个本地路由器）：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_4/UNP4.3.4.png&quot; alt=&quot;（服务器主机立刻响应以一个RST分节）&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最后，我们指定一个因特网中不可到达的IP地址，那么路由器就会返回主机不可达的ICMP错误：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_4/UNP4.3.5.png&quot; alt=&quot;（connect也在等待规定的一段时间之后才返回EHOSTUNREACH错误）&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;bind-函数&quot;&gt;bind 函数&lt;/h1&gt;

&lt;p&gt;bind 函数把一个本地协议地址赋予一个套接字。对于网际网协议，协议地址是32位的IPv4地址或128位的IPv6地址与16位的TCP或UDP端口号的组合。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_4/UNP4.4.1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;第二个参数是一个指向特定于协议的地址结构的指针，第三个参数是该地址结构的长度。从bind函数返回的一个常见错误是EADDRINUSE（“Address already in use”，地址已使用）。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;对于TCP，调用bind函数可以指定一个端口号，或指定一个IP地址，也可以两者都指定，还可以都不指定。因此，有两点需要注意：&lt;/p&gt;

&lt;p&gt;（1）如果一个TCP客户或服务器未曾调用 bind捆绑一个端口，当调用 connect 或 listen 时，内核就要为相应的套接字选择一个临时端口。让内核来选择临时端口对于TCP客户来说是正常的，除非应用需要一个预留端口（图2-10）；然而对于TCP服务器来说却极为罕见，因为服务器是通过它们的众所周知端口被大家认识的。&lt;/p&gt;

&lt;p&gt;不过，有一个例外——远程过程调用（Remote Procedure Call，RPC）服务器。由内核为它们的监听套接字选择一个临时端口，而该端口随后通过RPC端口映射器进行注册。客户在connect这些服务器之前，必须与端口映射器联系以获取它们的临时端口。这种情况也适用于使用UDP的RPC服务器。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;（2）进程可以把一个特定的IP地址捆绑到它的套接字上，不过这个IP地址必须属于其所在主机的网络接口之一。&lt;/p&gt;

&lt;p&gt;对于TCP客户端来说，这就为在该套接字上发送的IP数据报指派了源IP地址。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;对于TCP服务器，这就限定该套接字只接收那些目的地为这个IP地址的客户连接。TCP客户通常不把IP地址捆绑到它的套接字上。当连接套接字时，内核将根据所用外出网络接口来选择源IP地址，而所用外出接口则取决于到达服务器所需的路径（TCPv2第737页）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果TCP服务器没有把IP地址捆绑到它的套接字上，内核就把客户发送的SYN的目的IP地址作为服务器的源IP地址（TCPv2第943页）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;下图汇总了根据预期的结果，来设置sin_addr和sin_port或者sin6_addr和sin6_port的值：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_4/UNP4.4.2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;对于上图的一些说明：&lt;/p&gt;

&lt;p&gt;（1）如果指定端口号为0，内核会在bind被调用时选择一个临时端口。然而，如果指定IP地址为通配地址，内核将会等到（TCP）套接字已连接 或 已经在（UDP）套接字上发出数据报时，它才选择一个本地IP地址。&lt;/p&gt;

&lt;p&gt;对于IPv4来说，通配地址由常值INADDR_ANY来指定，其值一般为0（由于是网络字节序还是主机字节序，INADDR_ANY的值（为0）都一样，因此使用htonl并非必需）。它告知内核去选择IP地址。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_4/UNP4.4.3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;（2）对于IPv6，我们就不能这么做了，因为128位的IPv6地址是存放在一个结构中的。（在C语言中，赋值语句的右边无法表示常值结构。）为了解决这个问题，我们改写为：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_4/UNP4.4.4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;系统 预先 分 配 in6addr_any 变量并将其 初始 化为常值 IN6ADDR_ANY_INIT。头文件&amp;lt;netinet/in.h&amp;gt;中含有in6addr_any的extern声明。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;（3）如果让内核来为套接字选择一个临时端口号，那么必须注意，函数bind并不返回所选择的
值。实际上，由于bind函数的第二个参数有const限定词，它无法返回所选之值。为了得到内
核所选择的这个临时端口值，必须调用函数getsockname来返回协议地址。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;listen-函数&quot;&gt;listen 函数&lt;/h1&gt;

&lt;p&gt;listen函数仅由TCP服务器调用，它做两件事情：&lt;/p&gt;

&lt;p&gt;（1）当socket函数创建一个套接字时，它被假设为一个主动套接字，而 listen 函数把这个未连接的套接字转换成一个被动套接字，指示内核应接受指向该套接字的连接请求。&lt;/p&gt;

&lt;p&gt;根据下图，调用listen导致套接字从CLOSED状态转换到LISTEN状态。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_4/UNP4.5.1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;(2) 本函数的第二个参数规定了内核应该为相应套接字排队的最大连接个数。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_4/UNP4.5.2.png&quot; alt=&quot;（本函数通常应该在调用socket和bind这两个函数之后，并在调用accept函数之前调用）&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为了理解其中的backlog参数，我们必须认识到内核为任何一个给定的监听套接字维护两个队列：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;(1) 未完成连接队列（incomplete connection queue），每个这样的SYN分节对应其中一项：已由某个客户发出并到达服务器，而服务器正在等待完成相应的TCP三路握手过程。这些套接字处于SYN_RCVD状态。&lt;/p&gt;

&lt;p&gt;(2) 已完成连接队列（completed connection queue），每个已完成TCP三路握手过程的客户对
应其中一项。这些套接字处于ESTABLISHED状态。&lt;/p&gt;

&lt;p&gt;这两种状态如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_4/UNP4.5.3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;关于这两个队列的处理，以下几点需要考虑：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;（1）listen函数的backlog参数曾被规定为这两个队列总和的最大值。&lt;/p&gt;

&lt;p&gt;（2）源自Berkeley的实现给backlog增设了一个模糊因子（fudge factor）。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;把它乘以1.5得到未处理队列最大长度（TCPv1第257页和TCPv2第462页）。举例来说，通常指定为5的backlog值实际上允许最多有8项在排队。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果我们把backlog看成是内核能为某套接字排队的最大已完成连接数目，那么增加模糊因子的理由是，把队列中的未完成连接也计算在内。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;（3）不要把backlog定义为0，因为不同的实现对此有不同的解释。如果你不想让任何客户连接到你的监听套接字上，那就关掉该监听套接字。&lt;/p&gt;

&lt;p&gt;（4）在三路握手顺利完成的前提下，未完成连接队列中的任何一项的存留时间就是一个RTT。而RTT的值取决于特定的客户与服务器。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;TCPv3的14.4节指出，对于一个Web服务器，许多客户与单个服务器之间的中值RTT为187ms。（既然出现一些大值可能显著扭曲均值，对于该统计量通常使用中值。）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;（5）现如今，服务器一天可能要处理几百万个连接，这个4.2BSD支持的最大值 (backlog价为5) 就根本不够了（TCPv3第187～192页）。繁忙的HTTP服务器必须指定一个大得多的backlog值，而且较新的内核必须支持较大的backlog值。&lt;/p&gt;

&lt;p&gt;因此，指定较大backlog值的理由在于：随着客户SYN分节的到达，未完成连接队列中的项数可能增长，它们等着三路握手的完成。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;（6）当一个客户端的SYN到达时，若这些队列是满的，服务端TCP就忽略该分节（TCPv2第930～931页），也就是不发送RST。这么做是因为：这种情况是暂时的，客户端TCP将重发SYN，期望不久就能在这些队列中找到可用空间。&lt;/p&gt;

&lt;p&gt;另外，客户端无法区别响应SYN的RST究竟意味着 “该端口没有服务器在监听” ，还是意味着 “该端口有服务器在监听，不过它的队列满了”。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;（7）在三路握手完成之后，但在服务器调用accept之前到达的&lt;strong&gt;数据&lt;/strong&gt;应在服务器TCP中排队，最大数据量为相应已连接套接字的接收缓冲区大小。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;实现原理&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;每当在未完成连接队列中创建一项时，来自监听套接字的参数就复制到即将建立的连接中。连接的创建机制是完全自动的，无需服务器进程插手。&lt;/p&gt;

&lt;p&gt;下图展示了用这两个队列建立连接时所交换的分组。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_4/UNP4.5.4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;（1）当来自客户的SYN到达时，TCP在未完成连接队列中创建一个新项。&lt;/p&gt;

&lt;p&gt;（2）然后响应以三路握手的第二个分节：服务器的SYN响应，其中捎带对客户SYN的ACK。&lt;/p&gt;

&lt;p&gt;（3）这个新项一直保留在未完成连接队列中，直到三路握手的第三个分节（客户对服务器SYN的ACK）到达或者该项超时为止。（源自Berkeley的实现为这些未完成连接的项设置的超时值为75 s。&lt;/p&gt;

&lt;p&gt;（4）如果三路握手正常完成，该项就从未完成连接队列移到已完成连接队列的队尾。&lt;/p&gt;

&lt;p&gt;（5）当进程调用 accept 时，已完成连接队列中的队头项将返回给进程，或者如果该队列为空，那么进程将被投入睡眠，直到TCP在该队列中放入一项才唤醒它。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;不同的操作系统，backlog 的意义解释也是不同的，如下图：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_4/UNP4.5.4.png&quot; alt=&quot;FreeBSD的算法是backlog值本身加1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;accept-函数&quot;&gt;accept 函数&lt;/h1&gt;

&lt;p&gt;accept函数由TCP服务器调用，用于从已完成连接队列队头返回下一个已完成连接。如果已完成连接队列为空，那么进程被投入睡眠（假定套接字为默认的阻塞方式）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_4/UNP4.6.1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;关于accept 函数有关说明：&lt;/p&gt;

&lt;p&gt;（1）参数 cliaddr 和 addrlen 用来返回已连接的对端进程（客户）的协议地址。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;（2）addrlen是&lt;a href=&quot;https://waterwoodfountainhead.github.io/unp/2019/06/27/Unp-Chapter-3.html&quot;&gt;值—结果参数&lt;/a&gt;：调用前，我们将由 * addrlen 所引用的整数值置为由cliaddr所指的套接字地址结构的长度。返回时，该整数值即为由内核存放在该套接字地址结构内的确切字节数。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;（3）如果accept成功，那么其返回值是由内核自动生成的一个全新描述符，代表与所返回客户
的TCP连接。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;（4）accept的第一个参数是监听套接字（listening socket）描述符（由socket创建，随后用作bind和listen的第一个参数的描述符）。它的返回值是已连接套接字（connected socket）描述符。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;区分这两个套接字非常重要：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;监听套接字：一个服务器通常仅仅创建一个监听套接字，它在该服务器的生命期内一直存在。&lt;/p&gt;

&lt;p&gt;已连接套接字：内核为服务器进程接受的客户连接创建一个已连接套接字（也就是说对于它的TCP三路握手过程已经完成）。当服务器完成对某个给定客户的服务时（调用close），相应的已连接套接字就被关闭。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;（5）accept 函数最多返回三个值：&lt;/p&gt;

&lt;p&gt;①可能是新套接字描述符。&lt;/p&gt;

&lt;p&gt;②可能是出错指示的整数、客户进程的协议地址（由 cliaddr指针参数所指）以及该地址的大小（由 addrlen指针参数所指）。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;并发服务器&quot;&gt;并发服务器&lt;/h1&gt;

&lt;p&gt;使用 fork创建一个典型的并发服务器轮廓，如图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_4/UNP4.8.1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当一个连接建立时，accept返回，服务器接着调用fork，然后由子进程服务客户（通过已连接套接字connfd），父进程则等待另一个连接（通过监听套接字listenfd）。既然新的客户由子进程提供服务，父进程就关闭已连接套接字。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为什么上图程序中父进程对 connfd 调用 close 没有终止它与客户的连接呢？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们知道每个文件或套接字都有一个引用计数。socket返回后与listenfd关联的文件表项的引用计数值为1。accept返回后与connfd关联的文件表项的引用计数值也为1。&lt;/p&gt;

&lt;p&gt;在fork返回后，这两个描述符就在父进程与子进程间共享（也就是被复制），因此与这两个套接字相关联的文件表项各自的访问计数值均为2。&lt;/p&gt;

&lt;p&gt;当父进程关闭connfd时，它只是把相应的引用计数值从2减为1。该套接字真正的清理和资源释放
要等到其引用计数值到达0时才发生。既然引用计数值仍大于0，这个close调用并不引发TCP的四分组连接终止序列。这会在稍后子进程也关闭connfd时发生。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如果父进程对每个由accept返回的已连接套接字都不调用close，那么并发服务器中将会发生什么？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;没有一个客户连接会被终止。父进程最终将耗尽可用描述符，因为任何进程在任何时刻可拥有的打开着的描述符数通常是有限制的。同时，这将妨碍TCP连接终止序列的发生，导致连接一直打开着。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;close-函数&quot;&gt;close 函数&lt;/h1&gt;

&lt;p&gt;Unix close函数也用来关闭套接字，并终止TCP连接。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_4/UNP4.9.1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;close的默认行为是把该套接字标记成已关闭，然后立即返回到调用进程。该套接字描述符不能再由调用进程使用，也就是说它不能再作为read或write的第一个参数。&lt;/p&gt;

&lt;p&gt;然而TCP将尝试发送（已排队并等待发送到对端的）数据，发送完毕后正常进行TCP连接终止序列。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;getsockname-和-getpeername-函数&quot;&gt;getsockname 和 getpeername 函数&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_4/UNP4.10.1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;getsockname函数：返回与某个套接字关联的本地协议地址。&lt;/p&gt;

&lt;p&gt;getpeername 函数：返回与某个套接字关联的外地协议地址。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这两个函数的最后一个参数都是 &lt;strong&gt;值-结果参数&lt;/strong&gt;。这就是说，这两个函数都得装填由 localaddr 或 peeraddr指针所指的套接字地址结构。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;需要这两个函数的理由如下：&lt;/p&gt;

&lt;p&gt;（1）在一个没有调用 bind函数的TCP客户端上，connect成功返回后，getsockname用于返回（由内核赋予）该连接的本地IP地址和本地端口号。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;（2）在以端口号 0 调用bind（告知内核去选择本地端口号）后，getsockname用于返回由内核赋予的本地端口号。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;（3）getsockname可用于获取某个套接字的地址族。例如：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sockfd_to_family&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sockfd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;	&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sockaddr_storage&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ss&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;socklen_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;len&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ss&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getsockname&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sockfd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SA&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ss&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ss&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ss_family&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;11&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;第5行：由于不清楚要分配的套接字地址结构的类型，于是采用sockaddr_storage这个通用结构。因为它能够承载系统支持的任何套接字地址结构。&lt;/p&gt;

&lt;p&gt;第7-10行：我们调用getsockname返回地址族。既然POSIX规范允许对未绑定的套接字调用getsockname，该函数应该适合任何已打开的套接字描述符。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;（4）在一个以通配IP地址调用bind的TCP服务器上，与某个客户的连接一旦建立（accept成功返回），getsockname就可以用于返回（由内核赋予）该连接的本地IP地址。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;在这样的调用中，套接字描述符参数必须是已连接套接字的描述符，而不是监听套接字的描述符。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;（5）当一个服务器是由调用过accept的某个进程通过调用exec执行程序时，它能够获取客户身份的唯一途径便是调用getpeername。&lt;/p&gt;
</description>
        <pubDate>Fri, 28 Jun 2019 10:00:00 +0800</pubDate>
        <link>http://localhost:4000/unp/2019/06/28/Unp-Chapter-4.html</link>
        <guid isPermaLink="true">http://localhost:4000/unp/2019/06/28/Unp-Chapter-4.html</guid>
        
        
        <category>unp</category>
        
      </item>
    
      <item>
        <title>[Unp]Chapter 3</title>
        <description>&lt;h1 id=&quot;ipv4套接字地址结构&quot;&gt;IPv4套接字地址结构&lt;/h1&gt;

&lt;p&gt;它以sockaddr_in命名，定义在&amp;lt;netinet/in.h&amp;gt;头文件中。如下是它的POSIX定义：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_3/UNP3.2.1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;关于套接字地址结构的一般性说明：&lt;/p&gt;

&lt;p&gt;1）长度字段sin_len是为增加对OSI协议的支持而随4.3BSD-Reno添加的。不过，POSIX规范也不要求有这个成员。该成员的数据类型uint8_t是典型的，符合POSIX的系统都提供这种形式的数据类型。即使有长度字段，我们也无须设置和检查它，除非涉及路由套接字。它是由处理来自不同协议族的套接字地址结构的例程（例如路由表处理代码）在内核中使用的。&lt;/p&gt;

&lt;p&gt;2）POSIX规范只需要这个结构中的3个字段：sin_family、sin_addr和sin_port。对于符合POSIX的实现来说，定义额外的结构字段是可以接受的，这对于网际套接字地址结构来说也是正常的。几乎所有的实现都增加了sin_zero字段，所以所有的套接字地址结构大小都至少是16字节（因为sin_zero是一个带有8个元素长度的char类型的数组）。&lt;/p&gt;

&lt;p&gt;sin_addr字段：in_addr_t数据类型必须是一个至少32位的无符号整数类型。&lt;/p&gt;

&lt;p&gt;sin_port字段：in_port_t必须是一个至少16位的无符号整数类型。&lt;/p&gt;

&lt;p&gt;sin_family字段：sa_family_t数据类型可以是任何无符号整数类型。在支持长度字段的实现中，sa_family_t数据类型通常是一个8位的无符号整数，而在不支持长度字段的实现中，它则是一个16位的无符号整数。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;3，IPv4地址和TCP或UDP端口号在套接字地址结构中总是以网络字节序来存储。&lt;/p&gt;

&lt;p&gt;4，32位IPv4地址存在两种不同的访问方法。第一种：&lt;strong&gt;.sin_addr&lt;/strong&gt; 按 &lt;strong&gt;in_addr&lt;/strong&gt;结构引用其中的32位IPv4地址。第二种：&lt;strong&gt;.sin_addr.s_addr&lt;/strong&gt; 将按 &lt;strong&gt;in_addr_t&lt;/strong&gt;（通常是一个无符号的32位整数）引用同一个32位IPv4地址。&lt;/p&gt;

&lt;p&gt;5，sin_zero字段未曾使用，不过在填写这种套接字地址结构时，我们要把该字段置为0。尤其是，当捆绑一个非通配的IPv4地址时，该字段必须为0。&lt;/p&gt;

&lt;p&gt;6，套接字地址结构仅在给定主机上使用：虽然结构中的某些字段（例如IP地址和端口号）用在不同主机之间的通信中，但是结构本身并不在主机之间传递。因为不同的主机中的地址结构有可能会不同。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;通用套接字地址结构&quot;&gt;通用套接字地址结构&lt;/h1&gt;

&lt;p&gt;在任何套接字函数处理来自所支持的任何协议族的套接字地址结构的指针的时候，会引发一个问题（如何声明函数参数来容纳不同的指针类型？）。&lt;/p&gt;

&lt;p&gt;当然，ANSI C用 void * 解决了通用指针类型的问题。不过在这之前（1982年）采取的办法是在&amp;lt;sys/socket.h&amp;gt;头文件中定义一个通用的套接字地址结构：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_3/UNP3.2.2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;由于套接字函数是在ANSI C之前定义的，因此套接字函数被定义为——以指向某个通用套接字地址结构的一个指针作为其参数之一。这正如bind函数的ANSI C函数原型所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_3/UNP3.2.3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;因此，这就要求对套接字地址结构的指针参数进行类型强制转换，变成指向某个通用套接字地址结构的指针，例如：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_3/UNP3.2.4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;从应用层和内核角度看待此情况的强制转换的意义：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;从应用程序开发人员的观点看，这些通用套接字地址结构的唯一用途就是对指向特定于协议的套接字地址结构的指针执行类型强制转换。&lt;/p&gt;

&lt;p&gt;从内核的角度看，使用指向通用套接字地址结构的指针另有原因：内核必须取调用者的指针，把它类型强制转换为 **struct sockaddr * ** 类型，然后检查其中sa_family字段的值来确定这个结构的真实类型。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;ipv6-套接字地址结构&quot;&gt;IPv6 套接字地址结构&lt;/h1&gt;

&lt;p&gt;IPv6套接字地址结构在&amp;lt;netinet/in.h&amp;gt;头文件中定义，如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_3/UNP3.2.5.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1，如果系统支持套接字地址结构中的长度字段，那么SIN6_LEN常值必须定义。&lt;/p&gt;

&lt;p&gt;2，IPv6的地址族是AF_INET6，而IPv4的地址族是AF_INET。&lt;/p&gt;

&lt;p&gt;3，结构中字段的先后顺序做过编排。如果 sockaddr_in6 套接字地址结构本身是64位对齐的，那么128位的 sin6_addr 字段也是64位对齐的。在一些64位处理机上，如果64位数据存储在某个64位边界位置，那么对它的访问将得到优化处理。&lt;/p&gt;

&lt;p&gt;4，sin6_flowinfo 字段分成两个字段：（1）低序20位是流标（flow label）。（2）高序12位保留。&lt;/p&gt;

&lt;p&gt;5，对于具备范围的地址（scoped address），sin6_scope_id字段标识其范围（scope），最常见的是链路局部地址（link-local address）的接口索引（interface index）。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;新的通用套接字地址结构&quot;&gt;新的通用套接字地址结构&lt;/h1&gt;

&lt;p&gt;作为IPv6套接字API的一部分而定义的新的通用套接字地址结构克服了现有struct sockaddr的一些缺点。&lt;/p&gt;

&lt;p&gt;新的struct sockaddr_storage足以容纳系统所支持的任何套接字地址结构。sockaddr_storage结构在&amp;lt;netinet/in.h&amp;gt;头文件中定义，如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_3/UNP3.2.6.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;新的通用套接字（sockaddr_storage）与旧的（sockaddr）之间的区别：&lt;/p&gt;

&lt;p&gt;1，如果系统支持的任何套接字地址结构有对齐需要，那么sockaddr_storage能够满足最苛刻的对齐要求。&lt;/p&gt;

&lt;p&gt;2，sockaddr_storage足够大，能够容纳系统支持的任何套接字地址结构。
注意，除了ss_family和ss_len外（如果有的话），sockaddr_storage结构中的其他字段对用户来说是透明的。sockaddr_storage结构必须类型强制转换成（或复制到）适合ss_family字段所给出指针类型的套接字地址结构中，才能访问其他字段。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;套接字地址结构的比较&quot;&gt;套接字地址结构的比较&lt;/h1&gt;

&lt;p&gt;5种套接字地址结构进行比较：IPv4、IPv6、Unix域、数据链路和存储。（Unix域和数据链路以后会提到）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_3/UNP3.2.7.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;前两种套接字地址结构是固定长度的。Unix域结构和数据链路结构是可变长度的，为了处理长度可变的结构，我们把一个指针（它指向套接字地址结构）作为参数传递给套接字函数时，也把该套接字地址结构的长度作为另一个参数传递给它。&lt;/p&gt;

&lt;p&gt;我们在每种长度固定的结构下方给出了这种结构的字节数长度。&lt;/p&gt;

&lt;p&gt;不过，Unix域（sockaddr_un）结构本身并非长度可变的，但是其中的信息（即结构中的路径名）却是长度可变的。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;值结果参数&quot;&gt;值—结果参数&lt;/h1&gt;

&lt;p&gt;当一个套接字地址结构的指针作为一个套接字函数的参数时，结构的长度也会作为一个参数来传递，不过其传递方式取决于该结构的传递方向：是从进程到内核，还是从内核到进程。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;从进程到内核：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;有3个函数——bind、connect和sendto。这些函数的一个参数是指向某个套接字地址结构的指针，另一个参数是该结构的整数大小，例如：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_3/UNP3.3.1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这样内核知道到底需要从进程复制多少数据进来，如图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_3/UNP3.3.2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;从内核到进程：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;有4个函数——accept、recvfrom、getsockname 和 getpeername。这四个函数的其中两个参数是指向套接字地址结构和指向该结构长度的指针，例如：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_3/UNP3.3.3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;label style=&quot;color:red&quot;&gt;将长度以指针传递给内核的原因是：&lt;/label&gt;&lt;/p&gt;

&lt;p&gt;当函数被调用时，结构大小是一个值（value），它告诉内核该结构的大小，这样内核在写该结构时不至于越界；当函数返回时，结构大小又是一个结果（result），它告诉进程内核在该结构中究竟存储了多少信息。这种类型的参数称为值—结果（value-result）参数。&lt;/p&gt;

&lt;p&gt;如图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_3/UNP3.3.4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;除这四个函数外，还有其他 值—结果参数相关的函数：&lt;/p&gt;

&lt;p&gt;1，select函数中间的3个参数。&lt;/p&gt;

&lt;p&gt;2，getsockopt函数的长度参数。&lt;/p&gt;

&lt;p&gt;3，ifconf结构中的ifc_len字段。&lt;/p&gt;

&lt;p&gt;4，sysctl函数两个长度参数中的第一个。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;字节排序函数&quot;&gt;字节排序函数&lt;/h1&gt;

&lt;p&gt;由于历史的原因和POSIX规范的规定，套接字地址结构中的某些字段必须按照网络字节序进行维护。因此我们要关注如何在&lt;a href=&quot;https://waterwoodfountainhead.github.io/unp/2019/06/26/Unp-Nouns.html&quot;&gt;主机字节序和网络字节序(nouns第14条)&lt;/a&gt;之间相互转换。这两种字节序之间的转换使用以下4个函数：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_3/UNP3.4.1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;h代表host，n代表network，s代表short，l代表long。（short和long这两个称谓是出自4.2BSD的Digital VAX实现的历史产物。）我们应该把s视为一个16位的值（例如TCP或UDP端口号），把l视为一个32位的值（例如IPv4地址）。&lt;/p&gt;

&lt;p&gt;当使用这些函数时，我们并不关心主机字节序和网络字节序的真实值。在那些与网际协议所用字节序（大端）相同的系统中，这四个函数通常被定义为空宏。&lt;/p&gt;

&lt;p&gt;于此同时，我们也应该了解下&lt;a href=&quot;https://waterwoodfountainhead.github.io/unp/2019/06/26/Unp-Nouns.html&quot;&gt;因特网标准的两条重要约定(nouns第15条)&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;字节操纵函数&quot;&gt;字节操纵函数&lt;/h1&gt;

&lt;p&gt;名字以b（表示字节）开头的第一组函数起源于4.2BSD，几乎所有现今支持套接字函数的系统仍然提供它们。名字以mem（表示内存）开头的第二组函数起源于ANSI C标准，支持ANSIC函数库的所有系统都提供它们。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4.2BSD&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_3/UNP3.5.1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Bzero函数：它把目标字节串中指定数目的字节置为0。我们可以使用该函数来把一个套接字地址结构初始化为0。&lt;/p&gt;

&lt;p&gt;Bcopy函数 ：它将指定数目的字节从源字节串移到目标字节串。&lt;/p&gt;

&lt;p&gt;Bcmp函数：它比较两个任意的字节串，若相同则返回值为0，否则返回值为非0。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ANSI C函数&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_3/UNP3.5.2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Memset函数：它把目标字节串指定数目的字节置为值c。&lt;/p&gt;

&lt;p&gt;Memcpy函数：它类似bcopy，不过两个指针参数的顺序是相反的。&lt;strong&gt;注意&lt;/strong&gt;：当源字节串与目标字节串重叠时，bcopy能够正确处理，但是memcpy的操作结果却不可知。这种情形下必须改用ANSI C的memmove函数。memcpy的赋值顺序（从左往右）：dest = src 。&lt;/p&gt;

&lt;p&gt;Memcmp函数：它比较两个任意的字节串，若相同则返回0，否则返回一个非0值，是大于0还是小于0则取决于第一个不等的字节。注意：比较操作是在假设两个不等的字节均为无符号字符（unsigned char）的前提下完成的。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;两组地址转换函数&quot;&gt;两组地址转换函数&lt;/h1&gt;

&lt;p&gt;有两组函数可以在ASCII字符串（人类偏爱的格式）与网络字节序的二进制值（这是存放在套接字地址结构中的值）之间转换网际地址。&lt;/p&gt;

&lt;p&gt;（1）inet_aton、inet_addr 和 inet_ntoa在点分十进制数串（例如“206.168.112.96”）与它长度为32位的网络字节序二进制值间转换IPv4地址。&lt;/p&gt;

&lt;p&gt;（2）两个较新的函数inet_pton 和 inet_ntop对于IPv4地址和IPv6地址都适用。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;inet_aton、inet_addr 和 inet_ntoa 函数&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_3/UNP3.6.1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;inet_aton 函数：它将strptr所指C字符串转换成一个32位的网络字节序二进制值，并通过指针addrptr来存储。若成功则返回1，否则返回0。它有一个特性：如果addrptr指针为空，那么该函数仍然对输入的字符串执行有效性检查，但是不存储任何结果。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://waterwoodfountainhead.github.io/unp/2019/06/26/Unp-Nouns.html&quot;&gt;inet_addr 函数已被废弃(nouns第16条)。&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;inet_ntoa 函数：它将一个32位的网络字节序二进制IPv4地址转换成相应的点分十进制数串。由该函数的返回值所指向的字符串驻留在静态内存中。这意味着该函数是不可重入的。最后，它的参数是以结构的值传递的，这是很罕见的。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;inet_pton 和 inet_ntop 函数&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_3/UNP3.7.1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;函数名中p和n分别代表表达（presentation）和数值（numeric）。&lt;/p&gt;

&lt;p&gt;地址的表达格式通常是ASCII字符串，数值格式则是存放到套接字地址结构中的二进制值。&lt;/p&gt;

&lt;p&gt;这两个函数的family参数既可以是AF_INET，也可以是AF_INET6。如果以不被支持的地址族作为family参数，这两个函数就都返回一个错误，并将errno置为EAFNOSUPPORT。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;inet_pton 函数：它尝试转换由strptr指针所指的字符串，并通过addrptr指针存放二进制结果。若成功则返回值为1，否则如果对所指定的family而言输入的字符串不是有效的表达格式，那么返回值为0。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;inet_ntop 函数：它进行相反的转换，从数值格式（addrptr）转换到表达格式（strptr）。len参数是目标存储单元的大小，以免该函数溢出其调用者的缓冲区。为有助于指定这个大小，在&amp;lt;netinet/in.h&amp;gt;头文件中有如下定义：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_3/UNP3.7.2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;关于inet_ntop的参数：&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;（1）如果len参数太小，不足以容纳表达格式结果（包括结尾的空字符），那么返回一个空指针，并置errno为ENOSPC。&lt;/p&gt;

&lt;p&gt;（2）它的strptr参数不可以是一个空指针。调用者必须为目标存储单元分配内存并指定其大小。调用成功时，这个指针就是该函数的返回值。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总结inet_aton、inet_addr 和 inet_ntoa 、inet_pton 和 inet_ntop 函数&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_3/UNP3.7.3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 27 Jun 2019 10:00:00 +0800</pubDate>
        <link>http://localhost:4000/unp/2019/06/27/Unp-Chapter-3.html</link>
        <guid isPermaLink="true">http://localhost:4000/unp/2019/06/27/Unp-Chapter-3.html</guid>
        
        
        <category>unp</category>
        
      </item>
    
      <item>
        <title>[Unp]Chapter 2</title>
        <description>&lt;h1 id=&quot;tcp连接终止&quot;&gt;TCP连接终止&lt;/h1&gt;

&lt;p&gt;讲TIME_WAIT前，我们需要了解下&lt;a href=&quot;https://waterwoodfountainhead.github.io/unp/2019/06/26/Unp-Nouns.html&quot;&gt;迷途(Nouns第12条)&lt;/a&gt;和TCP连接终止的过程，如图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_2/UNP2.6.1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;TCP的终结需要4个分节：&lt;/p&gt;

&lt;p&gt;（1）客户端首先调用close，我们称该端执行主动关闭（active close）。该端的TCP于是发送一个FIN分节，表示数据发送完毕。&lt;/p&gt;

&lt;p&gt;（2）接收到这个FIN的对端执行被动关闭（passive close）。这个FIN由TCP确认。服务端接收FIN意味着服务端的应用进程在相应连接上再无额外数据可接收。&lt;/p&gt;

&lt;p&gt;（3）一段时间后，接收到这个文件结束符的应用进程将调用close关闭它的套接字。这导致它的TCP也发送一个FIN。&lt;/p&gt;

&lt;p&gt;（4）接收这个最终FIN的客户端的TCP（即执行主动关闭的那一端）确认这个FIN。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;time_wait状态&quot;&gt;TIME_WAIT状态&lt;/h1&gt;

&lt;p&gt;先介绍下TIME_WAIT状态：这个状态的持续时间是最长分节生命期（maximum segment lifetime，MSL）的两倍，有时候称之为2MSL。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;那么，TIME_WAIT状态有什么作用呢？&lt;/p&gt;

&lt;p&gt;(1) 可靠地实现TCP全双工连接的终止；&lt;/p&gt;

&lt;p&gt;假设最终的ACK丢失了来解释。服务器将重新发送它的最终那个FIN，因此客户必须维护状态信息，以允许它重新发送最终那个ACK。要是客户不维护状态信息，它将响应以一个RST（另外一种类型的TCP分节），该分节将被服务器解释成一个错误。如果TCP打算执行所有必要的工作以彻底终止某个连接上两个方向的数据流（即全双工关闭），那么它必须正确处理连接终止序列4个分节中任何一个分节丢失的情况。&lt;/p&gt;

&lt;p&gt;这也说明了执行主动关闭的那一端(客户端)由于要重传最后一个ACK，所以是处于TIME_WAIT状态。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;(2) 允许老的重复分节在网络中消逝。&lt;/p&gt;

&lt;p&gt;有时候一个连接可能会在关闭后，又在相同的ip地址和端口之间建立一个连接。因此TCP必须防止这个连接的老的重复分组在该连接已终止后再现，以免被误解成属于同一连接的某个新的化身。&lt;/p&gt;

&lt;p&gt;为此，TCP将不给处于TIME_WAIT状态的连接发起新的化身。既然TIME_WAIT状态的持续时间是MSL的2倍，这就足以让某个方向上的分组最多存活MSL秒即被丢弃，另一个方向上的应答最多存活MSL秒也被丢弃。通过实施这个规则，我们就能保证每成功建立一个TCP连接时，来自该连接先前化身的老的重复分组都已在网络中消逝了。&lt;/p&gt;
</description>
        <pubDate>Wed, 26 Jun 2019 16:00:00 +0800</pubDate>
        <link>http://localhost:4000/unp/2019/06/26/Unp-Chapter-2.html</link>
        <guid isPermaLink="true">http://localhost:4000/unp/2019/06/26/Unp-Chapter-2.html</guid>
        
        
        <category>unp</category>
        
      </item>
    
      <item>
        <title>[Unp]Nouns</title>
        <description>&lt;p&gt;1，&lt;strong&gt;路由器&lt;/strong&gt;是广域网的设备。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;2，&lt;strong&gt;因特网&lt;/strong&gt;是当今最大的广域网。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;3，TCP/IP协议概况&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/NOUNS/NOUNS_3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;4，&lt;strong&gt;RFC&lt;/strong&gt;——所有网际协议由一个或多个称为请求评注（Request for Comments，RFC）的文档定义，第三条内容里面的协议就是它们的正式规范。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;5，&lt;strong&gt;IPv4/IPv6主机&lt;/strong&gt; 或 &lt;strong&gt;双栈主机&lt;/strong&gt; 表示同时支持IPv4和IPv6的主机。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;6，&lt;strong&gt;被动打开（passive open）&lt;/strong&gt;，通常通过调用socket、bind和listen这3个函数来完成。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;7，&lt;strong&gt;主动打开（active open）&lt;/strong&gt;，通过调用connect发起。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;8，&lt;strong&gt;SYN&lt;/strong&gt;，一个同步分节。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;9，&lt;strong&gt;ACK&lt;/strong&gt;，一个确认分节。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;10，&lt;strong&gt;主动关闭（active close）&lt;/strong&gt;，某个应用进程首先调用close，称该端执行主动关闭。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;11，&lt;strong&gt;MSL&lt;/strong&gt;，它是任何IP数据报能够在因特网中存活的最长时间。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;12，&lt;strong&gt;迷途&lt;/strong&gt;，通常是路由异常的结果。&lt;/p&gt;

&lt;p&gt;例如：某个路由器崩溃或某两个路由器之间的某个链路断开时，路由协议需花数秒钟到数分钟的时间才能稳定并找出另一条通路。在这段时间内有可能发生路由循环（路由器A把分组发送给路由器B，而B再把它们发送回A），我们关心的分组可能就此陷入这样的循环。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;13，&lt;strong&gt;网际套接字地址结构&lt;/strong&gt;，它是IPv4套接字地址结构，它以sockaddr_in命名。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;14，&lt;strong&gt;小端（little-endian）&lt;/strong&gt;字节序，是将低序字节存储在起始地址的方法；&lt;strong&gt;大端（big-endian）&lt;/strong&gt;字节序，是将高序字节存储在起始地址的方法。如图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/NOUNS/NOUNS_14.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;主机字节序&lt;/strong&gt;，是某个给定系统所用的字节序的名称。&lt;/p&gt;

&lt;p&gt;由于网络协议必须制定一个网络字节序（network byte order），其中网际协议使用大端字节序来传送这些多字节整数。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;15，&lt;strong&gt;因特网标准的两个重要约定&lt;/strong&gt;：1）大多数因特网标准使用八位组（octet）这个术语而不是使用字节来表示8位的量。2）另一约定是位序。如图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/NOUNS/NOUNS_15.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;它表示按照在线缆上出现的顺序排列4个字节（32个位），最左边的位是最早出现的最高有效位。注意位序的编号从0开始，分配给最高有效位的编号位0。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;16，&lt;strong&gt;inet_addr函数被废弃的原因&lt;/strong&gt;：它进行相同的转换，返回值为32位的网络字节序二进制值。但是，该函数存在两个问题：&lt;/p&gt;

&lt;p&gt;1）当出错时该函数返回 INADDR_NONE常值（通常是一个32位均为1的值）。这意味着点分十进制数串255.255.255.255（这是IPv4的有限广播地址）不能由该函数处理，因为它的二进制值被用来当作该函数的失败返回值。&lt;/p&gt;

&lt;p&gt;2）一些手册页面声明该函数出错时返回-1而不是INADDR_NONE。这样在对该函数的返回值（一个无符号的值）和一个负常值（-1）进行比较时可能会发生问题，具体取决于C编译器。&lt;/p&gt;

</description>
        <pubDate>Wed, 26 Jun 2019 15:00:00 +0800</pubDate>
        <link>http://localhost:4000/unp/2019/06/26/Unp-Nouns.html</link>
        <guid isPermaLink="true">http://localhost:4000/unp/2019/06/26/Unp-Nouns.html</guid>
        
        
        <category>unp</category>
        
      </item>
    
      <item>
        <title>[Apue]Linux-Sync、Fsync and Fdatasync</title>
        <description>&lt;h1 id=&quot;在linux操作系统上怎样保证对文件的更新内容成功持久化到硬盘&quot;&gt;在Linux操作系统上，怎样保证对文件的更新内容成功持久化到硬盘？&lt;/h1&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;1--write不够需要fsync&quot;&gt;1.  write不够，需要fsync&lt;/h2&gt;

&lt;p&gt;一般情况下，对硬盘（或者其他持久存储设备）文件的write操作，更新的只是内存中的页缓存（page cache）。但是脏页面不会立即更新到硬盘中，而是由操作系统统一调度，如，由专门的flusher内核线程在满足一定条件时（如一定时间间隔、内存中的脏页达到一定比例）内将脏页面同步到硬盘上（放入设备的IO请求队列）。&lt;/p&gt;

&lt;p&gt;因为write调用不会等到硬盘IO完成之后才返回，因此如果OS在write调用之后、硬盘同步之前崩溃，则数据可能丢失。虽然这样的时间窗口很小，但是对于需要保证事务的持久化（durability）和一致性（consistency）的数据库程序来说，write()所提供的“松散的异步语义”是不够的，通常需要OS提供的同步IO（synchronized-IO）原语来保证：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unistd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fsync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;fsync的功能是确保文件fd所有已修改的内容已经正确同步到硬盘上，该调用会阻塞等待直到设备报告IO完成。&lt;/p&gt;

&lt;p&gt;注意：如果采用内存映射文件的方式进行文件IO（使用mmap，将文件的page cache直接映射到进程的地址空间，通过写内存的方式修改文件），也有类似的系统调用来确保修改的内容完全同步到硬盘之上：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;incude&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sys&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mman&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;msync需要指定同步的地址区间，如此细粒度的控制似乎比fsync更加高效（因为应用程序通常知道自己的脏页位置），但实际上（Linux）kernel中有着十分高效的数据结构，能够很快地找出文件的脏页，使得fsync只会同步文件的修改内容。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;2--fsync的性能问题与fdatasync&quot;&gt;2.  fsync的性能问题，与fdatasync&lt;/h2&gt;

&lt;p&gt;除了同步文件的修改内容（脏页），fsync还会同步文件的描述信息（metadata，包括size、访问时间st_atime &amp;amp; st_mtime等等），因为文件的数据和metadata通常存在硬盘的不同地方，因此fsync至少需要两次IO写操作，fsync的man page这样说：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Unfortunately fsync() will always initialize two write operations : one for the newly written data and another one in order to update the modification time stored in the inode.
If the modification time is not a part of the transaction concept fdatasync() can be used to avoid unnecessary inode disk write operations.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;多余的一次IO操作，有多么昂贵呢？根据Wikipedia的数据，当前硬盘驱动的平均寻道时间（Average seek time）大约是3~15ms，7200RPM硬盘的平均旋转延迟（Average rotational latency）大约为4ms，因此一次IO操作的耗时大约为10ms左右。这个数字意味着什么？下文还会提到。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Posix同样定义了fdatasync，放宽了同步的语义以提高性能：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unistd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fdatasync&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Fdatasync的功能与fsync类似，但是仅仅在必要的情况下才会同步metadata，因此可以减少一次IO写操作。那么，什么是“必要的情况”呢？根据man page中的解释：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;fdatasync does not flush modified metadata unless that metadata is needed in order to allow a subsequent data retrieval to be corretly handled.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;举例来说，文件的尺寸（st_size）如果变化，是需要立即同步的，否则OS一旦崩溃，即使文件的数据部分已同步，由于metadata没有同步，依然读不到修改的内容。而最后访问时间(atime) /修改时间(mtime)是不需要每次都同步的，只要应用程序对这两个时间戳没有苛刻的要求，基本无伤大雅。&lt;/p&gt;

&lt;p&gt;注意：open时的参数O_SYNC/O_DSYNC有着和fsync/fdatasync类似的语义：使每次write都会阻塞等待硬盘IO完成。（实际上，Linux对O_SYNC/O_DSYNC做了相同处理，没有满足Posix的要求，而是都实现了fdatasync的语义）相对于fsync/fdatasync，这样的设置不够灵活，应该很少使用。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;3-使用fdatasync优化日志同步&quot;&gt;3. 使用fdatasync优化日志同步&lt;/h2&gt;

&lt;p&gt;文章开头时已提到，为了满足事务要求，数据库的日志文件是常常需要同步IO的。由于需要同步等待硬盘IO完成，所以事务的提交操作常常十分耗时，成为性能的瓶颈。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在Berkeley DB下，如果开启了AUTO_COMMIT（所有独立的写操作自动具有事务语义）并使用默认的同步级别（日志完全同步到硬盘才返回），写一条记录的耗时大约为5~10ms级别，基本和一次IO操作（10ms）的耗时相同。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我们已经知道，在同步上fsync是低效的。但是如果需要使用fdatasync减少对metadata的更新，则需要确保文件的尺寸在write前后没有发生变化。日志文件天生是追加型（append-only）的，总是在不断增大，似乎很难利用好fdatasync。且看Berkeley DB是怎样处理日志文件的：&lt;/p&gt;

&lt;blockquote&gt;

  &lt;p&gt;&lt;br /&gt;1.每个log文件固定为10MB大小，从1开始编号，名称格式为“log.%010d”
&lt;br /&gt;2.每次log文件创建时，先写文件的最后1个page，将log文件扩展为10MB大小
&lt;br /&gt;3.向log文件中追加记录时，由于文件的尺寸不发生变化，使用fdatasync可以大大优化写log的效率
&lt;br /&gt;4.如果一个log文件写满了，则新建一个log文件，也只有一次同步metadata的开销&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;转至：
&lt;a href=&quot;https://blog.csdn.net/cywosp/article/details/8767327&quot;&gt;《linux 同步IO: sync、fsync与fdatasync》&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 24 Jun 2019 00:40:32 +0800</pubDate>
        <link>http://localhost:4000/apue/2019/06/24/Apue-Linux-Sync-Fsync-and-Fdatasync.html</link>
        <guid isPermaLink="true">http://localhost:4000/apue/2019/06/24/Apue-Linux-Sync-Fsync-and-Fdatasync.html</guid>
        
        
        <category>apue</category>
        
      </item>
    
      <item>
        <title>[Apue]Chapter 3</title>
        <description>&lt;h1 id=&quot;文件描述符&quot;&gt;文件描述符&lt;/h1&gt;
&lt;p&gt;概念：所有打开的文件都通过文件描述符，它是一个非负整数。&lt;/p&gt;

&lt;p&gt;原理 ：当打开一个现有文件或创建一个新文件时，内核向进程返回一个文件描述符。当读写一个文件时，使用open或creat返回的文件描述符标识该文件，将其作为参数传给read或write。&lt;/p&gt;

&lt;p&gt;补充：每个进程创建的时候都会打开三个文件：stdin(描述符0)，stdout(描述符1)和stderr(描述符2)。这三个文件对应符号常量 STDIN_FILENO、STDOUT_ FILENO、STDERR_ FILENO。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;函数open-和-openat&quot;&gt;函数Open 和 Openat&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/images/Apue/APUE_3/Unix3.3.1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;( “…”参数表示剩下的参数是可变的)&lt;/p&gt;

&lt;p&gt;作用：调用Open或Openat函数可以打开或创建一个文件。不过，Openat的出现是希望解决两个问题：&lt;/p&gt;

&lt;p&gt;（1）让线程可以使用相对路径名打开目录中的文件，而不局限于只能打开当前工作目录。&lt;/p&gt;

&lt;p&gt;（2）避免TOCTTOU错误，也称time-of-check-to-time-of-use (两个函数调用，其中一个的调用依赖另外一个调用的结果，那么这是不好的。)&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;函数creat&quot;&gt;函数Creat&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/images/Apue/APUE_3/Unix3.4.1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;作用：调用creat函数创建一个新文件，并用只写方式打开。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;函数close&quot;&gt;函数Close&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/images/Apue/APUE_3/Unix3.5.1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;作用：调用close函数关闭进程中一个打开的文件。关闭一个文件时还会释放该进程加在该文件上的所有记录锁。&lt;/p&gt;

&lt;p&gt;需要注意的是，内核中的资源不会被立刻释放掉，假设有一个或多个进程的多个文件文件描述符指向同一个内核的资源，那么只有当最后一个文件描述符被close时，内核的资源才会被释放。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;函数lseek&quot;&gt;函数Lseek&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/images/Apue/APUE_3/Unix3.6.1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;作用：调用lseek可以显示地为一个打开文件设置偏移量。&lt;/p&gt;

&lt;p&gt;由于Lseek只将当前的文件偏移量记录在内核中，所以并不会引起任何I/O操作。而且，偏移量是可以大于文件的当前长度。如果在偏移量后写入字节将加长该文件，就会在文件中构成一个空洞，没有被实际写入文件的所有字节由0 表示。空洞是否占用硬盘空间是由文件系统决定的。因为lseek使用的偏移量是用off_t类型表示的，所以实现需要根据各自平台选择大小合适的数据类型。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;函数read&quot;&gt;函数Read&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/images/Apue/APUE_3/Unix3.7.1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;作用：调用read函数从打开文件中读数据。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;函数write&quot;&gt;函数Write&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/images/Apue/APUE_3/Unix3.8.1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;作用：调用 write 函数向打开文件写数据。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;由于wirte是文件I/O，文件I/O是一种带有缓冲区的操作函数，而在实际的操作过程中，势必会出现阻塞与非阻塞(网络)相关的问题：&lt;/p&gt;

&lt;p&gt;write函数首先将进程需要发送的数据先放在进程缓冲区中，然后向socket的发送缓冲区进行拷贝。但是，可能会出现这样情况，即当进程缓冲区中的数据量大于此时发送缓冲区中所能接受的数据量时，若此时处于阻塞模式，应用进程将会被挂起，直到进程缓冲区中的数据全部拷贝到发送缓冲区中，注意此时内核也不会返回write函数，因此，在阻塞模式下，若write函数正常返回，这也并不代表数据已经完成被对方进程接收，至多只能说明数据已经被发送缓冲区完全接受；若是处于非阻塞模式，此时write操作将会失败，内核会立即返回EAGAIN错误，有时候在某些地方说会返回EWOULDBLOCK错误，其实它们都一样，只是分别用于不同的系统，前者主要是出现于GNU系统，后者主要出现在类BSD系统。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;文件共享&quot;&gt;文件共享&lt;/h1&gt;

&lt;p&gt;Unix系统支持在不同进程间共享打开文件。内核用三种数据结构来表示打开文件，如图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Apue/APUE_3/Unix3.10.1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;（1）：文件描述符表，它里面包含 标志(文件描述符标志)和文件指针(指向一个文件表项的指针)。&lt;/p&gt;

&lt;p&gt;（2）：文件表，它里面包含 文件状态标志(读，写，添写，同步和非阻塞等)，当前文件偏移量和v节点指针(指向该文件v节点表项的指针)。&lt;/p&gt;

&lt;p&gt;（3）：v节点表项，它里面包含文件类型和对此文件进行各种操作函数的指针。同时，它还包含i节点。这些信息的作用是在打开文件时从磁盘上读入内存。注意，Linux没有使用v节点。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;如果两个独立的进程各自打开了同一文件，文件关系如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Apue/APUE_3/Unix3.10.2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;之所以每个进程都能获得自己的进程和文件表项，是因为可以使每个进程都有自己对该文件的当前偏移量。文件描述符标志只应用于一个进程的一个描述符;而文件状态标志则应用于指向给定的文件表项的任何进程中的所有描述符。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;对上图的进一步说明：&lt;/p&gt;

&lt;p&gt;（1）A进程每次写入后，在文件表项中的当前文件偏移量将会增加(由写入的字节数决定)。如果这导致当前文件偏移量超出了当前文件超度，那么该文件将会加长。&lt;/p&gt;

&lt;p&gt;（2）如果用具有追加写标志的文件执行写操作时，对应标志(O_APPEND) 会被设置到文件表项的文件状态标志中。当进行写操作时，文件表项的当前文件偏移量会被设置为i节点表项中的当前文件长度。&lt;/p&gt;

&lt;p&gt;（3）如果一个文件用lseek函数定位到文件当前的尾端，那么文件表项的当前文件偏移量会被设置为i节点表项中的当前文件长度。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;原子操作&quot;&gt;原子操作&lt;/h1&gt;

&lt;p&gt;原子操作（atomic operation）指的是由多步组成的一个操作。如果该操作原子地执行，则要么执行完所有步骤，要么一步也不执行，不可能只执行所有步骤的一个子集。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;XSI扩展允许原子性地定位并执行I/O——Pread和Pwrite：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Apue/APUE_3/Unix3.11.1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;调用praed相当于调用lseek后调用read，注意：（Pwrite与Pread类似）&lt;/p&gt;

&lt;p&gt;（1）调用pread时，无法中断其定位和读操作。&lt;/p&gt;

&lt;p&gt;（2）不更新当前文件偏移量，也就是从固定位置读取。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;函数dup和dup2&quot;&gt;函数Dup和Dup2&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/images/Apue/APUE_3/Unix3.12.1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;作用：可用来复制一个现有的文件描述符。如下图所示：（Dup后的文件数据结构）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Apue/APUE_3/Unix3.12.2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;注意：调用dup函数等同于先调用&lt;label style=&quot;color:red&quot;&gt;fcntl(fd, F_DUPFD, 0)&lt;/label&gt; ，而调用 dup2 等同于调用 &lt;label style=&quot;color:red&quot;&gt;close(fd2)&lt;/label&gt; 和 &lt;label style=&quot;color:red&quot;&gt;fcntl(fd, F_DUPFD, fd2)&lt;/label&gt; 。 Dup2 是一个原子操作，它与 funtl 有一些不同的 ettno 。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;函数syncfsync和fdatasync&quot;&gt;函数Sync、Fsync和Fdatasync&lt;/h1&gt;

&lt;p&gt;首先要引入一个概念：延迟写，即，传统的UNIX实现在内核中设有缓冲区高速缓存或页面高速缓存，大多数磁盘I/O都通过缓冲进行。&lt;/p&gt;

&lt;p&gt;我们将数据写入文件时，内核通常先将该数据复制到其中一个缓冲区中。如果该缓冲区尚未写满，则并不将其排入输出队列。而是等待其写满或者当内核需要重用该缓冲区以便存放其他磁盘块数据时，再将该缓冲排入输出队列，然后待其到达队首时，才进行实际的I/O操作。&lt;/p&gt;

&lt;p&gt;延迟写减少了磁盘读写次数，但是却降低了文件内容的更新速度，使得欲写到文件中的数据在一段时间内并没有写到磁盘上。当系统发生故障时，这种延迟可能造成文件更新内容的丢失。为了保证磁盘上实际文件系统与缓冲区高速缓存中内容的一致性，UNIX系统提供了Sync、Fsync和Fdatasync三个函数。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Apue/APUE_3/Unix3.13.1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;sync 只是将所有修改过的块缓冲区排入写队列，然后就返回，它并不等待实际写磁盘操作结束。&lt;/p&gt;

&lt;p&gt;一般情况下，名为 update 的系统守护进程周期性地调用（一般每隔 30 秒） sync 函数。这就保证了定期冲洗（flush）内核的块缓冲区。命令 sync(1)也调用 sync 函数。&lt;/p&gt;

&lt;p&gt;Fsync 函数只对由文件描述符 fd 指定的一个文件起作用，并且等待写磁盘操作结束才返回。Fsync 可用于数据库这样的应用程序，这种应用程序需要确保修改过的块立即写到磁盘上。&lt;/p&gt;

&lt;p&gt;Fdatasync 函数类似于 fsync，但它只影响文件的数据部分。而除数据外， fsync 还会同步更新文件的属性。我经过查阅资料后，由于篇幅原因，因此自己另整理了一份：（点击下面标题进入）&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://waterwoodfountainhead.github.io/apue/2019/06/23/Apue-Linux-Sync-Fsync-and-Fdatasync.html&quot;&gt;《深刻探讨Sync、Fsync和Fdatasync》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;函数fcntl&quot;&gt;函数Fcntl&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/images/Apue/APUE_3/Unix3.14.1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;作用：(关于cmd参数的详解见APUE p66)&lt;/p&gt;

&lt;p&gt;（1）复制一个已有的描述符（cmd = F_DUPFD 或 F_DUPFD_CLOEXEC）。&lt;/p&gt;

&lt;p&gt;（2）获取/设置文件描述符标志（cmd = F_GETFD 或 F_SETFD）。&lt;/p&gt;

&lt;p&gt;（3）获取/设置文件状态标志（cmd = F_GETFL 或 F_SETFL）。&lt;/p&gt;

&lt;p&gt;（4）获取/设置异步 I/O 所有权（cmd = F_GETOWN 或 F_SETOWN）。&lt;/p&gt;

&lt;p&gt;（5）获取/设置记录锁（cmd = F_GETLK、 F_SETLK 或 F_SETLKW）。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;关于同步写和延迟写&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当支持同步写时，系统时间和时钟时间会显著增加。如果同步写所用的系统时间不比延迟写增加的多时，要么操作系统对延迟写和同步写操作的工作量相同;要么 O_SYNC 标志并没有起到期望的作用，在这种情况下，Linux 操作系统并不允许我们用 fcntl 设置 O_SYNC 标志，而是显示失败但没有返回出错（如果在文件打开时能指定该标志，我们应该遵重这个标志的）。&lt;/p&gt;

&lt;p&gt;同步写比延迟写所消耗的时间增加了很多，而且在同步写后再调用函数 fsync 并不产生测量结果上的显著差别。不过，在延迟写后增加一个 fsync 函数调用，测量结果的差别也不大。其可能原因是，在向某个文件写入新数据时，操作系统已经将以前写入的数据都冲洗到了磁盘上，所以在调用函数 fsync 时只需要做很少的工作。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;函数ioctl&quot;&gt;函数ioctl&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/images/Apue/APUE_3/Unix3.15.1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;作用：它是设备驱动程序中设备控制接口函数，一个字符设备驱动通常会实现设备打开、关闭、读、写等功能，在一些需要细分的情境下，如果需要扩展新的功能，通常以增设 ioctl() 命令的方式实现。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;对于用户态程序的ioctl&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在实际应用中，ioctl 最常见的 errorno 值为 ENOTTY（error not a typewriter），顾名思义，即第一个参数 fd 指向的不是一个字符设备，不支持 ioctl 操作，这时候应该检查前面的 open 函数是否出错或者设备路径是否正确。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;对于驱动程序的ioctl&lt;/strong&gt;
&lt;img src=&quot;/images/Apue/APUE_3/Unix3.15.2.png&quot; alt=&quot;&quot; /&gt;
unlocked_ioctl，顾名思义，应该在无大内核锁（BKL）的情况下调用；compat_ioctl，compat 全称 compatible（兼容的），主要目的是为 64 位系统提供 32 位 ioctl 的兼容方法，也是在无大内核锁的情况下调用。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;devfd-目录&quot;&gt;/dev/fd 目录&lt;/h1&gt;

&lt;p&gt;概念：/dev/fd文件主要由shell使用，它允许作为路径名被程序作为参数调用。打开文件/dev/fd/n 等效于复制描述符n (假设描述符n是打开的)。&lt;/p&gt;

&lt;p&gt;如果你在一个程序调用creat，并且路径名参数是&lt;label style=&quot;color:red&quot;&gt;/dev/fd/1&lt;/label&gt;。虽然，程序可以工作，但是，你一定要小心。你在 Linux 上这么做必须非常小心，因为 Linux 实现使用指向实际文件的符号链接，所以在&lt;label style=&quot;color:red&quot;&gt;/dev/fd&lt;/label&gt;文件上使用 creat 会导致底层文件被截断。&lt;label style=&quot;color:red&quot;&gt;/dev/fd&lt;/label&gt; 在Linux实现中是个例外，它把文件描述符映射成指向底层物理文件的符号链接。&lt;/p&gt;
</description>
        <pubDate>Mon, 24 Jun 2019 00:38:32 +0800</pubDate>
        <link>http://localhost:4000/apue/2019/06/24/Apue-Chapter-3.html</link>
        <guid isPermaLink="true">http://localhost:4000/apue/2019/06/24/Apue-Chapter-3.html</guid>
        
        
        <category>apue</category>
        
      </item>
    
  </channel>
</rss>
