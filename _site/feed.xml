<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Fountainhead</title>
    <description>Blog</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Mon, 05 Aug 2019 17:19:08 +0800</pubDate>
    <lastBuildDate>Mon, 05 Aug 2019 17:19:08 +0800</lastBuildDate>
    <generator>Jekyll v3.8.5</generator>
    
      <item>
        <title>[Unp2]Chapter 3</title>
        <description>&lt;h1 id=&quot;概述&quot;&gt;概述&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;以下三种类型的IPC合称为System V IPC：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;System V消息队列（第6章）；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;System V信号量（第11章）；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;System V共享内存区（第14章）。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个称谓作为 这三种 IPC 机制的通称，是因为它们源自System V Unix。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;图3-1 汇总了所有 System V IPC 函数。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp2/UNP2_3/UNP2_1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;key_t-键和-ftok-函数&quot;&gt;key_t 键和 ftok 函数&lt;/h1&gt;

&lt;p&gt;图1-4 中注明，三种类型的 System V IPC 使用 key_t 值作为它们的名字。头文件&amp;lt;sys/types.h&amp;gt; 把 key_t 这个数据类型定义为一个整数，它至少是一个32位的整数。这些整数值通常是由 ftok函数 赋予的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp2/UNP2_1/UNP2_4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
函数ftok 把一个已存在的路径名和一个整数标识符，转换成一个 key_t 值，称为 IPC键。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp2/UNP2_3/UNP2_2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;该函数把从 pathname 导出的信息与 id的低序8位 组合成一个整数IPC键。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;该函数假定对于使用System V IPC的某个给定应用来说，客户和服务器同意使用对该应用有一定意义的pathname。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;它可以是服务器守护程序的路径名、服务器使用的某个公共数据文件的路径名或者系统上的某个其他路径名。&lt;/p&gt;

&lt;p&gt;如果客户和服务器之间只需单个 IPC通道，那么可以使用譬如说值为1的 id。&lt;/p&gt;

&lt;p&gt;如果需要多个 IPC通道，比如，从客户到服务器一个通道，从服务器到客户又一个通道。那么作为一个例子，一个通道可使用值为 1的id，另一个通道可使用值为 2的id。&lt;/p&gt;

&lt;p&gt;客户和服务器一旦在 pathname 和 id 上达成一致，双方就都能调用 ftok函数 把 pathname 和 id 转换成同一个 IPC键。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ftok函数 的典型实现调用 stat函数，然后组合以下三个值。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;(1) pathname 所在的文件系统的信息（stat 结构的 st_dev成员）。&lt;/p&gt;

&lt;p&gt;(2) 该文件在本文件系统内的索引节点号（stat 结构的 st_ino成员）。&lt;/p&gt;

&lt;p&gt;(3) id的低序8位（不能为0）。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Unix 98现在宣称：当 ftok函数 的 id参数 的低序8位为0 时，该函数的行为是未指定的。查看一番后，作者发现 Solaris 和 Digital Unix 中关于 ftok 函数的手册页面也作了同样的声明。作者不知道这是什么时候加上的，而且作者于1991年编写的“System V Interface Definition”中也没有这样的声明。AIX甚至走得更远，若 id 为0，则返回一个错误。实际上 ftok函数 的三种不同实现——System V Release 2、GNU libc 和 BSD/OS——没有一个要求 id为非零：它们只是在 id的低序8位中 作逻辑或，而不管它的值。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;这三个值的组合通常会产生一个32位键。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;不能保证两个不同的路径名与同一个 id 的组合产生不同的键，因为上面所列三个条目（文件系统标识符、索引节点、id）中的信息位数可能大于一个整数的信息位数。&lt;/p&gt;

&lt;p&gt;索引节点绝不会是0，因此，大多数实现把 IPC_PRIVATE定义为0。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如果 pathname 不存在，或者对于调用进程不可访问，ftok函数 就返回−1。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;注意，路径名用于产生键的文件，不能是在服务器存活期间由服务器反复创建并删除的文件，因为该文件每次创建时，由系统赋予的索引节点号很可能不一样。于是，对下一个调用者来说，由 ftok函数 返回的键也可能不同。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;ipc_perm-结构&quot;&gt;ipc_perm 结构&lt;/h1&gt;

&lt;p&gt;内核给每个 IPC对象 维护一个信息结构，其内容跟内核给文件维护的信息类似。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp2/UNP2_3/UNP2_3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;该结构以及 System V IPC函数 使用的较为明显的常值，都定义在 &amp;lt;sys/ipc.h&amp;gt;头文件中。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;创建与打开-ipc-通道&quot;&gt;创建与打开 IPC 通道&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;创建或打开一个 IPC对象 的三个 getXXX函数（见图3-1）的第一个 参数key 是类型为 key_t 的 IPC 键，返回值identifier 是一个整数标识符。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp2/UNP2_3/UNP2_1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;该标识符不同于 ftok函 数的 id参数，我们不久就会看到。对于 key值，应用程序有两种选择。&lt;/p&gt;

&lt;p&gt;(1) 调用 ftok函数，给它传递 pathname 和 id。&lt;/p&gt;

&lt;p&gt;(2) 指定 key 为 IPC_PRIVATE，这将保证会创建一个新的、唯一的 IPC对象。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;图3-3展示有关步骤的顺序。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp2/UNP2_3/UNP2_4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;所有三个 getXXX函数（见图3-1）都有一个名为 oflag的参数，它指定 IPC对象 的读写权限位（ ipc_perm结构 的 mode成员），并选择是创建一个新的 IPC对象 还是访问一个已存在的 IPC对象。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;这种选择的规则如下。&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;指定key为 IPC_PRIVATE 能保证创建一个唯一的 IPC对象。没有一对 id 和 pathname 的组合会导致 ftok函数 产生 IPC_PRIVATE 键值。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;设置 oflag参数 的 IPC_CREAT位 ，但不设置它的 IPC_EXCL位 的情况下，如果所指定键的 IPC对象 不存在，那就创建一个新的对象，否则返回该对象。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;同时设置 oflag参数 的 IPC_CREAT 和 IPC_EXCL位 的情况下，如果所指定键的 IPC对象 不存在，那就创建一个新的对象，否则返回一个 EEXIST错误，因为该对象已存在。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对 IPC对象 来说，IPC_CREAT 和 IPC_EXCL 的组合跟 open函数 的O_CREAT和O_EXCL的组合类似。&lt;/p&gt;

&lt;p&gt;设置IPC_EXCL位，但不设置 IPC_CREAT位 是没有意义的。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;图3-4展示了打开一个IPC对象的逻辑流程。图3-5 是展示 图3-4 所示逻辑的另一种形式。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp2/UNP2_3/UNP2_5.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp2/UNP2_3/UNP2_6.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意 图3-5 中间只有 IPC_CREAT，而没有 IPC_EXCL 标志的那一行，我们得不到一个指示以判别是创建了一个新对象，还是在引用一个已存在的对象。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;大多数应用程序中，由服务器创建 IPC对象，并指定 IPC_CREAT标志（如果它不关心该对象是否存在）或 【 IPC_CREAT  或 IPC_EXCL标志】（如果它需要检查该对象是否已经存在）。&lt;/p&gt;

&lt;p&gt;客户则不指定其中任何一个标志（它们假定服务器已经创建了该对象）。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;ipc-权限&quot;&gt;IPC 权限&lt;/h1&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;每当使用某个 getXXX函数（指定IPC_CREAT标志）创建一个新的 IPC对象 时，以下信息就保存到该对象的 ipc_perm 结构中。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp2/UNP2_3/UNP2_3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;(1) oflag参数 中 某些位 初始化ipc_perm结构 的 mode成员。图3-6展示了System V三种不同
IPC机制的权限位（记号»3的意思是将值右移3位）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp2/UNP2_3/UNP2_7.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;(2) cuid 和 cgid 成员分别设置为，调用进程的有效用户ID 和 有效组ID。这两个成员合称为，创建者ID（creator ID）。&lt;/p&gt;

&lt;p&gt;(3) ipc_perm 结构的 uid 和 gid 成员也分别设置为，调用进程的有效用户ID 和 有效组ID。这两个成员合称为，属主ID（owner ID）。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;尽管一个进程可通过调用相应 IPC机制 ctlXXX函数（所用命令为IPC_SET）修改属主ID，创建者ID 却从不改变。这三个ctlXXX函数 还允许一个进程修改某个 IPC对象 的 mode成员。&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;多数实现在&amp;lt;sys/msg.h&amp;gt;、&amp;lt;sys/sem.h&amp;gt;和&amp;lt;sys/shm.h&amp;gt;这三个头文件中定义图3-6中所示的6个常值：MSG_R、MSG_W、SEM_R、SEM_A、SHM_R、SHM_W。不过Unix 98没有这样的要求。SEM_A中的后缀A代表“alter”（改变）。
&lt;br /&gt;&lt;br /&gt;
这三个ctlXXX函数 不使用通常的文件模式创建掩码。消息队列、信号量或共享内存区对象的权限准确地设置成由这些函数所指定的值。
&lt;br /&gt;&lt;br /&gt;
Posix IPC 并不允许一个 IPC对象 的创建者改变该对象的属主。Posix IPC 中没有类似于 IPC_SET命令 的操作。然而如果 Posix IPC 名字存储在文件系统中，那么超级用户可使用 chown命令 改变其属主。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;每当有一个进程访问某个 IPC对象 时，IPC 就执行两级检查，该 IPC对象 被打开时（getXXX函数）执行一次，以后每次使用该对象时执行一次。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;(1) 每当有一个进程以某个getXXX函数 建立，来访问某个已存在 IPC对象 的通道时，IPC 就执行一次初始检查，验证调用者的 oflag参数 没有指定不在该对象ipc_perm结构mode成员中的任何访问位。这就是图3-4中底部的方框。举例来说，一个服务器进程可以把它的输入消息队列的 mode成员设置成关掉组成员读和其他用户读这两个权限位。&lt;/p&gt;

&lt;p&gt;任何进程调用针对该消息队列的 msgget函数 时，如果所指定的 oflag参数 包含这两位，那么该函数都将返回一个错误。然而由 getXXX函数 完成的这种测试并没有多大用处。它隐含假定调用者知道自己属于哪个权限范畴——用户、组成员或其他用户。&lt;/p&gt;

&lt;p&gt;如果创建者特意关掉了某些权限位，而调用者却指定了这些位，那么 getXXX函数 将检测出这个错误。然而任何进程都能够完全绕过这种检查，其办法是在得知该 IPC对象 已存在后，简单地指定一个值为0的 oflag参数 即可。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;(2) 每次 IPC操作 都对使用该操作的进程执行一次权限测试。&lt;/p&gt;

&lt;p&gt;举例来说，每当有一个进程试图使用 msgsnd函数 往某个消息队列放置一个消息时，msgsnd函数 将以下面所列的顺序执行（多个）测试。一旦某个测试赋予了访问权，其后的测试就不再执行。&lt;/p&gt;

&lt;p&gt;a) 超级用户总是赋予访问权。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
b) 如果当前进程的有效用户ID等于该IPC对象的uid值或cuid值，而且相应的访问位在该 IPC对象 的 mode成员 中是打开的，那么赋予访问权。&lt;/p&gt;

&lt;p&gt;这儿“相应的访问位”的意思是，如果调用者想要在该 IPC对象 上执行一个读操作（例如从某个消息队列接收一个消息），那么读位必须设置，如果想要执行一个写操作，那么写位必须设置。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
c) 如果 当前进程的有效组ID 等于 该IPC对象的gid值或cgid值，而且相应的访问位在该 IPC对象的mode成员 中是打开的，那么赋予访问权。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
d) 如果上面的测试没有一个为真，那么相应的 “其他用户” 访问位在该 IPC对象的mode成员 中必须是打开的才能赋予访问权。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;标识符重用&quot;&gt;标识符重用&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;ipc_perm结构 还含有一个名为 seq的变量，它是一个槽位使用情况序列号。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp2/UNP2_3/UNP2_3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;该变量是一个由内核为系统中每个潜在的 IPC对象 维护的计数器。每当删除一个 IPC对象 时，内核就递增相应的槽位号，若溢出则循环回0。&lt;/p&gt;

&lt;p&gt;本节讲述的是普通 SVR4 实现。Unix 98 没有强制使用该实现技巧。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;该计数器的存在有两个原因。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;首先，考虑由内核维护的用于打开文件的文件描述符。它们是些小整数，只在单个进程内有意义，也就是它们是进程特定的值。&lt;/p&gt;

&lt;p&gt;其次，如果我们试图从 文件描述符4 读，那么这种尝试只有该进程已在该描述符上打开了一个文件后才会奏效。它对于可能在另外一个与本进程无亲缘关系的进程中打开在 文件描述符4 上的文件来说，根本没有意义。然而，System V IPC标识符 却是系统范围的，而不是特定于进程的。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;我们从某个get函数（msgget、semget和shmget）获得一个IPC标识符（类似于文件描述符）。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这些标识符也是整数，不过它们的意义适用于所有进程。&lt;/p&gt;

&lt;p&gt;举例来说，如果有两个无亲缘关系的进程（一个是客户，一个是服务器）使用单个消息队列，那么由 msgget函数 返回的该消息队列的标识符在双方进程中必须是同一个整数值，这样双方才能访问同一个消息队列。&lt;/p&gt;

&lt;p&gt;这种特性意味着，某个行为不端的进程 可能会从 另外某个应用的消息队列 中读消息。办法是，尝试不同的小整数标识符，以期待找出一个（当前在使用的、允许读访问的）消息队列。&lt;/p&gt;

&lt;p&gt;如果这些标识符的取值是小整数（像文件描述符那样），那么找到一个有效标识符的可能性约为1:50（假设每个进程最多有约50个描述符）。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为避免这样的问题，这些 IPC机制 的设计者们把标识符值的可能范围扩大到包含所有整数，而不是仅仅包含小整数。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这种扩大是这么实现的：每次重用一个 IPC表项 时，把返回给调用进程的标识符值增加一个IPC表项数。&lt;/p&gt;

&lt;p&gt;举例来说，如果系统配置成最多50个消息队列，那么内核中的第一个消息队列表项首次被使用时，返回给进程的标识符值为0。该消息队列被删除，从而第一个表项得以重用后，所返回的标识符为50。再下一次重用时，该标识符变为100，如此等等。&lt;/p&gt;

&lt;p&gt;既然，seq变量 通常作为一个无符号长整数实现（见3.3节所示的ipc_perm结构），那么该表项只有在被重用 85 899 346（232/50，假设长整数为32位）次后，才循环回0。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;递增槽位使用情况序列号的另一个原因是，为了避免短时间内重用 System V IPC标识符。这有助于确保——过早终止的服务器重新启动后，不会重用标识符。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;ipcs-和-ipcrm-程序&quot;&gt;ipcs 和 ipcrm 程序&lt;/h1&gt;

&lt;p&gt;&lt;br /&gt;
由于 System V IPC 的三种类型不是以文件系统中的路径名标识的，因此使用标准的ls和rm
程序无法看到它们，也无法删除它们。&lt;/p&gt;

&lt;p&gt;不过实现了这些类型IPC的任何系统都提供两个特殊的程序：ipcs 和 ipcrm。ipcs 输出有关System V IPC特性的各种信息，ipcrm 则删除一个 System V 消息队列、信号量集或共享内存区。ipcs 支持约十来个命令行选项，它们决定报告哪种类型的 IPC 以及输出哪些信息，ipcrm 支持6个命令行选项。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;System V IPC不是Posix中的内容，因此这两个命令也未被Posix.2标准化。不过它们是Unix98的内容。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;内核限制&quot;&gt;内核限制&lt;/h1&gt;

&lt;p&gt;System V IPC 的多数实现有内核限制，例如消息队列的最大数目、每个信号量集的最大信号量数，等等。&lt;/p&gt;

&lt;p&gt;我们将在图6-25、图11-8和图14-5中给出这些限制的某些典型值。&lt;/p&gt;

&lt;p&gt;这些限制通常起源于最初的 System V实现。&lt;/p&gt;

&lt;p&gt;不幸的是，这些对象的大小被内核限制得往往太小。因为其中许多限制起源于在某个小地址空间系统（16位PDP-11）上完成的最初实现。&lt;/p&gt;

&lt;p&gt;然而万幸的是，多数系统允许管理员 部分或完全 修改这些默认限制，但是不同风格的Unix 所需的步骤也不一样。多数系统要求在修改完值后重新自举运行中的内核。尽管如此，某些实现仍然给其中一些限制使用 16位整数，这在无形之中提供了一个难以突破的硬限制。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;
举例来说，Solaris 2.6有20个这些限制。&lt;/p&gt;

&lt;p&gt;它们的当前值可使用 sysdef命令 输出。不过，如果相应的内核模块尚未加载（也就是说尚未使用IPC机制），那么所输出的值为0。它们的值可通过在 /etc/system文件 中加入如下语句来修改，而 /etc/system文件 是自举内核时读入的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp2/UNP2_3/UNP2_8.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;等号左边名字中最后6个字符 是列在 图6-25、图11-8和图14-5中的变量名&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;至于Digital Unix 4.0B，sysconfig程序 可用于 查询或修改 许多内核参数和限制。下面是使用-q选项时该程序的输出，它在 ipc子系统 查询内核以输出当前限制值。我们已省略掉了与System V IPC机制无关的一些行。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp2/UNP2_3/UNP2_9.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这些参数的默认值可通过在 /etc/sysconfigtab文件 中，来指定不同的值来修改。不过，该文件应使用 sysconfigdb程序 维护。该文件是在系统自举时读入的。&lt;/p&gt;
</description>
        <pubDate>Sun, 04 Aug 2019 10:01:00 +0800</pubDate>
        <link>http://localhost:4000/unp/2019/08/04/Unp2-Chapter-3.html</link>
        <guid isPermaLink="true">http://localhost:4000/unp/2019/08/04/Unp2-Chapter-3.html</guid>
        
        
        <category>unp</category>
        
      </item>
    
      <item>
        <title>[Unp2]Chapter 2</title>
        <description>&lt;h1 id=&quot;概述&quot;&gt;概述&lt;/h1&gt;

&lt;p&gt;有三种类型的 IPC 合称为 “ Posix IPC ”：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Posix消息队列（第5章）；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Posix信号量（第10章）；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Posix共享内存区（第13章）。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Posix IPC在访问它们的函数和描述它们的信息上有一些类似点。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;图2-1汇总了所有Posix IPC函数。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp2/UNP2_2/UNP2_1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;ipc-名字&quot;&gt;IPC 名字&lt;/h1&gt;

&lt;p&gt;&lt;br /&gt;
&lt;img src=&quot;/images/Unp2/UNP2_1/UNP2_4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;在图1-4 中我们指出，三种类型的 Posix IPC 都使用 “Posix IPC名字” 进行标识。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;mq_open、sem_open 和 shm_open 这三个函数的第一个参数就是这样的一个名字，它可能是某个文件系统中的一个真正的路径名，也可能不是。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;
&lt;strong&gt;Posix.1是这么描述 Posix IPC 名字的。&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;它必须符合已有的路径名规则（必须最多由 PATH_MAX 个字节构成，包括结尾的空字节）。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果它以斜杠符开头，那么对这些函数的不同调用将访问同一个队列。如果它不以斜杠符开头，那么效果取决于实现。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;名字中额外的斜杠符的解释由实现定义。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为便于移植起见，Posix IPC 名字必须以一个斜杠符打头，并且不能再含有任何其他斜杠符。遗憾的是这些规则还不够，仍会出现移植性问题&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;
&lt;strong&gt;当我们指定一个只有单个斜杠符（作为首字符）的名字时，移植性问题就发生了：&lt;/strong&gt;
我们必须在根目录中具有写权限。&lt;/p&gt;

&lt;p&gt;为避免这些移植性问题，我们应该把 Posix IPC 名字的 #define 行放在一个便于修改的头文件中，这样应用程序转移到另一个系统上时，只需修改这个头文件。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;这是一个标准试图变得相当通用（本例子中，实时标准试图允许消息队列、信号量和共享内存区都在现有的Unix内核中实现，而且在独立的无盘系统上也能工作），结果标准的具体实现却变得不可移植的个例之一。在Posix中，这种现象称为“造成不标准的标准方式” （astandard way of being nonstandard）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;Posix.1 定义了三个宏：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;S_TYPEISMQ (buf)&lt;/p&gt;

&lt;p&gt;S_TYPEISSEM (buf)&lt;/p&gt;

&lt;p&gt;S_TYPEISSHM (buf)&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
它们的单个参数是指向某个 stat 结构的指针，其内容由 fstat、lstat 或 stat 这三个函数填入。&lt;/p&gt;

&lt;p&gt;如果所指定的 IPC 对象（消息队列、信号量或共享内存区对象）是作为一种独特的文件类型实现的，而且参数所指向的 stat 结构访问这样的文件类型，那么这三个宏计算出一个非零值。否则，计算出的值为0。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;不幸的是，这三个宏没有多大用处，因为无法保证这三种类型的IPC使用一种独特的文件类型实现。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;创建与打开-ipc-通道&quot;&gt;创建与打开 IPC 通道&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;mq_open、sem_open 和 shm_open 这三个创建或打开一个 IPC 对象的函数，它们的名为 oflag 的第二个参数指定怎样打开所请求的对象。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这与标准 open 函数的第二个参数类似。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;图2-3 给出了可组合构成该参数的各种常值&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;前3行指定怎样打开对象：只读、只写或读写。消息队列能以其中任何一种模式打开，信号量的打开不指定任何模式（任意信号量操作，都需要读写访问权），共享内存区对象则不能以只写模式打开。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp2/UNP2_2/UNP2_2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;图2-3中余下4行标志是可选的。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;O_CREAT&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;若不存在则创建由函数第一个参数所指定名字的消息队列、信号量或共享内存区对象（同时检查 O_EXCL 标志，我们不久将要说明）。&lt;/p&gt;

&lt;p&gt;创建一个新的消息队列、信号量或共享内存区对象时，至少需要另外一个称为 mode 的参数。该参数指定权限位，它是由图2-4中所示常值按位或形成的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp2/UNP2_2/UNP2_3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;这些常值定义在 &amp;lt;sys/stat.h&amp;gt; 头文件中。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;所指定的权限位受当前进程的文件模式创建掩码（file mode creation mask）修正，而该掩码可通过调用 umask 函数（APUE第83~85页）或使用shell的umask命令来设置。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;
&lt;strong&gt;跟新创建的文件一样，当创建一个新的消息队列、信号量或共享内存区对象时，其用户ID 被置为当前进程的有效用户ID。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;信号量 或 共享内存区对象的组ID 被置为当前进程的有效组ID （或某个系统默认组ID）。新消息队列对象的组ID则被置为当前进程的有效组ID（APUE第77~78页②详细讨论了 用户ID 和 组ID。）&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;O_EXCL&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果该标志和 O_CREAT 一起指定，那么 IPC 函数只在所指定名字的消息队列、信号量或共享内存区对象不存在时才创建新的对象。&lt;/p&gt;

&lt;p&gt;如果该对象已经存在，而且指定了  O_CREAT 、 O_EXCL  ，那么返回一个 EEXIST 错误。&lt;/p&gt;

&lt;p&gt;考虑到其他进程的存在，检查（所指定名字的消息队列）、（信号量）或（共享内存区
对象的是否存在）和 创建它（如果它不存在），这两步必须是原子的（atomic）。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;O_NONBLOCK&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;该标志使得一个消息队列在队列为空时的读或队列填满时的写不被阻塞。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;O_TRUNC&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果以读写模式打开了一个已存在的共享内存区对象，那么该标志将使得该对象的长度被截成0。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;
&lt;strong&gt;图2-5展示了打开一个IPC对象的真正逻辑流程。我们将在2.4节通过访问权限的测试说明该
图。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;图2-6是展示图2-5中逻辑的另一种形式。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp2/UNP2_2/UNP2_4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;
图2-6 指定了 O_CREAT 标志，但是没有指定 O_EXCL 标志的中间那行，因此我们无法得到一个指示以判别是创建了一个新对象，还是在引用一个已存在的对象。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;ipc-权限&quot;&gt;IPC 权限&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;新的消息队列、有名信号量或共享内存区对象是由其 oflag 参数中含有 O_CREAT 标志的 mq_open 、sem_open 或 shm_open 函数创建的。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如图2-4所示，权限位与这些 IPC 类型的每个对象相关联，就像它们与每个 Unix 文件相关联一样。&lt;/p&gt;

&lt;p&gt;(1) 创建时赋予该IPC对象的权限位；&lt;/p&gt;

&lt;p&gt;(2) 所请求的访问类型（O_RDONLY、O_WRONLY或O_RDWR）；&lt;/p&gt;

&lt;p&gt;(3) 调用进程的有效用户ID、有效组ID以及各个辅助组ID（若支持的话）。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;
&lt;strong&gt;大多数Unix内核，按如下步骤执行权限测试。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;(1) 如果当前进程的有效用户ID为0（超级用户），那就允许访问。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
(2) 在当前进程的 有效用户ID 等于该 IPC对象 的 属主ID 的前提下，如果相应的用户访问权限位已设置，那就允许访问，否则拒绝访问。&lt;/p&gt;

&lt;p&gt;这里相应的访问权限位的意思是：如果当前进程为读访问而打开该 IPC对象，那么用户读权限位必须设置；如果当前进程为写访问而打开该IPC对象，那么用户写权限位必须设置。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
(3) 在当前进程的 有效组ID 或它的某个 辅助组ID 等于该 IPC对象 的 组ID 的前提下，如果相应的组访问权限位已设置，那就允许访问，否则拒绝访问。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
(4) 如果相应的其他用户访问权限位已设置，那就允许访问，否则拒绝访问。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
这4个步骤是按所列的顺序尝试的。&lt;/p&gt;

&lt;p&gt;因此，如果当前进程拥有该 IPC对象（第2步），那么访问权的授予与拒绝只依赖于用户访问权限——组访问权限绝不会考虑。&lt;/p&gt;

&lt;p&gt;类似地，如果当前进程不拥有该 IPC对象，但它属于某个合适的组，那么访问权的授予 与 拒绝只依赖于组访问权限——其他用户访问权限绝不会考虑。&lt;/p&gt;

</description>
        <pubDate>Fri, 02 Aug 2019 10:01:00 +0800</pubDate>
        <link>http://localhost:4000/unp/2019/08/02/Unp2-Chapter-2.html</link>
        <guid isPermaLink="true">http://localhost:4000/unp/2019/08/02/Unp2-Chapter-2.html</guid>
        
        
        <category>unp</category>
        
      </item>
    
      <item>
        <title>[Unp2]Chapter 1</title>
        <description>&lt;h1 id=&quot;概述&quot;&gt;概述&lt;/h1&gt;

&lt;p&gt;IPC 是进程间通信（interprocess communication）的简称。传统上该术语描述的是运行在某个操作系统之上的不同进程间各种消息传递（message passing）的方式。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;在Unix操作系统过去30年的演变史中，消息传递历经了如下几个发展阶段：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;管道（pipe，第4章）是第一个广泛使用的IPC形式，既可在程序中使用，也可从 shell 中使用。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;System V 消息队列（System V message queue，第6章）是在20世纪80年代早期加到System V 内核中的。它们可用在同一主机上有亲缘关系或无亲缘关系的进程之间。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Posix消息队列（Posix消息队列，第5章）是由Posix实时标准（1003.1b-1993）加入的。它们可用在同一主机上有亲缘关系和无亲缘关系的进程之间。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;远程过程调用（Remote Procedure Call，RPC，第五部分）出现在20世纪80年代中期，它是从一个系统（客户主机）上某个程序调用另一个系统（服务器主机）上某个函数的一种方法，是作为显式网络编程的一种替换方法开发的。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;看一看由 Unix 提供的各种同步形式的演变同样颇有教益：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;需要某种同步形式（往往是为了防止多个进程同时修改同一文件）的早期程序使用了文件系统的诡秘特性&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;记录上锁（record locking，第9章）是在20世纪80年代早期加到 Unix 内核中的，然后在1988 年由Posix.1标准化的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;System V 信号量（System V semaphore，第11章）是在System V消息队列加入 System V 内核的同时（20世纪80年代早期）伴随System V共享内存区（System V shared memory）加入的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Posix 信号量（Posix semaphore，第10章）和 Posix 共享内存区（Posix shared memory，第13章）也由Posix实时标准（1003.1b-1993）加入。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;互斥锁（mutex）和 条件变量（condition variable，第7章）是由 Posix 线程标准（1003.1c-1995）定义的两种同步形式。尽管往往用于线程间的同步，它们也能提供不同进程间的同步。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;读写锁（read-write lock，第8章）是另一种形式的同步。它们还没有被 Posix 标准化，不过也许不久后会被标准化。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;进程线程与信息共享&quot;&gt;进程、线程与信息共享&lt;/h1&gt;

&lt;p&gt;按照传统的 Unix 编程模型，我们在一个系统上运行多个进程，每个进程都有各自的地址空
间。Unix进程间的信息共享可以有多种方式。图1-1对此作了总结。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp2/UNP2_1/UNP2_1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;(1) 左边的两个进程共享存留于文件系统中某个文件上的某些信息。&lt;/p&gt;

&lt;p&gt;为访问这些信息，每个进程都得穿越内核（例如 read、write、lseek 等）。&lt;/p&gt;

&lt;p&gt;当一个文件有待更新时，某种形式的同步是必要的，这样既可保护多个写入者，防止相互串扰，也可保护一个或多个读出者，防止写入者的干扰。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
(2) 中间的两个进程共享驻留于内核中的某些信息。&lt;/p&gt;

&lt;p&gt;管道是这种共享类型的一个例子，System V 消息队列和 System V信号量也是。&lt;/p&gt;

&lt;p&gt;访问共享信息的每次操作都涉及对内核的一次系统调用。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
(3) 右边的两个进程有一个双方都能访问的共享内存区。每个进程一旦设置好该共享内存区，就能根本不涉及内核而访问其中的数据。共享该内存区的进程需要某种形式的同步。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;没有任何东西限制任何IPC技术只能使用两个进程。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;ipc-对象的持续性&quot;&gt;IPC 对象的持续性&lt;/h1&gt;

&lt;p&gt;我们可以把任意类型的IPC的持续性（persistence）定义成该类型的一个对象一直存在多长
时间。图1-2展示了三种类型的持续性。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp2/UNP2_1/UNP2_2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;(1) 随进程持续的（process-persistent）IPC对象&lt;/p&gt;

&lt;p&gt;它一直存在到打开着该对象的最后一个进程关闭该对象为止。例如管道和FIFO就是这种对象。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
(2) 随内核持续的（kernel-persistent）IPC对象&lt;/p&gt;

&lt;p&gt;它一直存在到内核重新自举或显式删除该对象为止。例如System V的消息队列、信号量和共享内存区就是此类对象。&lt;/p&gt;

&lt;p&gt;Posix的消息队列、信号量和共享内存区必须至少是随内核持续的，但也可以是随文件系统持续的，具体取决于实现。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
(3) 随文件系统持续的（filesystem-persistent）IPC对象&lt;/p&gt;

&lt;p&gt;它一直存在到显式删除该对象为止。即使内核重新自举了，该对象还是保持其值。&lt;/p&gt;

&lt;p&gt;Posix 消息队列、信号量和共享内存区如果是使用映射文件实现的（不是必需条件），那么它们就是随文件系统持续的。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;
在定义一个 IPC 对象的持续性时我们必须小心，因为它并不总是像看起来的那样。&lt;/p&gt;

&lt;p&gt;例如，管道内的数据是在内核中维护的，但是，管道具备的是随进程的持续性，而不是随内核的持续性：最后一个将某个管道打开着，用于读的进程关闭该管道后，内核将丢弃所有的数据并删除该管道。&lt;/p&gt;

&lt;p&gt;图1-3 汇总了将在本书中讲述的各种类型IPC对象的持续性。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp2/UNP2_1/UNP2_3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;该列表中没有任何类型的IPC具备随文件系统的持续性，但是我们说过有三种类型的 Posix IPC 可能会具备该持续性，这取决于它们的实现。&lt;/p&gt;

&lt;p&gt;显然，向一个文件写入数据提供了随文件系统的持续性，但这通常不作为一种 IPC 形式使用。多数形式的 IPC 并没有在系统重新自举后继续存在的打算，因为进程不可能跨越重新自举继续存活。&lt;/p&gt;

&lt;p&gt;对于一种给定形式的IPC，要求它具备随文件系统的持续性可能会使其性能降级，而IPC的一个基本的设计目标是高性能&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;名字空间&quot;&gt;名字空间&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;当两个或多个无亲缘关系的进程使用某种类型的 IPC 对象来彼此交换信息时，该 IPC 对象必须有一个某种形式的名字（name）或标识符（identifier）。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这样其中一个进程（往往是服务器）可以创建该IPC对象，其余进程则可以指定同一个IPC对象。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;
&lt;strong&gt;在以后各章具体讲述其他形式的 IPC 时，我们将使用另外的命名约定。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;对于一种给定的IPC类型，其可能的名字的集合称为它的名字空间（name space）。&lt;/p&gt;

&lt;p&gt;名字空间非常重要，因为对于除普通管道以外的所有形式的IPC来说，名字是客户与服务器彼此连接以交换消息的手段。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
图1-4汇总了不同形式的 IPC 所用的命名约定。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp2/UNP2_1/UNP2_4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;
&lt;strong&gt;尽管 Posix.1 标准化了信号量，它们仍然是可选的特性。图1-5 汇总了 Posix.1 和 Unix 98 对各
种 IPC 特性的说明。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;每种特性有强制、未定义和可选三种选择。对于可选的特性，我们指出了其中每种特性受支持时（通常在 &lt;unistd.h&gt; 头文件中）定义的常值的名字，例如 _ POSIX_THREADS。&lt;/unistd.h&gt;&lt;/p&gt;

&lt;p&gt;注意，Unix 98 是 Posix.1 的超集。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp2/UNP2_1/UNP2_5.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;forkexec-和-exit-对-ipc-对象的影响&quot;&gt;fork、exec 和 exit 对 IPC 对象的影响&lt;/h1&gt;

&lt;p&gt;我们需要理解 fork、exec和 _ exit 函数对于所讨论的各种形式的 IPC 的影响（ _ exit 是由 exit 调用的一个函数）。图1-6对此作了总结。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp2/UNP2_1/UNP2_6.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;我们需要强调几点。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;首先&lt;/strong&gt;，考虑到无名同步变量（互斥锁、条件变量、读写锁、基于内存的信号量），从一个具有多个线程的进程中调用 fork 将变得混乱不堪。［Butenhof 1997］的6.1节提供了其中的细节。&lt;/p&gt;

&lt;p&gt;我们在表中只是简单地注明：
如果这些变量驻留在共享内存区中，而且创建时设置了进程间共享属性，那么对于能访问该共
享内存区的任意进程来说，其任意线程能继续访问这些变量。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;其次&lt;/strong&gt;，System V IPC 的三种形式没有打开或关闭的说法。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;unp2-中-ipc-例子索引表&quot;&gt;UNP2 中 IPC 例子索引表&lt;/h1&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;为分析各种特性，全书主要使用了三种交互模式。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(1) 文件服务器：&lt;/strong&gt;客户-服务器应用程序，客户向服务器发送一个路径名，服务器把该文件
的内容返回给客户。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;((2) 生产者-消费者：&lt;/strong&gt;一个或多个线程或进程（生产者）把数据放到一个共享缓冲区中，另
有一个或多个线程或进程（消费者）对该共享缓冲区中的数据进行操作。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(3) 序列号持续增1：&lt;/strong&gt;一个或多个线程或进程给一个共享的序列号持续增1。该序列号有时在
一个共享文件中，有时在共享内存区中。&lt;/p&gt;

&lt;p&gt;第一个例子分析各种形式的消息传递，另外两个例子则分析各种类型的同步和共享内存区。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;
&lt;strong&gt;为了提供本书所涵盖的不同主题的索引，图1-9、图1-10和图1-11汇总了我们开发的程序及
它们的源代码所在的起始图号和页码&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp2/UNP2_1/UNP2_7.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp2/UNP2_1/UNP2_8.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp2/UNP2_1/UNP2_9.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Fri, 02 Aug 2019 10:00:00 +0800</pubDate>
        <link>http://localhost:4000/unp/2019/08/02/Unp2-Chapter-1.html</link>
        <guid isPermaLink="true">http://localhost:4000/unp/2019/08/02/Unp2-Chapter-1.html</guid>
        
        
        <category>unp</category>
        
      </item>
    
      <item>
        <title>[Unp]Chapter 26</title>
        <description>&lt;h1 id=&quot;概述&quot;&gt;概述&lt;/h1&gt;

&lt;p&gt;父进程 accept 一个连接，fork 一个子进程，该子进程处理与该连接的客户之间的通信。尽管这种范式多少年来一直用得挺好。但是，fork 调用却存在一些问题：&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
（1）fork 是昂贵的。如今实现使用 写时复制（copy-on-write）的技术。在子进程切实需要自己的副本之前，它避免了把父进程的数据空间复制到子进程。然而即便有这样的优化措施， fork 仍然是昂贵的。&lt;/p&gt;

&lt;p&gt;（2）fork 返回之后，父子进程之间信息的传递需要进程间通信（IPC）机制。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;线程有助于解决这两个问题。线程有时称为 轻权进程（lightweight process），因为线程比进程 “权重轻些”，速度比进程的创建快10～100倍。&lt;/p&gt;

&lt;p&gt;不过，在同一进程内，所有线程共享相同的全局内存。这使得线程之间易于共享信息，然而这种简易性，它会产生同步（synchronization）问题。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;此外，同一进程内的所有线程除了共享全局变量外还共享：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;进程指令；&lt;/li&gt;
  &lt;li&gt;大多数数据；&lt;/li&gt;
  &lt;li&gt;打开的文件（即描述符）；&lt;/li&gt;
  &lt;li&gt;信号处理函数和信号处置；&lt;/li&gt;
  &lt;li&gt;当前工作目录；&lt;/li&gt;
  &lt;li&gt;用户ID和组ID。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;不过每个线程有各自的：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;线程ID；&lt;/li&gt;
  &lt;li&gt;寄存器集合，包括程序计数器和栈指针；&lt;/li&gt;
  &lt;li&gt;栈（用于存放局部变量和返回地址）；&lt;/li&gt;
  &lt;li&gt;errno；&lt;/li&gt;
  &lt;li&gt;信号掩码；&lt;/li&gt;
  &lt;li&gt;优先级。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;本文章讲解的是 POSIX 线程，也称为 Pthread。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;基本线程函数创建和终止&quot;&gt;基本线程函数：创建和终止&lt;/h1&gt;

&lt;p&gt;讲解5个基本线程函数。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;pthread_create 函数&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当一个程序由 exec 启动执行时，称为 初始线程（initial thread）或 主线程（main thread）的单个线程就创建了。其余线程则由 pthread_create 函数创建。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_26/UNP_1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一个进程内的每个线程都由一个线程 ID（thread ID）标识，其数据类型为 pthread_t （往往是unsigned int）。&lt;/strong&gt;如果新的线程成功创建，其 ID 就通过 tid 指针返回。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;每个线程都有许多属性（attribute）：&lt;/strong&gt;优先级、初始栈大小、是否应该成为一个守护线程等等。这可以在创建线程时，我们通过初始化一个取代默认设置的 pthread_attr_t 变量，把它用来指定这些属性。通常情况下，我们采纳默认设置，这时我们把 attr 参数指定为空指针。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;创建一个线程时，我们最后指定的参数是，由该线程执行的函数及其参数。&lt;/strong&gt;该线程通过调用这个函数开始执行，然后，显式地终止（通过调用pthread_exit），或者隐式地终止（通过让该函数返回）。&lt;/p&gt;

&lt;p&gt;该函数的地址由func参数指定，该函数的唯一调用参数是指针 arg。&lt;/p&gt;

&lt;p&gt;如果我们需要给该函数传递多个参数，我们就得把它们打包成一个结构，然后把这个结构的地址作为单个参数传递给这个起始函数.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意func和arg的声明。&lt;/strong&gt; func 所指函数作为参数，它接受一个通用指针(void * )，又作为返回值返回一个通用指针(void * )。这使得我们可以把一个指针传递给线程（指针指向我们期望的任何内容），又允许线程返回一个指针（指针同样指向我们期望的任何内容）。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;通常情况下，Pthread函数的返回值成功时为0，出错时为某个非0值。与套接字函数及大多数系统调用出错时返回-1&lt;/p&gt;

</description>
        <pubDate>Sun, 21 Jul 2019 10:00:00 +0800</pubDate>
        <link>http://localhost:4000/unp/2019/07/21/Unp-Chapter-26.html</link>
        <guid isPermaLink="true">http://localhost:4000/unp/2019/07/21/Unp-Chapter-26.html</guid>
        
        
        <category>unp</category>
        
      </item>
    
      <item>
        <title>[Unp]Chapter 25</title>
        <description>&lt;h1 id=&quot;概述&quot;&gt;概述&lt;/h1&gt;

&lt;p&gt;信号驱动式 I/O 是指：进程预先告知内核，使得当某个描述符上发生某事时，内核使用信号通知相关进程。&lt;/p&gt;

&lt;p&gt;它通常定义为，进程执行 I/O 系统调用（譬如读或写）告知内核启动某个 I/O 操作，内核启动 I/O 操作后立即返回到进程。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;套接字的信号驱动式-io&quot;&gt;套接字的信号驱动式 I/O&lt;/h1&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;针对一个套接字使用信号驱动式I/O（SIGIO），它需要进程执行以下3个步骤：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;（1）首先，建立 SIGIO 信号的信号处理函数。&lt;/p&gt;

&lt;p&gt;（2）其次，设置该套接字的属主，通常使用 fcntl 的 F_SETOWN 命令设置。&lt;/p&gt;

&lt;p&gt;（3）最后，开启该套接字的信号驱动式 I/O ，通常通过使用 fcntl 的 F_SETFL 命令打开 O_ASYNC 标志完成。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;确定哪些条件导致内核产生 SIGIO 信号（该信号是递交给套接字属主），这不是容易的事。这种判定取决于支撑协议。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;对于 UDP 套接字的 SIGIO 信号&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;在UDP上使用信号驱动式I/O是简单的。SIGIO信号在发生以下事件时，它会产生：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;数据报到达套接字；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;套接字上发生异步错误。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因此，当捕获某个 UDP 套接字的 SIGIO 信号时，我们调用 recvfrom 或者 读入到达的数据报，或者 获取发生的异步错误。UDP 套接字发生异步错误的前提是，UDP套接字已连接。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;对于 TCP 套接字的 SIGIO 信号&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;信号驱动式 I/O 对于 TCP 套接字近乎无用。问题在于，该信号产生得过于频繁。并且，它的出现没有告诉我们发生了什么事件。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;如 TCPv2 第439页所注，下列条件都可以导致 TCP 套接字产生 SIGIO 信号（假设该套接字的信号驱动式I/O已经开启）：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;监听套接字上某个连接请求已经完成；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;某个断连请求已经发起；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;某个断连请求已经完成；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;某个连接之半已经关闭；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;数据到达套接字；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;数据已经从套接字发送走（即输出缓冲区有空闲空间）；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;发生某个异步错误。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;我们只考虑对监听 TCP 套接字使用 SIGIO 。因为对于监听套接字产生 SIGIO 的唯一条件是：某个新连接的完成。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;信号驱动式 I/O 对于套接字的唯一现实用途是，基于 UDP 的 NTP 服务器程序。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;大多数UDP服务器都设计成 下图左侧 所示的方式。&lt;/p&gt;

&lt;p&gt;不过，NTP 服务器却采用 下图右侧 所示的技巧。当一个新的数据报到达时，SIGIO 处理函数读入该数据报，同时记录它的到达时刻，然后将它置于进程内的另一个队列中，以便主服务器循环移走并处理。&lt;/p&gt;

&lt;p&gt;尽管服务器代码变复杂了，却为到达数据报提供了精确的时间戳。对 NTP 服务器而言，重要的是，为每个收取的数据报记录精确的时间戳，因为该值将返送给客户，由客户用于计算到服务器的 RTT。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_25/UNP_1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;UNP 25.3后面的例子可以多去看看。&lt;/p&gt;

</description>
        <pubDate>Sat, 20 Jul 2019 07:00:00 +0800</pubDate>
        <link>http://localhost:4000/unp/2019/07/20/Unp-Chapter-25.html</link>
        <guid isPermaLink="true">http://localhost:4000/unp/2019/07/20/Unp-Chapter-25.html</guid>
        
        
        <category>unp</category>
        
      </item>
    
      <item>
        <title>[Unp]Chapter 24</title>
        <description>&lt;h1 id=&quot;概述&quot;&gt;概述&lt;/h1&gt;

&lt;p&gt;许多传输层有 带外数据 （out-of-band  data）的概念，也称它为 经加速数据（expedited data）。&lt;/p&gt;

&lt;p&gt;带外数据的想法是；在一个连接的某端发生了重要事情，该端希望迅速通告它对端。“迅速” 意味着这种通知会在排队等待发送的数据（等待的数据称“带内数据”）之前发送。&lt;/p&gt;

&lt;p&gt;因此，带外数据的一个特性是，它具有比普通数据更高的优先级。同时，带外数据会被映射到已有的连接当中。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;tcp-带外数据&quot;&gt;TCP 带外数据&lt;/h1&gt;

&lt;p&gt;TCP 没有真正意义上的带外数据。不过，可以通过紧急模式（urgent mode）来实现。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;从发送端的角度观察带外数据的发送&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;假设一个进程往一个 TCP 套接字的发送缓冲区中写入 N 字节数据，并且标记出来。如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_24/UNP_1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;接着，该进程以 MSG_OOB 标记调用 send 函数，它写出一个含有 ASCII 字符 a 的单字节第外数据：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_24/UNP_2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最后，TCP 把这个数据放置在套接字发送缓冲区的下一个可用位置。并且， 在 OOB 标志的下一个位置中，设置该连接的 TCP 紧急指针（urgent pointer）。如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_24/UNP_3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;TCP 紧急指针对应一个 TCP 序列号，它是最后一个数据字节对应的序列号加 1。其中的  “最后一个数据字节”  指的是，使用 MSG_OOB 标志写出的数据字节。（即，带外字节）&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;TCP 紧急模式的一个重要特性&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;TCP 首部指出发送端进入紧急模式，即，伴随紧急偏移的 URG 标志（携带紧急指针）已经设置。但是，紧急指针所指的实际数据字节，它不一定会伴随 URG 发送出去。&lt;/p&gt;

&lt;p&gt;即使因为接收端的套接字接收缓冲区已满，导致向其 TCP 发送端通告一个值为 0 的窗口，紧急通知照样发送出去，但是它不会伴随任何数据。&lt;/p&gt;

&lt;p&gt;由于这个特性，有很多应用程序使用 TCP 紧急模式。哪怕数据的流动会因为 TCP 的流量控制而停止，但是紧急通知却总是能发送到对端 TCP。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;关于 “紧急指针” 和 “紧急偏移”&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;上面特性提到在这两个术语，因此需要解释此含义。在 TCP 层次上，它们是不同的。TCP 首部的16位值称为 紧急指针 。它必须加上同一个首部中的序列号字段才能获得32位的紧急指针。&lt;/p&gt;

&lt;p&gt;在同一个首部中，只有称为 URG 标志的位已经设置的前提下，TCP 才会检查紧急偏移。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如果我们发送多字节的带外数据，情况会怎么样呢?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_24/UNP_4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在这个例子中，TCP 的紧急指针指向最后的字节紧后的位置，也就是说，最后的那个字节（字母c）被认为是带外字节。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;从接收端的角度观察带外数据的接收&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（1）当收到一个设置了 URG  标志的分节时，接收端 TCP 检查紧急指针，用来确定它是否指向新的带外数据。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;发送端 TCP 往往发送多个含有 URG 标志的分节，并且此分节也含有多个紧急指针指向的同一个数据字节。在这些分节中，只有第一个到达的会导致通知接收进程有新的带外数据到达。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（2）当有新的紧急指针到达时，接收进程被通知到。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;首先，内核给接收套接字的属主进程发送SIGURG信号。前提是，接收进程 或 其他进程 曾调用 fcntl 或 ioctl  为这个套接字建立了属主，而且该属主进程已经为这个信号建立了信号处理函数。&lt;/p&gt;

&lt;p&gt;其次，如果接收进程阻塞在 select 调用中，用以等待这个套接字描述符出现一个异常条件的话，select调用就返回。&lt;/p&gt;

&lt;p&gt;注意：只有一个OOB标记，如果新的 OOB 字节在旧的 OOB 字节被读取之前就到达，旧的 OOB 字节会被丢弃。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（3）当实际数据字节（字节由紧急指针指向）到达接收端 TCP 时，该数据字节既可能被拉出带外，也可能被留在带内，即在线（inline）留存。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h3 id=&quot;so_oobinline-套接字选项默认情况下是禁止的&quot;&gt;SO_OOBINLINE 套接字选项默认情况下是禁止的。&lt;/h3&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对于这样的接收端套接字，该数据字节并不放入套接字接收缓冲区，而是被放入该连接的一个独立的单字节带外缓冲区（TCPv2第986～988页）。&lt;/p&gt;

&lt;p&gt;接收进程从单字节缓冲区读入数据的唯一方法是：指定 MSG_OOB 标志调用 recv、recvfrom 或 recvmsg。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h3 id=&quot;如果接收进程开启了-so_oobinline-套接字选项&quot;&gt;如果接收进程开启了 SO_OOBINLINE 套接字选项。&lt;/h3&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;由TCP紧急指针指向的 实际数据字节 会被留在 套接字接收缓冲区中。&lt;/p&gt;

&lt;p&gt;这种情况下，接收进程不能指定 MSG_OOB 标志读入该数据字节。相反，接收进程通过检查该连接的带外标记（out-of-band mark），用以获悉何时访问到这个数据字节。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;接收进程会发生错误的各种情况：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（1）&lt;/strong&gt;如果接收进程请求读入带外数据（通过指定MSG_OOB标志），但是对端尚未发送任何带外数据，读入操作将返回EINVAL。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（2）&lt;/strong&gt;在接收进程 被告知 对端发送了一个带外字节（通过SIGURG或select手段）的前提下。&lt;/p&gt;

&lt;p&gt;如果接收进程试图读入该字节，但是，该字节尚未到达。那么读入操作将返回EWOULDBLOCK。&lt;/p&gt;

&lt;p&gt;接收进程此时能做的是，从套接字接收缓冲区读入数据（要是没有存放这些数据的空间，可能还得丢弃它们），以便在该缓冲区中腾出空间，继而允许对端TCP发送出那个带外字节。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（3）&lt;/strong&gt; 如果 接收进程 试图多次读入 同一个带外字节，读入操作将返回EINVAL。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（4）&lt;/strong&gt;如果 接收进程 已经开启了SO_OOBINLINE套接字选项，后来试图通过 指定 MSG_OOB 标志 读入带外数据，读入操作将返回EINVAL。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;sockatmark-函数&quot;&gt;sockatmark 函数&lt;/h1&gt;

&lt;p&gt;在从套接字读入期间，接收进程通过调用 sockatmark 函数确定是否处于带外标记。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_24/UNP_5.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;带外标记的四个特性综合前面提及的并加入新的特性&quot;&gt;带外标记的四个特性：（综合前面提及的，并加入新的特性）&lt;/h1&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（1）带外标记总是指向 紧随普通数据最后一个字节后面 的位置。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这意味着&lt;/p&gt;

&lt;p&gt;如果带外数据在线接收，并且下一个准备读入的字节，发送端是使用 MSG_OOB 标记发送它的话。那么，sockatmark 函数返回真。&lt;/p&gt;

&lt;p&gt;如果 SO_OOBINLINE 套接字选项没有开启，并且下一个准备读入的字节，它是紧跟在带外数据后面发送到这里的话。那么，sockatmark 函数返回真。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（2）读操作总是停在带外标记上（TCPv2第519～520页）。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这意味着&lt;/p&gt;

&lt;p&gt;假设在套接字接收缓冲区中有100个字节，不过在带外标记之前只有5个字节。如果进程执行一个请求100个字节的 read 调用，那么返回的是带外标记之前的5个字节。&lt;/p&gt;

&lt;p&gt;这种在带外标记上强制停止读操作的做法，它使得进程能够调用 sockatmark 来确定缓冲区指针是否处于带外标记。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（3）即使因为流量控制而停止发送数据了，TCP 仍然发送带外数据的通知（即它的紧急指针）。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（4）在带外数据到达之前，接收进程可能被通知，通知内容为发送进程已经发送了带外数据（使用 SIGURG 信号或通过 select ）。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果接收进程接着指定 MSG_OOB 调用 recv ，而带外数据却尚未到达，recv 将返回 EWOULDBLOCK 错误。&lt;/p&gt;

&lt;p&gt;在&lt;strong&gt;从接收端的角度观察带外数据的接收&lt;/strong&gt;中详细描述。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;关于心搏函数的设计&quot;&gt;关于心搏函数的设计&lt;/h1&gt;

&lt;p&gt;讲解一个简单的心搏函数。这个函数的功能是，它可以发现对端主机 或 到对端的通信路径的过早失效。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;在讲解这些函数之前，必须提出一些警告：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;（1）如果使用 TCP 的保持存活特性（ SO_KEEPALIVE 套接字选项）来提供这种功能，那么 TCP 得在连接已经闲置2小时之后，它才发送一个保持存活探测段。&lt;/p&gt;

&lt;p&gt;关于这种方法，接下来还有一个问题：如何把保持存活的参数改为一个小得多的值（往往是在秒钟的量级），以便更快地检测到失效。&lt;/p&gt;

&lt;p&gt;尽管缩短 TCP 的保持存活的参数在许多系统上确实可行（见TCPv1的附录E），但是，这些参数通常是按照内核，而不是按照每个套接字维护的。因此改动它们将影响所有开启该选项的套接字。另外，保持存活选项的用意绝不是这个目的（高频率地轮询）。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;（2）两个端系统之间短暂的连接性丢失并非总是坏事。&lt;/p&gt;

&lt;p&gt;TCP一开始就设计成能够对付临时断连，比如，源自Berkeley的TCP实现将重传8～10分钟才放弃某个连接。较新的IP路由协议（例如 OSPF ）能够发现链接的失效，并且有可能在短时间内（譬如在秒钟量级上）启用候选的路径。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;我们使用 TCP 紧急模式周期地轮询&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;客户每隔1秒钟向服务器发送一个带外字节。服务器收取该字节会导致它向客户发回一个带外字节。&lt;/p&gt;

&lt;p&gt;每端都需要知道对端是否不复存在 或者 不再可达。客户和服务器每1秒钟就递增它们的 cnt 变量一次，每收到一个带外字节，然后把该变量重置为0。如果该计数器达到5，那就认定连接失效，也就是说本进程已有5秒钟没有收到来自对端的带外字节。&lt;/p&gt;

&lt;p&gt;当有带外字节到达时，客户和服务器都使用 SIGURG 信号得以通知。&lt;/p&gt;

&lt;p&gt;详情参考 UNP24-14的代码。&lt;/p&gt;

</description>
        <pubDate>Fri, 19 Jul 2019 01:00:00 +0800</pubDate>
        <link>http://localhost:4000/unp/2019/07/19/Unp-Chapter-24.html</link>
        <guid isPermaLink="true">http://localhost:4000/unp/2019/07/19/Unp-Chapter-24.html</guid>
        
        
        <category>unp</category>
        
      </item>
    
      <item>
        <title>[Apue]Chapter 10 - c</title>
        <description>&lt;h1 id=&quot;信号集&quot;&gt;信号集&lt;/h1&gt;

&lt;p&gt;信号集（signal set）是一个能表示多个信号的数据类型。&lt;/p&gt;

&lt;p&gt;一般而言，不能用整型量中的一位代表一种信号，也就是说，不能用一个整型变量表示信号集&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;POSIX.1定义数据类型 sigset_t，它可以包含一个信号集，并且定义了下列 5个处理信号集的函数。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Apue/APUE_10/APUE_10_9.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;函数 sigemptyset 初始化由 set 指向的信号集，清除其中所有信号。&lt;/p&gt;

&lt;p&gt;函数 sigfillset 初始化由 set 指向的信号集，使其包括所有信号。&lt;/p&gt;

&lt;p&gt;函数 sigaddset 将一个信号添加到已有的信号集中。&lt;/p&gt;

&lt;p&gt;函数 sigdelset 则从信号集中删除一个信号。&lt;/p&gt;

&lt;p&gt;函数 sigismember 判断给定的信号（signo 参数），是否时信号集中（set 参数）的一个成员。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（1）&lt;/strong&gt;所有应用程序在使用信号集前，要对该信号集调用 sigemptyset 或 sigfillset 一次。&lt;/p&gt;

&lt;p&gt;这是因为 C编译程序 把 不赋初值的外部变量和静态变量都初始化为0。一旦初始化了一个信号集，以后就可以在该信号集中操作（增、删）特定的信号。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（2）&lt;/strong&gt;所有以信号集作为参数的函数，信号集参数通常以指针的形式传递。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;函数-sigprocmask&quot;&gt;函数 sigprocmask&lt;/h1&gt;

&lt;p&gt;调用函数 sigprocmask 可以检测 或 更改，或 同时进行检测和更改进程的信号屏蔽字。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Apue/APUE_10/APUE_10_10.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;参数：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（1）&lt;/strong&gt;参数 oset&lt;/p&gt;

&lt;p&gt;如果它是非空指针，那么进程的当前信号屏蔽字通过 oset 返回。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（2）&lt;/strong&gt;参数 set&lt;/p&gt;

&lt;p&gt;a，如果 set 参数是一个非空指针，那么 how 参数表示如何修改当前信号屏蔽字。下图说明了 how 参数可选的值。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Apue/APUE_10/APUE_10_11.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;SIG_BLOCK 是或操作，而SIG_SETMASK 则是赋值操作。注意，不能阻塞 SIGKILL 和 SIGSTOP 信
号。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;b，如果 set 参数是一个空指针，那么不改变该进程的信号屏蔽字， how 参数的值也没有意义。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;在调用 sigprocmask 函数后，如果有任何（未决的、不再阻塞的）信号，那么在 sigprocmask 函数返回前，至少要把其中的一个信号发送给该进程。&lt;/p&gt;

&lt;p&gt;sigprocmask 函数 仅为单线程定义的。处理多线程进程中的信号屏蔽字，需要使用另一个函数。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;函数-sigpending&quot;&gt;函数 sigpending&lt;/h1&gt;

&lt;p&gt;sigpending 函数返回一个信号集，对于调用进程而言，其中的各个信号是阻塞的、不能传送的。因此，该信号当前是未决的。该信号集通过 set 参数返回。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Apue/APUE_10/APUE_10_12.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;函数-sigaction&quot;&gt;函数 sigaction&lt;/h1&gt;

&lt;p&gt;sigaction 函数的功能是：检查 或 修改 （或 检查并修改）与指定信号相关联的处理动作。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Apue/APUE_10/APUE_10_13.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;参数 signo 是要检测或修改其具体动作的信号编号。&lt;/p&gt;

&lt;p&gt;如果 act 指针参数非空，那么就要修改信号的动作。&lt;/p&gt;

&lt;p&gt;如果 oact 指针参数非空，那么系统经由 oact 指针返回该信号的上一个动作。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;参数 act 和 参数 oact 使用的结构内容，如下：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Apue/APUE_10/APUE_10_14.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Tue, 16 Jul 2019 00:59:32 +0800</pubDate>
        <link>http://localhost:4000/apue/2019/07/16/Apue-Chapter-10-c.html</link>
        <guid isPermaLink="true">http://localhost:4000/apue/2019/07/16/Apue-Chapter-10-c.html</guid>
        
        
        <category>apue</category>
        
      </item>
    
      <item>
        <title>[Apue]Chapter 10 - b</title>
        <description>&lt;h1 id=&quot;函数-signal&quot;&gt;函数 signal&lt;/h1&gt;

&lt;p&gt;UNIX 系统信号机制最简单的接口是 signal 函数。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Apue/APUE_10/APUE_10_2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;signo 返回值是一个函数地址，该函数的参数是整型。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
signal 函数参数：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;signo 参数是信号名(SIGXXXX)。signo 是一个整型数。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;func 是函数指针。func 的值是常量 SIG_IGN、常量SIG_DFL ，或着是 当接收到这个信号后，要调用的函数的地址。
&lt;br /&gt;&lt;br /&gt;
如果制定SIG_IGN，则向内核表示忽略此信号（SIGKILL 和 SIGSTOP 不能被忽略）。
&lt;br /&gt;&lt;br /&gt;
如果制定SIG_DFL，则表示，接收到这个信号后的动作是系统默认动作。
&lt;br /&gt;&lt;br /&gt;
当func 参数是函数的地址时，那么在信号发生时，调用该函数。我们称这种处理为 ‘捕捉该信号”；称这个函数为 “信号处理函数” 或 ”信号捕捉函数“。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;不可靠的信号&quot;&gt;不可靠的信号&lt;/h1&gt;

&lt;p&gt;不可靠的信号是指，信号可能会丢失。一个信号发生了，但进程却可能一直不知道这一点。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;早期版本有一个问题：在进程每次接收到信号，然后进行处理时，将该信号动作重置为默认值。
例如：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Apue/APUE_10/APUE_10_3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;这段代码的一个问题是：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;从信号发生后，一直到信号处理程序调用 signal 函数，这中间有一个时间窗口。在此段时间中，可能会发生另一次中断信号。第二个信号会造成执行默认动作，而对中断信号的默认动作是终止该进程。这种类型的程序段在大多数情况下会正常工作，使得我们认为它们是正确无误的，而实际上却并非如此。&lt;/p&gt;

&lt;p&gt;我们可以对每种信号只捕捉一次，从而回避这一点。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;早期版本的另外一个问题：在进程不希望某种信号发生时，它不能关闭该信号。例如：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Apue/APUE_10/APUE_10_4.png&quot; alt=&quot;它捕捉一个信号，然后设置一个表示该信号已发生的标志&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;这段代码的含义：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;进程调用 pause 函数使自己休眠，直到捕捉到一个信号后苏醒。当捕捉到信号时，信号处理程序将标志 sig_int_flag 设置为非 0 值。从信号处理程序返回后，内核自动将该进程唤醒，它检测到该标志为非 0，然后执行它所需做的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;这段代码的问题是：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在检测sig_int_flag 之后、调用 pause 之前会产生一个时间窗口。如果在这段时间内发生信号，那么此进程在调用 pause 时，可能将永久休眠（假定此信号不会再次产生）。于是，这次发生的信号也就丢失了。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;中断的系统调用&quot;&gt;中断的系统调用&lt;/h1&gt;

&lt;p&gt;早期Unix 系统的一个特性是：如果进程在执行一个低速系统调用，在阻塞期间捕捉到一个信号，则该低速系统调用就被中断，不再继续执行。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;低速系统调用是可能会让进程永远阻塞的一类系统调用，包括：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;如果某些类型文件的数据不存在，则读操作可能会使调用者永远阻塞。这里的某些类型文件指，读管道、终端设备和网络设备。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果这些数据不能被相同的类型文件立即接受，那么写操作可能会使调用者永远阻塞。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在某种条件发生之前，打开某些类型文件，这可能会发生阻塞。比如，打开一个终端设备时，需要先等待与它连接的调制解调器的应答。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;pause 函数 和 wait 函数。按照pause 的定义，它使调用进程休眠，直到捕捉到一个信号苏醒。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;某些进程间通信函数。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;在这些低速系统调用中，有一个值得注意的例外：与磁盘 I/O 有关的系统调用。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;虽然读、写一个磁盘文件可能暂时阻塞调用者，但是除非发生硬件错误，I/O 操作总会很快返回，并且使调用者不再处于阻塞状态。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;为了帮助应用程序不必处理被中断的系统调用，4.2BSD 引进了（某些被中断系统调用的）自动重启动。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;引入自动重启动功能的一个理由是&lt;/strong&gt;：有时用户不知道使用的输入、输出设备是否是低速设备。如果在程序中捕捉信号，而且系统并不提供重启动功能， 则对每次读、写系统调用就要进行是否出错返回的测试；如果是被中断的，则再调用读、写系统调用&lt;/p&gt;

&lt;p&gt;自动重启动的系统调用有：ioctl、read、readv、write、writev、wait 和 waitpid。前5个函数只有对低速设备进行操作时，才会被信号中断。而wait 和 waitpid 在捕捉到信号时，总是被中断。&lt;/p&gt;

&lt;p&gt;因为这种自动重启动的处理方式也会带来问题，某些应用程序不希望这些函数被中断后重启动。因此，4.3BSD 允许进程基于每个信号禁用此功能。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;可重入函数&quot;&gt;可重入函数&lt;/h1&gt;

&lt;p&gt;不可重入的例子：&lt;/p&gt;

&lt;p&gt;进程捕捉到信号，对该信号进行处理时，进程正在执行的正常指令序列就会被临时中断（信号处理程序）。它会先执行该信号处理程序中的指令。如果进程正在malloc，从其堆中分配存储空间。而此时，进程捕捉到信号，从而先执行信号处理程序。因为进程调用了malloc，那么这种情况下会发生什么事情呢？&lt;/p&gt;

&lt;p&gt;这可能会对进程造成破坏。因为malloc 通常为它分配的存储空间维护一个链表，而插入信号处理程序时，进程可能正在更改此链表。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
又例如，若进程正在执行getpwnam这种将其结果存放在静态存储单元中的函数，其间插入执行信号处理程序，它又调用这样的函数，则返回给正常调用者的信息 可能会被 返回给信号处理程序的信息 覆盖。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;可重入的函数如下表：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Apue/APUE_10/APUE_10_5.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;大多数函数是不可重入的原因是：&lt;/p&gt;

&lt;p&gt;（a）它们使用静态数据结构。&lt;/p&gt;

&lt;p&gt;（b）它们调用 malloc 或 free。&lt;/p&gt;

&lt;p&gt;（c）它们是标准 I/O 函数。标准 I/O 库的很多实现都以不可重入的方式使用全剧数据结构。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;注意：&lt;/p&gt;

&lt;p&gt;（1）即使信号处理程序调用的是可重入函数，但是由于每个县城只有一个 errno 变量，因此信号处理程序会修改原先值。&lt;/p&gt;

&lt;p&gt;（2）可重入函数列表中没有 longjmp 和 siglongjmp 的原因是：因为主例程以非可重入方式正在更新一个数据结构时，它可能产生信号。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;sigcld-语义&quot;&gt;SIGCLD 语义&lt;/h1&gt;

&lt;p&gt;SIGCLD 和 SIGCHLD 这两个信号很容易混淆。&lt;/p&gt;

&lt;p&gt;SIGCLD 是 System V 的一个信号名，而SIGCHLD 是 BSD 的信号，它们两个的语音不相同。POSIX.1 采用 BSD 的SIGCHLD 信号。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;SIGCLD&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果用 signal 或 sigset 设置信号配置，则基于 SVR4 的系统继承了这一具有问题色彩的传统（即兼容性限制）。对于 SIGCLD 的早期处理方式是：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（1）&lt;/strong&gt;如果进程将该信号的配置设置为 SIG_IGN ，那么调用进程的子进程将不会产生僵死进程。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;这与 SIG_DFL 信号的默认动作 “忽略” 不同。&lt;/p&gt;

&lt;p&gt;子进程在终止时，将它的状态丢弃。如果调用进程继续调用一个 wait 函数，那么它将阻塞到所有子进程终止，最后该 wait 会返回-1，并将它 errno 设置为 ECHILD。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（2）&lt;/strong&gt;如果将 SIGCLD 的配置设置为捕捉，那么内核会立即检查是否有子进程准备好 被等待。如果是的话，那么调用 SIGCD 处理程序。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;SIGCHLD&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;POSIX.1 未说明在 SIGCHLD 被忽略时应产生的后果，所以这种行为是允许的。 Single UNIX Specification 的 XSI 扩展选项要求对于 SIGCHLD 支持这种行为。&lt;/p&gt;

&lt;p&gt;在 4.4BSD 中，如果 SIGCHLD 的配置设置为忽略， 那么总是产生僵死进程。如果要避免僵死进程，那么必须等待子进程。&lt;br /&gt;在 SVR4 中，如果调用 signal 或 sigset 将 SIGCHLD 的配置设置为忽略，那么决不会产生僵死进程。&lt;/p&gt;

&lt;p&gt;使用 sigaction 可设置 SA_NOCLDWAIT 标志（见图 10-6）以避免进程僵死。本书讨论的 4
种平台都支持这一点。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;可靠信号术语和语义&quot;&gt;可靠信号术语和语义&lt;/h1&gt;

&lt;p&gt;当造成信号的事件发生时，为进程产生一个信号 （或 向进程发送一个信号）。当一个信号产生时，内核通常在进程表中，以某种形式设置一个标志。&lt;/p&gt;

&lt;p&gt;当对信号采取了这种动作时，我们说，这是向进程&lt;strong&gt;递送&lt;/strong&gt;了一个信号。&lt;br /&gt;在信号产生（generation）和 递送（delivery）之间的时间间隔内，称信号是&lt;strong&gt;未决的&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;事件，它可以是硬件异常（如 除以0）、软件条件（如 alarm 定时期超时）、终端产生的信号 或 调用 kill 函数。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;进程可以选用 “阻塞信号递送”。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果进程&lt;strong&gt;产生&lt;/strong&gt;了一个阻塞信号，对该信号的动作是系统默认动作 或 捕捉该信号，那么此进程将该信号保持为&lt;strong&gt;未决状态&lt;/strong&gt;。这将会持续到此进程对该信号解除阻塞，或者 对此信号的动作更改为忽略。&lt;/p&gt;

&lt;p&gt;内核在&lt;strong&gt;发送&lt;/strong&gt;一个被阻塞的信号给进程时，才决定对信号的处理方式。因此，在信号发送到进程之前，仍可以改变对该信号的动作。进程可以调用 sigpending 函数来判断哪些信号是设置为阻塞，并且处于未决状态的。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;在进程解除对某个信号的阻塞之前，如果这个信号发生了多次，那么会发生什么呢？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;POSIX.1 允许系统发送该信号一次 或 多次。如果发送该信号多次，则称 这些信号进行了排队。但是，除了支持 POSIX.1 实时扩展的系统，否则大多数 UNIX 并不对信号排队，而是只递送这种信号一次。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如果有多个信号要发送给一个进程，那么会发生什么呢？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;POSIX.1 并没有规定这些信号的发送顺序。但是 POSIX.1 基础部分建议：在其他信号之前，发送与进程当前状态有关的信号，如 SIGSEGV。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;每个进程都有一个信号屏蔽字（signal mask），它规定了，当前要阻塞发送到该进程的信号集。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;对于每种可能会阻塞的信号，该屏蔽字中，都有一位与之对应。&lt;br /&gt;对于某种信号，如果它的对应位已设置，则它当前是被阻塞的。&lt;/p&gt;

&lt;p&gt;进程可以调用 sigprocmask 来检测和更改它当前信号屏蔽字。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;信号集&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;由于信号编号可能会超过一个整型所包含的二进制位数，因此，POSIX.1 定义了一个新数据类型 sigset_t。&lt;/p&gt;

&lt;p&gt;这个新数据类型可以容纳一个信号集，而信号屏蔽字就可以存放在信号集中。（此数据类型就是信号集的实现）&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;函数-kill-和-raise&quot;&gt;函数 kill 和 raise&lt;/h1&gt;

&lt;p&gt;kill 函数将信号发送给进程 （或 进程组）。raise 函数则允许进程向自身发送信号。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Apue/APUE_10/APUE_10_6.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;kill 的 pid 参数有以下 4 种不同的情况：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;pid &amp;gt; 0&lt;/strong&gt; &lt;br /&gt; 将该信号发送给进程ID为 pid参数 的进程。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;pid == 0&lt;/strong&gt; &lt;br /&gt; 将该信号发送给一些进程。这些进程与发送进程属于同一进程组，而且发送进程有权限向这些进程发送信号。&lt;br /&gt; &lt;br /&gt; 注意，这些进程不包括实现定义的系统进程集。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;pid &amp;lt; 0&lt;/strong&gt; &lt;br /&gt; 将该信号发送给一些进程。这些进程的进程组ID等于 pid 参数绝对值，而且发送进程有权限向这些进程发送信号。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;pid = -1&lt;/strong&gt; &lt;br /&gt; 将该信号发送给一些进程。这些进程是发送进程有权限向它们发送信号的。&lt;br /&gt; &lt;br /&gt; 注意，这些进程不包括系统进程集中的进程。（与 pid == 0 的注意事项一样。）&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;函数-alarm-和-pause&quot;&gt;函数 alarm 和 pause&lt;/h1&gt;

&lt;p&gt;使用alarm 函数可以设置一个定时器（闹钟时间），在将来的某个时刻，这个定时器会超时。当这个定时期超时时，内核产生 SIGALRM 信号。如果忽略 或 不捕捉此信号，那么它的默认动作时终止调用该alarm 函数的进程。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Apue/APUE_10/APUE_10_7.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;参数 seconds 的值是产生信号 SIGALRM 的条件，该条件是需要经过的时钟秒数。&lt;/p&gt;

&lt;p&gt;当这一时刻达到时，信号由内核产生。由于进程调度的延迟，所以还需要一个时间间隔才能让进程得到控制，使得进程能够处理该信号。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;每个进程只能有一个闹钟时间&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果在调用 alarm时，之前已经为该进程注册了闹钟时间，并且还没有超时。那么，该闹钟时间剩余的值将会作为本次调用 alarm 函数的返回值，并且，以前注册的闹钟时间被新值代替。&lt;/p&gt;

&lt;p&gt;如果以前注册的闹钟时间还没有超时，并且本次 alarm 函数的 seconds 参数为0。那么，取消以前的闹钟时间，之前剩余的值作为 alarm 函数的返回值。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;虽然，SIGALRM 的默认动作是终止进程，但是大多数使用闹钟的进程捕捉此信号。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当我们想捕捉 SIGALRM 信号时，必须在调用 alarm 函数之前，安装该信号的处理程序。&lt;/p&gt;

&lt;p&gt;如果我们先调用 alarm 函数，在安装 SIGALRM 处理程序之前，已经接收到 SIGALRM 信号。那么进程将终止。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;pause 函数&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;它会让调用进程挂起，直到捕捉到一个信号。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Apue/APUE_10/APUE_10_8.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;只有执行了一个信号处理程序，并且从此程序返回时，pause才返回。这种情况下，pause 返回 -1，errno 设置为 EINTR。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://waterwoodfountainhead.github.io/apue/2019/07/15/Apue-Chapter-10-c.html&quot;&gt;进入下一篇：《Chapter 10 - c》&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Tue, 16 Jul 2019 00:50:32 +0800</pubDate>
        <link>http://localhost:4000/apue/2019/07/16/Apue-Chapter-10-b.html</link>
        <guid isPermaLink="true">http://localhost:4000/apue/2019/07/16/Apue-Chapter-10-b.html</guid>
        
        
        <category>apue</category>
        
      </item>
    
      <item>
        <title>[Apue]Chapter 10 - a</title>
        <description>&lt;h1 id=&quot;信号概念&quot;&gt;信号概念&lt;/h1&gt;

&lt;p&gt;信号是软件中断。信号提供了一种处理异步事件的方法。&lt;/p&gt;

&lt;p&gt;每个信号都有一个名字。这些名字都以3个字符SIG开头。&lt;/p&gt;

&lt;p&gt;在头文件&lt;signal.h&gt;中，信号名都被定义为正整数常量（信号编号）。不存在编号为0的信号。不过，kill 函数对信号编号0有特殊应用。POSIX.1 将此种信号编号值称为空信号。&lt;/signal.h&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;有很多条件可以产生信号:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;当用户按下某些终端键时，使终端产生的信号。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;硬件异常产生信号：除数为0、无效的内存引用等。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;进程调用 kill(2) 函数，可以将任意信号发送给另一个进程(或 进程组)。&lt;br /&gt;&lt;br /&gt;&lt;strong&gt;不过，它是有限制的：&lt;/strong&gt;接受信号的进程和发送信号的进程，它们的所有者必须相同。或者，发送信号的进程的所有者是超级用户。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;用户可以用 kill(1) 命令将信号发送给其他进程。此命令只是 kill函数的接口。它常用于终止一个失控的后台进程。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当检测到某种软件条件已经发生，并将其通知有关进程时，也会产生信号。这里指的不是硬件产生条件(比如，除以0)，而是软件条件。例如：SIGURG——在网络连接上传来带外的数据时产生，等等。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;进程不能测试一个变量来判断是否发生了一个信号，而是告诉内核进行处理。&lt;strong&gt;在某个信号出现时，可以告诉内核按下列3种方式之一进行处理：&lt;/strong&gt;（称为信号的处理，或与信号相关的动作）&lt;/p&gt;

&lt;p&gt;（1）忽略此信号。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;有两种信号不能被忽略——SIGKILL 和 SIGSTOP。原因是，它们向内核和超级用户提供了让进程终止(或 停止) 的可靠方法。&lt;/p&gt;

&lt;p&gt;如果忽略某些硬件异常所产生的信号，进程的运行行为是为定义的。比如：非法内存引用 或 除以0。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;（2）捕捉信号。&lt;/p&gt;

&lt;p&gt;为了捕捉信号，要通知内核在某种信号发生时，调用一个用户函数。在用户函数中，可以执行用户自己对这种事件的处理。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;（3）执行系统默认动作。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;对大多数信号而言，它们的系统默认动是终止该进程。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;下图列出所有信号的名字，说明了那些系统支持此信号，还有说明了这些信号的系统默认动作。&lt;/p&gt;

&lt;p&gt;列表中的点号表示这个信号定义为基本 POSIX.1规范部分。“XSI” 表示该信号定义在XSI扩展部分。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Apue/APUE_10/APUE_10_1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图中，一部分信号的默认动作是“终止+core”，这会产生一个core文件。那么，如何避免产生core文件呢？&lt;/p&gt;

&lt;p&gt;（a）进程是设置用户ID的，而且当前用户并非程序文件的所有者。&lt;/p&gt;

&lt;p&gt;（b）进程是设置组ID的，并且当前用户并非该程序文件的所有者。&lt;/p&gt;

&lt;p&gt;（c）用户没有写当前工作目录的权限。&lt;/p&gt;

&lt;p&gt;（d）文件已存在，而且用户对该文件设有写权限。&lt;/p&gt;

&lt;p&gt;（e）文件太大。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;上图中，SIGBUS——硬件故障   是对应实现定义的硬件故障。APUE p272 - 276页（实际页数为p252 - 256页）将进一步详细说明一些信号。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://waterwoodfountainhead.github.io/apue/2019/07/15/Apue-Chapter-10-b.html&quot;&gt;进入下一篇：《Chapter 10 - b》&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 16 Jul 2019 00:38:32 +0800</pubDate>
        <link>http://localhost:4000/apue/2019/07/16/Apue-Chapter-10-a.html</link>
        <guid isPermaLink="true">http://localhost:4000/apue/2019/07/16/Apue-Chapter-10-a.html</guid>
        
        
        <category>apue</category>
        
      </item>
    
      <item>
        <title>[Unp]Chapter 5</title>
        <description>&lt;p&gt;#&lt;/p&gt;

&lt;p&gt;讲TIME_WAIT前，我们需要了解下&lt;a href=&quot;https://waterwoodfountainhead.github.io/unp/2019/06/26/Unp-Nouns.html&quot;&gt;迷途(Nouns第12条)&lt;/a&gt;和TCP连接终止的过程，如图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_2/UNP2.6.1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;TCP的终结需要4个分节：&lt;/p&gt;

&lt;p&gt;（1）客户端首先调用close，我们称该端执行主动关闭（active close）。该端的TCP于是发送一个FIN分节，表示数据发送完毕。&lt;/p&gt;

&lt;p&gt;（2）接收到这个FIN的对端执行被动关闭（passive close）。这个FIN由TCP确认。服务端接收FIN意味着服务端的应用进程在相应连接上再无额外数据可接收。&lt;/p&gt;

&lt;p&gt;（3）一段时间后，接收到这个文件结束符的应用进程将调用close关闭它的套接字。这导致它的TCP也发送一个FIN。&lt;/p&gt;

&lt;p&gt;（4）接收这个最终FIN的客户端的TCP（即执行主动关闭的那一端）确认这个FIN。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;time_wait状态&quot;&gt;TIME_WAIT状态&lt;/h1&gt;

&lt;p&gt;先介绍下TIME_WAIT状态：这个状态的持续时间是最长分节生命期（maximum segment lifetime，MSL）的两倍，有时候称之为2MSL。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;那么，TIME_WAIT状态有什么作用呢？&lt;/p&gt;

&lt;p&gt;(1) 可靠地实现TCP全双工连接的终止；&lt;/p&gt;

&lt;p&gt;假设最终的ACK丢失了来解释。服务器将重新发送它的最终那个FIN，因此客户必须维护状态信息，以允许它重新发送最终那个ACK。要是客户不维护状态信息，它将响应以一个RST（另外一种类型的TCP分节），该分节将被服务器解释成一个错误。如果TCP打算执行所有必要的工作以彻底终止某个连接上两个方向的数据流（即全双工关闭），那么它必须正确处理连接终止序列4个分节中任何一个分节丢失的情况。&lt;/p&gt;

&lt;p&gt;这也说明了执行主动关闭的那一端(客户端)由于要重传最后一个ACK，所以是处于TIME_WAIT状态。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;(2) 允许老的重复分节在网络中消逝。&lt;/p&gt;

&lt;p&gt;有时候一个连接可能会在关闭后，又在相同的ip地址和端口之间建立一个连接。因此TCP必须防止这个连接的老的重复分组在该连接已终止后再现，以免被误解成属于同一连接的某个新的化身。&lt;/p&gt;

&lt;p&gt;为此，TCP将不给处于TIME_WAIT状态的连接发起新的化身。既然TIME_WAIT状态的持续时间是MSL的2倍，这就足以让某个方向上的分组最多存活MSL秒即被丢弃，另一个方向上的应答最多存活MSL秒也被丢弃。通过实施这个规则，我们就能保证每成功建立一个TCP连接时，来自该连接先前化身的老的重复分组都已在网络中消逝了。&lt;/p&gt;
</description>
        <pubDate>Tue, 02 Jul 2019 10:00:00 +0800</pubDate>
        <link>http://localhost:4000/unp/2019/07/02/Unp-Chapter-5.html</link>
        <guid isPermaLink="true">http://localhost:4000/unp/2019/07/02/Unp-Chapter-5.html</guid>
        
        
        <category>unp</category>
        
      </item>
    
  </channel>
</rss>
