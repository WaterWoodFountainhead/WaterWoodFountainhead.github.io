<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Fountainhead</title>
    <description>Blog</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Fri, 02 Aug 2019 23:50:27 +0800</pubDate>
    <lastBuildDate>Fri, 02 Aug 2019 23:50:27 +0800</lastBuildDate>
    <generator>Jekyll v3.8.5</generator>
    
      <item>
        <title>[Unp2]Chapter 2</title>
        <description>&lt;h1 id=&quot;概述&quot;&gt;概述&lt;/h1&gt;

&lt;p&gt;有三种类型的 IPC 合称为 “ Posix IPC ”：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Posix消息队列（第5章）；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Posix信号量（第10章）；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Posix共享内存区（第13章）。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Posix IPC在访问它们的函数和描述它们的信息上有一些类似点。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;图2-1汇总了所有Posix IPC函数。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp2/UNP2_2/UNP2_1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;ipc-名字&quot;&gt;IPC 名字&lt;/h1&gt;

&lt;p&gt;&lt;br /&gt;
&lt;img src=&quot;/images/Unp2/UNP2_1/UNP2_4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;在图1-4 中我们指出，三种类型的 Posix IPC 都使用 “Posix IPC名字” 进行标识。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;mq_open、sem_open 和 shm_open 这三个函数的第一个参数就是这样的一个名字，它可能是某个文件系统中的一个真正的路径名，也可能不是。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;
&lt;strong&gt;Posix.1是这么描述 Posix IPC 名字的。&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;它必须符合已有的路径名规则（必须最多由 PATH_MAX 个字节构成，包括结尾的空字节）。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果它以斜杠符开头，那么对这些函数的不同调用将访问同一个队列。如果它不以斜杠符开头，那么效果取决于实现。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;名字中额外的斜杠符的解释由实现定义。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为便于移植起见，Posix IPC 名字必须以一个斜杠符打头，并且不能再含有任何其他斜杠符。遗憾的是这些规则还不够，仍会出现移植性问题&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;
&lt;strong&gt;当我们指定一个只有单个斜杠符（作为首字符）的名字时，移植性问题就发生了：&lt;/strong&gt;
我们必须在根目录中具有写权限。&lt;/p&gt;

&lt;p&gt;为避免这些移植性问题，我们应该把 Posix IPC 名字的 #define 行放在一个便于修改的头文件中，这样应用程序转移到另一个系统上时，只需修改这个头文件。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;这是一个标准试图变得相当通用（本例子中，实时标准试图允许消息队列、信号量和共享内存区都在现有的Unix内核中实现，而且在独立的无盘系统上也能工作），结果标准的具体实现却变得不可移植的个例之一。在Posix中，这种现象称为“造成不标准的标准方式” （astandard way of being nonstandard）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;Posix.1 定义了三个宏：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;S_TYPEISMQ (buf)&lt;/p&gt;

&lt;p&gt;S_TYPEISSEM (buf)&lt;/p&gt;

&lt;p&gt;S_TYPEISSHM (buf)&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
它们的单个参数是指向某个 stat 结构的指针，其内容由 fstat、lstat 或 stat 这三个函数填入。&lt;/p&gt;

&lt;p&gt;如果所指定的 IPC 对象（消息队列、信号量或共享内存区对象）是作为一种独特的文件类型实现的，而且参数所指向的 stat 结构访问这样的文件类型，那么这三个宏计算出一个非零值。否则，计算出的值为0。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;不幸的是，这三个宏没有多大用处，因为无法保证这三种类型的IPC使用一种独特的文件类型实现。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;创建与打开-ipc-通道&quot;&gt;创建与打开 IPC 通道&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;mq_open、sem_open 和 shm_open 这三个创建或打开一个 IPC 对象的函数，它们的名为 oflag 的第二个参数指定怎样打开所请求的对象。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这与标准 open 函数的第二个参数类似。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;图2-3 给出了可组合构成该参数的各种常值&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;前3行指定怎样打开对象：只读、只写或读写。消息队列能以其中任何一种模式打开，信号量的打开不指定任何模式（任意信号量操作，都需要读写访问权），共享内存区对象则不能以只写模式打开。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp2/UNP2_2/UNP2_2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;图2-3中余下4行标志是可选的。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;O_CREAT&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;若不存在则创建由函数第一个参数所指定名字的消息队列、信号量或共享内存区对象（同时检查 O_EXCL 标志，我们不久将要说明）。&lt;/p&gt;

&lt;p&gt;创建一个新的消息队列、信号量或共享内存区对象时，至少需要另外一个称为 mode 的参数。该参数指定权限位，它是由图2-4中所示常值按位或形成的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp2/UNP2_2/UNP2_3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;这些常值定义在 &amp;lt;sys/stat.h&amp;gt; 头文件中。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;所指定的权限位受当前进程的文件模式创建掩码（file mode creation mask）修正，而该掩码可通过调用 umask 函数（APUE第83~85页）或使用shell的umask命令来设置。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;
&lt;strong&gt;跟新创建的文件一样，当创建一个新的消息队列、信号量或共享内存区对象时，其用户ID 被置为当前进程的有效用户ID。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;信号量 或 共享内存区对象的组ID 被置为当前进程的有效组ID （或某个系统默认组ID）。新消息队列对象的组ID则被置为当前进程的有效组ID（APUE第77~78页②详细讨论了 用户ID 和 组ID。）&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;O_EXCL&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果该标志和 O_CREAT 一起指定，那么 IPC 函数只在所指定名字的消息队列、信号量或共享内存区对象不存在时才创建新的对象。&lt;/p&gt;

&lt;p&gt;如果该对象已经存在，而且指定了  O_CREAT 、 O_EXCL  ，那么返回一个 EEXIST 错误。&lt;/p&gt;

&lt;p&gt;考虑到其他进程的存在，检查（所指定名字的消息队列）、（信号量）或（共享内存区
对象的是否存在）和 创建它（如果它不存在），这两步必须是原子的（atomic）。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;O_NONBLOCK&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;该标志使得一个消息队列在队列为空时的读或队列填满时的写不被阻塞。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;O_TRUNC&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果以读写模式打开了一个已存在的共享内存区对象，那么该标志将使得该对象的长度被截成0。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;
&lt;strong&gt;图2-5展示了打开一个IPC对象的真正逻辑流程。我们将在2.4节通过访问权限的测试说明该
图。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;图2-6是展示图2-5中逻辑的另一种形式。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp2/UNP2_2/UNP2_4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;
图2-6 指定了 O_CREAT 标志，但是没有指定 O_EXCL 标志的中间那行，因此我们无法得到一个指示以判别是创建了一个新对象，还是在引用一个已存在的对象。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;ipc-权限&quot;&gt;IPC 权限&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;新的消息队列、有名信号量或共享内存区对象是由其 oflag 参数中含有 O_CREAT 标志的 mq_open 、sem_open 或 shm_open 函数创建的。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如图2-4所示，权限位与这些 IPC 类型的每个对象相关联，就像它们与每个 Unix 文件相关联一样。&lt;/p&gt;

&lt;p&gt;(1) 创建时赋予该IPC对象的权限位；&lt;/p&gt;

&lt;p&gt;(2) 所请求的访问类型（O_RDONLY、O_WRONLY或O_RDWR）；&lt;/p&gt;

&lt;p&gt;(3) 调用进程的有效用户ID、有效组ID以及各个辅助组ID（若支持的话）。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;
&lt;strong&gt;大多数Unix内核，按如下步骤执行权限测试。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;(1) 如果当前进程的有效用户ID为0（超级用户），那就允许访问。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
(2) 在当前进程的 有效用户ID 等于该 IPC对象 的 属主ID 的前提下，如果相应的用户访问权限位已设置，那就允许访问，否则拒绝访问。&lt;/p&gt;

&lt;p&gt;这里相应的访问权限位的意思是：如果当前进程为读访问而打开该 IPC对象，那么用户读权限位必须设置；如果当前进程为写访问而打开该IPC对象，那么用户写权限位必须设置。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
(3) 在当前进程的 有效组ID 或它的某个 辅助组ID 等于该 IPC对象 的 组ID 的前提下，如果相应的组访问权限位已设置，那就允许访问，否则拒绝访问。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
(4) 如果相应的其他用户访问权限位已设置，那就允许访问，否则拒绝访问。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
这4个步骤是按所列的顺序尝试的。&lt;/p&gt;

&lt;p&gt;因此，如果当前进程拥有该 IPC对象（第2步），那么访问权的授予与拒绝只依赖于用户访问权限——组访问权限绝不会考虑。&lt;/p&gt;

&lt;p&gt;类似地，如果当前进程不拥有该 IPC对象，但它属于某个合适的组，那么访问权的授予 与 拒绝只依赖于组访问权限——其他用户访问权限绝不会考虑。&lt;/p&gt;

</description>
        <pubDate>Fri, 02 Aug 2019 10:01:00 +0800</pubDate>
        <link>http://localhost:4000/unp/2019/08/02/Unp2-Chapter-2.html</link>
        <guid isPermaLink="true">http://localhost:4000/unp/2019/08/02/Unp2-Chapter-2.html</guid>
        
        
        <category>unp</category>
        
      </item>
    
      <item>
        <title>[Unp2]Chapter 1</title>
        <description>&lt;h1 id=&quot;概述&quot;&gt;概述&lt;/h1&gt;

&lt;p&gt;IPC 是进程间通信（interprocess communication）的简称。传统上该术语描述的是运行在某个操作系统之上的不同进程间各种消息传递（message passing）的方式。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;在Unix操作系统过去30年的演变史中，消息传递历经了如下几个发展阶段：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;管道（pipe，第4章）是第一个广泛使用的IPC形式，既可在程序中使用，也可从 shell 中使用。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;System V 消息队列（System V message queue，第6章）是在20世纪80年代早期加到System V 内核中的。它们可用在同一主机上有亲缘关系或无亲缘关系的进程之间。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Posix消息队列（Posix消息队列，第5章）是由Posix实时标准（1003.1b-1993）加入的。它们可用在同一主机上有亲缘关系和无亲缘关系的进程之间。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;远程过程调用（Remote Procedure Call，RPC，第五部分）出现在20世纪80年代中期，它是从一个系统（客户主机）上某个程序调用另一个系统（服务器主机）上某个函数的一种方法，是作为显式网络编程的一种替换方法开发的。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;看一看由 Unix 提供的各种同步形式的演变同样颇有教益：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;需要某种同步形式（往往是为了防止多个进程同时修改同一文件）的早期程序使用了文件系统的诡秘特性&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;记录上锁（record locking，第9章）是在20世纪80年代早期加到 Unix 内核中的，然后在1988 年由Posix.1标准化的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;System V 信号量（System V semaphore，第11章）是在System V消息队列加入 System V 内核的同时（20世纪80年代早期）伴随System V共享内存区（System V shared memory）加入的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Posix 信号量（Posix semaphore，第10章）和 Posix 共享内存区（Posix shared memory，第13章）也由Posix实时标准（1003.1b-1993）加入。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;互斥锁（mutex）和 条件变量（condition variable，第7章）是由 Posix 线程标准（1003.1c-1995）定义的两种同步形式。尽管往往用于线程间的同步，它们也能提供不同进程间的同步。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;读写锁（read-write lock，第8章）是另一种形式的同步。它们还没有被 Posix 标准化，不过也许不久后会被标准化。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;进程线程与信息共享&quot;&gt;进程、线程与信息共享&lt;/h1&gt;

&lt;p&gt;按照传统的 Unix 编程模型，我们在一个系统上运行多个进程，每个进程都有各自的地址空
间。Unix进程间的信息共享可以有多种方式。图1-1对此作了总结。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp2/UNP2_1/UNP2_1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;(1) 左边的两个进程共享存留于文件系统中某个文件上的某些信息。&lt;/p&gt;

&lt;p&gt;为访问这些信息，每个进程都得穿越内核（例如 read、write、lseek 等）。&lt;/p&gt;

&lt;p&gt;当一个文件有待更新时，某种形式的同步是必要的，这样既可保护多个写入者，防止相互串扰，也可保护一个或多个读出者，防止写入者的干扰。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
(2) 中间的两个进程共享驻留于内核中的某些信息。&lt;/p&gt;

&lt;p&gt;管道是这种共享类型的一个例子，System V 消息队列和 System V信号量也是。&lt;/p&gt;

&lt;p&gt;访问共享信息的每次操作都涉及对内核的一次系统调用。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
(3) 右边的两个进程有一个双方都能访问的共享内存区。每个进程一旦设置好该共享内存区，就能根本不涉及内核而访问其中的数据。共享该内存区的进程需要某种形式的同步。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;没有任何东西限制任何IPC技术只能使用两个进程。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;ipc-对象的持续性&quot;&gt;IPC 对象的持续性&lt;/h1&gt;

&lt;p&gt;我们可以把任意类型的IPC的持续性（persistence）定义成该类型的一个对象一直存在多长
时间。图1-2展示了三种类型的持续性。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp2/UNP2_1/UNP2_2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;(1) 随进程持续的（process-persistent）IPC对象&lt;/p&gt;

&lt;p&gt;它一直存在到打开着该对象的最后一个进程关闭该对象为止。例如管道和FIFO就是这种对象。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
(2) 随内核持续的（kernel-persistent）IPC对象&lt;/p&gt;

&lt;p&gt;它一直存在到内核重新自举或显式删除该对象为止。例如System V的消息队列、信号量和共享内存区就是此类对象。&lt;/p&gt;

&lt;p&gt;Posix的消息队列、信号量和共享内存区必须至少是随内核持续的，但也可以是随文件系统持续的，具体取决于实现。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
(3) 随文件系统持续的（filesystem-persistent）IPC对象&lt;/p&gt;

&lt;p&gt;它一直存在到显式删除该对象为止。即使内核重新自举了，该对象还是保持其值。&lt;/p&gt;

&lt;p&gt;Posix 消息队列、信号量和共享内存区如果是使用映射文件实现的（不是必需条件），那么它们就是随文件系统持续的。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;
在定义一个 IPC 对象的持续性时我们必须小心，因为它并不总是像看起来的那样。&lt;/p&gt;

&lt;p&gt;例如，管道内的数据是在内核中维护的，但是，管道具备的是随进程的持续性，而不是随内核的持续性：最后一个将某个管道打开着，用于读的进程关闭该管道后，内核将丢弃所有的数据并删除该管道。&lt;/p&gt;

&lt;p&gt;图1-3 汇总了将在本书中讲述的各种类型IPC对象的持续性。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp2/UNP2_1/UNP2_3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;该列表中没有任何类型的IPC具备随文件系统的持续性，但是我们说过有三种类型的 Posix IPC 可能会具备该持续性，这取决于它们的实现。&lt;/p&gt;

&lt;p&gt;显然，向一个文件写入数据提供了随文件系统的持续性，但这通常不作为一种 IPC 形式使用。多数形式的 IPC 并没有在系统重新自举后继续存在的打算，因为进程不可能跨越重新自举继续存活。&lt;/p&gt;

&lt;p&gt;对于一种给定形式的IPC，要求它具备随文件系统的持续性可能会使其性能降级，而IPC的一个基本的设计目标是高性能&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;名字空间&quot;&gt;名字空间&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;当两个或多个无亲缘关系的进程使用某种类型的 IPC 对象来彼此交换信息时，该 IPC 对象必须有一个某种形式的名字（name）或标识符（identifier）。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这样其中一个进程（往往是服务器）可以创建该IPC对象，其余进程则可以指定同一个IPC对象。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;
&lt;strong&gt;在以后各章具体讲述其他形式的 IPC 时，我们将使用另外的命名约定。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;对于一种给定的IPC类型，其可能的名字的集合称为它的名字空间（name space）。&lt;/p&gt;

&lt;p&gt;名字空间非常重要，因为对于除普通管道以外的所有形式的IPC来说，名字是客户与服务器彼此连接以交换消息的手段。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
图1-4汇总了不同形式的 IPC 所用的命名约定。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp2/UNP2_1/UNP2_4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;
&lt;strong&gt;尽管 Posix.1 标准化了信号量，它们仍然是可选的特性。图1-5 汇总了 Posix.1 和 Unix 98 对各
种 IPC 特性的说明。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;每种特性有强制、未定义和可选三种选择。对于可选的特性，我们指出了其中每种特性受支持时（通常在 &lt;unistd.h&gt; 头文件中）定义的常值的名字，例如 _ POSIX_THREADS。&lt;/unistd.h&gt;&lt;/p&gt;

&lt;p&gt;注意，Unix 98 是 Posix.1 的超集。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp2/UNP2_1/UNP2_5.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;forkexec-和-exit-对-ipc-对象的影响&quot;&gt;fork、exec 和 exit 对 IPC 对象的影响&lt;/h1&gt;

&lt;p&gt;我们需要理解 fork、exec和 _ exit 函数对于所讨论的各种形式的 IPC 的影响（ _ exit 是由 exit 调用的一个函数）。图1-6对此作了总结。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp2/UNP2_1/UNP2_6.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;我们需要强调几点。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;首先&lt;/strong&gt;，考虑到无名同步变量（互斥锁、条件变量、读写锁、基于内存的信号量），从一个具有多个线程的进程中调用 fork 将变得混乱不堪。［Butenhof 1997］的6.1节提供了其中的细节。&lt;/p&gt;

&lt;p&gt;我们在表中只是简单地注明：
如果这些变量驻留在共享内存区中，而且创建时设置了进程间共享属性，那么对于能访问该共
享内存区的任意进程来说，其任意线程能继续访问这些变量。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;其次&lt;/strong&gt;，System V IPC 的三种形式没有打开或关闭的说法。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h1 id=&quot;unp2-中-ipc-例子索引表&quot;&gt;UNP2 中 IPC 例子索引表&lt;/h1&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;为分析各种特性，全书主要使用了三种交互模式。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(1) 文件服务器：&lt;/strong&gt;客户-服务器应用程序，客户向服务器发送一个路径名，服务器把该文件
的内容返回给客户。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;((2) 生产者-消费者：&lt;/strong&gt;一个或多个线程或进程（生产者）把数据放到一个共享缓冲区中，另
有一个或多个线程或进程（消费者）对该共享缓冲区中的数据进行操作。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(3) 序列号持续增1：&lt;/strong&gt;一个或多个线程或进程给一个共享的序列号持续增1。该序列号有时在
一个共享文件中，有时在共享内存区中。&lt;/p&gt;

&lt;p&gt;第一个例子分析各种形式的消息传递，另外两个例子则分析各种类型的同步和共享内存区。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;
&lt;strong&gt;为了提供本书所涵盖的不同主题的索引，图1-9、图1-10和图1-11汇总了我们开发的程序及
它们的源代码所在的起始图号和页码&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp2/UNP2_1/UNP2_7.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp2/UNP2_1/UNP2_8.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp2/UNP2_1/UNP2_9.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Fri, 02 Aug 2019 10:00:00 +0800</pubDate>
        <link>http://localhost:4000/unp/2019/08/02/Unp2-Chapter-1.html</link>
        <guid isPermaLink="true">http://localhost:4000/unp/2019/08/02/Unp2-Chapter-1.html</guid>
        
        
        <category>unp</category>
        
      </item>
    
      <item>
        <title>[Unp]Chapter 26</title>
        <description>&lt;h1 id=&quot;概述&quot;&gt;概述&lt;/h1&gt;

&lt;p&gt;父进程 accept 一个连接，fork 一个子进程，该子进程处理与该连接的客户之间的通信。尽管这种范式多少年来一直用得挺好。但是，fork 调用却存在一些问题：&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
（1）fork 是昂贵的。如今实现使用 写时复制（copy-on-write）的技术。在子进程切实需要自己的副本之前，它避免了把父进程的数据空间复制到子进程。然而即便有这样的优化措施， fork 仍然是昂贵的。&lt;/p&gt;

&lt;p&gt;（2）fork 返回之后，父子进程之间信息的传递需要进程间通信（IPC）机制。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;线程有助于解决这两个问题。线程有时称为 轻权进程（lightweight process），因为线程比进程 “权重轻些”，速度比进程的创建快10～100倍。&lt;/p&gt;

&lt;p&gt;不过，在同一进程内，所有线程共享相同的全局内存。这使得线程之间易于共享信息，然而这种简易性，它会产生同步（synchronization）问题。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;此外，同一进程内的所有线程除了共享全局变量外还共享：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;进程指令；&lt;/li&gt;
  &lt;li&gt;大多数数据；&lt;/li&gt;
  &lt;li&gt;打开的文件（即描述符）；&lt;/li&gt;
  &lt;li&gt;信号处理函数和信号处置；&lt;/li&gt;
  &lt;li&gt;当前工作目录；&lt;/li&gt;
  &lt;li&gt;用户ID和组ID。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;不过每个线程有各自的：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;线程ID；&lt;/li&gt;
  &lt;li&gt;寄存器集合，包括程序计数器和栈指针；&lt;/li&gt;
  &lt;li&gt;栈（用于存放局部变量和返回地址）；&lt;/li&gt;
  &lt;li&gt;errno；&lt;/li&gt;
  &lt;li&gt;信号掩码；&lt;/li&gt;
  &lt;li&gt;优先级。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;本文章讲解的是 POSIX 线程，也称为 Pthread。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;基本线程函数创建和终止&quot;&gt;基本线程函数：创建和终止&lt;/h1&gt;

&lt;p&gt;讲解5个基本线程函数。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;pthread_create 函数&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当一个程序由 exec 启动执行时，称为 初始线程（initial thread）或 主线程（main thread）的单个线程就创建了。其余线程则由 pthread_create 函数创建。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_26/UNP_1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一个进程内的每个线程都由一个线程 ID（thread ID）标识，其数据类型为 pthread_t （往往是unsigned int）。&lt;/strong&gt;如果新的线程成功创建，其 ID 就通过 tid 指针返回。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;每个线程都有许多属性（attribute）：&lt;/strong&gt;优先级、初始栈大小、是否应该成为一个守护线程等等。这可以在创建线程时，我们通过初始化一个取代默认设置的 pthread_attr_t 变量，把它用来指定这些属性。通常情况下，我们采纳默认设置，这时我们把 attr 参数指定为空指针。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;创建一个线程时，我们最后指定的参数是，由该线程执行的函数及其参数。&lt;/strong&gt;该线程通过调用这个函数开始执行，然后，显式地终止（通过调用pthread_exit），或者隐式地终止（通过让该函数返回）。&lt;/p&gt;

&lt;p&gt;该函数的地址由func参数指定，该函数的唯一调用参数是指针 arg。&lt;/p&gt;

&lt;p&gt;如果我们需要给该函数传递多个参数，我们就得把它们打包成一个结构，然后把这个结构的地址作为单个参数传递给这个起始函数.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意func和arg的声明。&lt;/strong&gt; func 所指函数作为参数，它接受一个通用指针(void * )，又作为返回值返回一个通用指针(void * )。这使得我们可以把一个指针传递给线程（指针指向我们期望的任何内容），又允许线程返回一个指针（指针同样指向我们期望的任何内容）。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;通常情况下，Pthread函数的返回值成功时为0，出错时为某个非0值。与套接字函数及大多数系统调用出错时返回-1&lt;/p&gt;

</description>
        <pubDate>Sun, 21 Jul 2019 10:00:00 +0800</pubDate>
        <link>http://localhost:4000/unp/2019/07/21/Unp-Chapter-26.html</link>
        <guid isPermaLink="true">http://localhost:4000/unp/2019/07/21/Unp-Chapter-26.html</guid>
        
        
        <category>unp</category>
        
      </item>
    
      <item>
        <title>[Unp]Chapter 25</title>
        <description>&lt;h1 id=&quot;概述&quot;&gt;概述&lt;/h1&gt;

&lt;p&gt;信号驱动式 I/O 是指：进程预先告知内核，使得当某个描述符上发生某事时，内核使用信号通知相关进程。&lt;/p&gt;

&lt;p&gt;它通常定义为，进程执行 I/O 系统调用（譬如读或写）告知内核启动某个 I/O 操作，内核启动 I/O 操作后立即返回到进程。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;套接字的信号驱动式-io&quot;&gt;套接字的信号驱动式 I/O&lt;/h1&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;针对一个套接字使用信号驱动式I/O（SIGIO），它需要进程执行以下3个步骤：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;（1）首先，建立 SIGIO 信号的信号处理函数。&lt;/p&gt;

&lt;p&gt;（2）其次，设置该套接字的属主，通常使用 fcntl 的 F_SETOWN 命令设置。&lt;/p&gt;

&lt;p&gt;（3）最后，开启该套接字的信号驱动式 I/O ，通常通过使用 fcntl 的 F_SETFL 命令打开 O_ASYNC 标志完成。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;确定哪些条件导致内核产生 SIGIO 信号（该信号是递交给套接字属主），这不是容易的事。这种判定取决于支撑协议。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;对于 UDP 套接字的 SIGIO 信号&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;在UDP上使用信号驱动式I/O是简单的。SIGIO信号在发生以下事件时，它会产生：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;数据报到达套接字；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;套接字上发生异步错误。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因此，当捕获某个 UDP 套接字的 SIGIO 信号时，我们调用 recvfrom 或者 读入到达的数据报，或者 获取发生的异步错误。UDP 套接字发生异步错误的前提是，UDP套接字已连接。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;对于 TCP 套接字的 SIGIO 信号&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;信号驱动式 I/O 对于 TCP 套接字近乎无用。问题在于，该信号产生得过于频繁。并且，它的出现没有告诉我们发生了什么事件。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;如 TCPv2 第439页所注，下列条件都可以导致 TCP 套接字产生 SIGIO 信号（假设该套接字的信号驱动式I/O已经开启）：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;监听套接字上某个连接请求已经完成；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;某个断连请求已经发起；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;某个断连请求已经完成；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;某个连接之半已经关闭；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;数据到达套接字；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;数据已经从套接字发送走（即输出缓冲区有空闲空间）；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;发生某个异步错误。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;我们只考虑对监听 TCP 套接字使用 SIGIO 。因为对于监听套接字产生 SIGIO 的唯一条件是：某个新连接的完成。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;信号驱动式 I/O 对于套接字的唯一现实用途是，基于 UDP 的 NTP 服务器程序。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;大多数UDP服务器都设计成 下图左侧 所示的方式。&lt;/p&gt;

&lt;p&gt;不过，NTP 服务器却采用 下图右侧 所示的技巧。当一个新的数据报到达时，SIGIO 处理函数读入该数据报，同时记录它的到达时刻，然后将它置于进程内的另一个队列中，以便主服务器循环移走并处理。&lt;/p&gt;

&lt;p&gt;尽管服务器代码变复杂了，却为到达数据报提供了精确的时间戳。对 NTP 服务器而言，重要的是，为每个收取的数据报记录精确的时间戳，因为该值将返送给客户，由客户用于计算到服务器的 RTT。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_25/UNP_1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;UNP 25.3后面的例子可以多去看看。&lt;/p&gt;

</description>
        <pubDate>Sat, 20 Jul 2019 07:00:00 +0800</pubDate>
        <link>http://localhost:4000/unp/2019/07/20/Unp-Chapter-25.html</link>
        <guid isPermaLink="true">http://localhost:4000/unp/2019/07/20/Unp-Chapter-25.html</guid>
        
        
        <category>unp</category>
        
      </item>
    
      <item>
        <title>[Unp]Chapter 24</title>
        <description>&lt;h1 id=&quot;概述&quot;&gt;概述&lt;/h1&gt;

&lt;p&gt;许多传输层有 带外数据 （out-of-band  data）的概念，也称它为 经加速数据（expedited data）。&lt;/p&gt;

&lt;p&gt;带外数据的想法是；在一个连接的某端发生了重要事情，该端希望迅速通告它对端。“迅速” 意味着这种通知会在排队等待发送的数据（等待的数据称“带内数据”）之前发送。&lt;/p&gt;

&lt;p&gt;因此，带外数据的一个特性是，它具有比普通数据更高的优先级。同时，带外数据会被映射到已有的连接当中。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;tcp-带外数据&quot;&gt;TCP 带外数据&lt;/h1&gt;

&lt;p&gt;TCP 没有真正意义上的带外数据。不过，可以通过紧急模式（urgent mode）来实现。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;从发送端的角度观察带外数据的发送&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;假设一个进程往一个 TCP 套接字的发送缓冲区中写入 N 字节数据，并且标记出来。如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_24/UNP_1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;接着，该进程以 MSG_OOB 标记调用 send 函数，它写出一个含有 ASCII 字符 a 的单字节第外数据：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_24/UNP_2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最后，TCP 把这个数据放置在套接字发送缓冲区的下一个可用位置。并且， 在 OOB 标志的下一个位置中，设置该连接的 TCP 紧急指针（urgent pointer）。如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_24/UNP_3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;TCP 紧急指针对应一个 TCP 序列号，它是最后一个数据字节对应的序列号加 1。其中的  “最后一个数据字节”  指的是，使用 MSG_OOB 标志写出的数据字节。（即，带外字节）&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;TCP 紧急模式的一个重要特性&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;TCP 首部指出发送端进入紧急模式，即，伴随紧急偏移的 URG 标志（携带紧急指针）已经设置。但是，紧急指针所指的实际数据字节，它不一定会伴随 URG 发送出去。&lt;/p&gt;

&lt;p&gt;即使因为接收端的套接字接收缓冲区已满，导致向其 TCP 发送端通告一个值为 0 的窗口，紧急通知照样发送出去，但是它不会伴随任何数据。&lt;/p&gt;

&lt;p&gt;由于这个特性，有很多应用程序使用 TCP 紧急模式。哪怕数据的流动会因为 TCP 的流量控制而停止，但是紧急通知却总是能发送到对端 TCP。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;关于 “紧急指针” 和 “紧急偏移”&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;上面特性提到在这两个术语，因此需要解释此含义。在 TCP 层次上，它们是不同的。TCP 首部的16位值称为 紧急指针 。它必须加上同一个首部中的序列号字段才能获得32位的紧急指针。&lt;/p&gt;

&lt;p&gt;在同一个首部中，只有称为 URG 标志的位已经设置的前提下，TCP 才会检查紧急偏移。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如果我们发送多字节的带外数据，情况会怎么样呢?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_24/UNP_4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在这个例子中，TCP 的紧急指针指向最后的字节紧后的位置，也就是说，最后的那个字节（字母c）被认为是带外字节。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;从接收端的角度观察带外数据的接收&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（1）当收到一个设置了 URG  标志的分节时，接收端 TCP 检查紧急指针，用来确定它是否指向新的带外数据。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;发送端 TCP 往往发送多个含有 URG 标志的分节，并且此分节也含有多个紧急指针指向的同一个数据字节。在这些分节中，只有第一个到达的会导致通知接收进程有新的带外数据到达。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（2）当有新的紧急指针到达时，接收进程被通知到。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;首先，内核给接收套接字的属主进程发送SIGURG信号。前提是，接收进程 或 其他进程 曾调用 fcntl 或 ioctl  为这个套接字建立了属主，而且该属主进程已经为这个信号建立了信号处理函数。&lt;/p&gt;

&lt;p&gt;其次，如果接收进程阻塞在 select 调用中，用以等待这个套接字描述符出现一个异常条件的话，select调用就返回。&lt;/p&gt;

&lt;p&gt;注意：只有一个OOB标记，如果新的 OOB 字节在旧的 OOB 字节被读取之前就到达，旧的 OOB 字节会被丢弃。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（3）当实际数据字节（字节由紧急指针指向）到达接收端 TCP 时，该数据字节既可能被拉出带外，也可能被留在带内，即在线（inline）留存。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h3 id=&quot;so_oobinline-套接字选项默认情况下是禁止的&quot;&gt;SO_OOBINLINE 套接字选项默认情况下是禁止的。&lt;/h3&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对于这样的接收端套接字，该数据字节并不放入套接字接收缓冲区，而是被放入该连接的一个独立的单字节带外缓冲区（TCPv2第986～988页）。&lt;/p&gt;

&lt;p&gt;接收进程从单字节缓冲区读入数据的唯一方法是：指定 MSG_OOB 标志调用 recv、recvfrom 或 recvmsg。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h3 id=&quot;如果接收进程开启了-so_oobinline-套接字选项&quot;&gt;如果接收进程开启了 SO_OOBINLINE 套接字选项。&lt;/h3&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;由TCP紧急指针指向的 实际数据字节 会被留在 套接字接收缓冲区中。&lt;/p&gt;

&lt;p&gt;这种情况下，接收进程不能指定 MSG_OOB 标志读入该数据字节。相反，接收进程通过检查该连接的带外标记（out-of-band mark），用以获悉何时访问到这个数据字节。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;接收进程会发生错误的各种情况：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（1）&lt;/strong&gt;如果接收进程请求读入带外数据（通过指定MSG_OOB标志），但是对端尚未发送任何带外数据，读入操作将返回EINVAL。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（2）&lt;/strong&gt;在接收进程 被告知 对端发送了一个带外字节（通过SIGURG或select手段）的前提下。&lt;/p&gt;

&lt;p&gt;如果接收进程试图读入该字节，但是，该字节尚未到达。那么读入操作将返回EWOULDBLOCK。&lt;/p&gt;

&lt;p&gt;接收进程此时能做的是，从套接字接收缓冲区读入数据（要是没有存放这些数据的空间，可能还得丢弃它们），以便在该缓冲区中腾出空间，继而允许对端TCP发送出那个带外字节。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（3）&lt;/strong&gt; 如果 接收进程 试图多次读入 同一个带外字节，读入操作将返回EINVAL。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（4）&lt;/strong&gt;如果 接收进程 已经开启了SO_OOBINLINE套接字选项，后来试图通过 指定 MSG_OOB 标志 读入带外数据，读入操作将返回EINVAL。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;sockatmark-函数&quot;&gt;sockatmark 函数&lt;/h1&gt;

&lt;p&gt;在从套接字读入期间，接收进程通过调用 sockatmark 函数确定是否处于带外标记。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_24/UNP_5.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;带外标记的四个特性综合前面提及的并加入新的特性&quot;&gt;带外标记的四个特性：（综合前面提及的，并加入新的特性）&lt;/h1&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（1）带外标记总是指向 紧随普通数据最后一个字节后面 的位置。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这意味着&lt;/p&gt;

&lt;p&gt;如果带外数据在线接收，并且下一个准备读入的字节，发送端是使用 MSG_OOB 标记发送它的话。那么，sockatmark 函数返回真。&lt;/p&gt;

&lt;p&gt;如果 SO_OOBINLINE 套接字选项没有开启，并且下一个准备读入的字节，它是紧跟在带外数据后面发送到这里的话。那么，sockatmark 函数返回真。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（2）读操作总是停在带外标记上（TCPv2第519～520页）。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这意味着&lt;/p&gt;

&lt;p&gt;假设在套接字接收缓冲区中有100个字节，不过在带外标记之前只有5个字节。如果进程执行一个请求100个字节的 read 调用，那么返回的是带外标记之前的5个字节。&lt;/p&gt;

&lt;p&gt;这种在带外标记上强制停止读操作的做法，它使得进程能够调用 sockatmark 来确定缓冲区指针是否处于带外标记。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（3）即使因为流量控制而停止发送数据了，TCP 仍然发送带外数据的通知（即它的紧急指针）。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（4）在带外数据到达之前，接收进程可能被通知，通知内容为发送进程已经发送了带外数据（使用 SIGURG 信号或通过 select ）。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果接收进程接着指定 MSG_OOB 调用 recv ，而带外数据却尚未到达，recv 将返回 EWOULDBLOCK 错误。&lt;/p&gt;

&lt;p&gt;在&lt;strong&gt;从接收端的角度观察带外数据的接收&lt;/strong&gt;中详细描述。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;关于心搏函数的设计&quot;&gt;关于心搏函数的设计&lt;/h1&gt;

&lt;p&gt;讲解一个简单的心搏函数。这个函数的功能是，它可以发现对端主机 或 到对端的通信路径的过早失效。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;在讲解这些函数之前，必须提出一些警告：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;（1）如果使用 TCP 的保持存活特性（ SO_KEEPALIVE 套接字选项）来提供这种功能，那么 TCP 得在连接已经闲置2小时之后，它才发送一个保持存活探测段。&lt;/p&gt;

&lt;p&gt;关于这种方法，接下来还有一个问题：如何把保持存活的参数改为一个小得多的值（往往是在秒钟的量级），以便更快地检测到失效。&lt;/p&gt;

&lt;p&gt;尽管缩短 TCP 的保持存活的参数在许多系统上确实可行（见TCPv1的附录E），但是，这些参数通常是按照内核，而不是按照每个套接字维护的。因此改动它们将影响所有开启该选项的套接字。另外，保持存活选项的用意绝不是这个目的（高频率地轮询）。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;（2）两个端系统之间短暂的连接性丢失并非总是坏事。&lt;/p&gt;

&lt;p&gt;TCP一开始就设计成能够对付临时断连，比如，源自Berkeley的TCP实现将重传8～10分钟才放弃某个连接。较新的IP路由协议（例如 OSPF ）能够发现链接的失效，并且有可能在短时间内（譬如在秒钟量级上）启用候选的路径。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;我们使用 TCP 紧急模式周期地轮询&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;客户每隔1秒钟向服务器发送一个带外字节。服务器收取该字节会导致它向客户发回一个带外字节。&lt;/p&gt;

&lt;p&gt;每端都需要知道对端是否不复存在 或者 不再可达。客户和服务器每1秒钟就递增它们的 cnt 变量一次，每收到一个带外字节，然后把该变量重置为0。如果该计数器达到5，那就认定连接失效，也就是说本进程已有5秒钟没有收到来自对端的带外字节。&lt;/p&gt;

&lt;p&gt;当有带外字节到达时，客户和服务器都使用 SIGURG 信号得以通知。&lt;/p&gt;

&lt;p&gt;详情参考 UNP24-14的代码。&lt;/p&gt;

</description>
        <pubDate>Fri, 19 Jul 2019 01:00:00 +0800</pubDate>
        <link>http://localhost:4000/unp/2019/07/19/Unp-Chapter-24.html</link>
        <guid isPermaLink="true">http://localhost:4000/unp/2019/07/19/Unp-Chapter-24.html</guid>
        
        
        <category>unp</category>
        
      </item>
    
      <item>
        <title>[Apue]Chapter 10 - c</title>
        <description>&lt;h1 id=&quot;信号集&quot;&gt;信号集&lt;/h1&gt;

&lt;p&gt;信号集（signal set）是一个能表示多个信号的数据类型。&lt;/p&gt;

&lt;p&gt;一般而言，不能用整型量中的一位代表一种信号，也就是说，不能用一个整型变量表示信号集&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;POSIX.1定义数据类型 sigset_t，它可以包含一个信号集，并且定义了下列 5个处理信号集的函数。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Apue/APUE_10/APUE_10_9.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;函数 sigemptyset 初始化由 set 指向的信号集，清除其中所有信号。&lt;/p&gt;

&lt;p&gt;函数 sigfillset 初始化由 set 指向的信号集，使其包括所有信号。&lt;/p&gt;

&lt;p&gt;函数 sigaddset 将一个信号添加到已有的信号集中。&lt;/p&gt;

&lt;p&gt;函数 sigdelset 则从信号集中删除一个信号。&lt;/p&gt;

&lt;p&gt;函数 sigismember 判断给定的信号（signo 参数），是否时信号集中（set 参数）的一个成员。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（1）&lt;/strong&gt;所有应用程序在使用信号集前，要对该信号集调用 sigemptyset 或 sigfillset 一次。&lt;/p&gt;

&lt;p&gt;这是因为 C编译程序 把 不赋初值的外部变量和静态变量都初始化为0。一旦初始化了一个信号集，以后就可以在该信号集中操作（增、删）特定的信号。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（2）&lt;/strong&gt;所有以信号集作为参数的函数，信号集参数通常以指针的形式传递。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;函数-sigprocmask&quot;&gt;函数 sigprocmask&lt;/h1&gt;

&lt;p&gt;调用函数 sigprocmask 可以检测 或 更改，或 同时进行检测和更改进程的信号屏蔽字。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Apue/APUE_10/APUE_10_10.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;参数：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（1）&lt;/strong&gt;参数 oset&lt;/p&gt;

&lt;p&gt;如果它是非空指针，那么进程的当前信号屏蔽字通过 oset 返回。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（2）&lt;/strong&gt;参数 set&lt;/p&gt;

&lt;p&gt;a，如果 set 参数是一个非空指针，那么 how 参数表示如何修改当前信号屏蔽字。下图说明了 how 参数可选的值。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Apue/APUE_10/APUE_10_11.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;SIG_BLOCK 是或操作，而SIG_SETMASK 则是赋值操作。注意，不能阻塞 SIGKILL 和 SIGSTOP 信
号。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;b，如果 set 参数是一个空指针，那么不改变该进程的信号屏蔽字， how 参数的值也没有意义。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;在调用 sigprocmask 函数后，如果有任何（未决的、不再阻塞的）信号，那么在 sigprocmask 函数返回前，至少要把其中的一个信号发送给该进程。&lt;/p&gt;

&lt;p&gt;sigprocmask 函数 仅为单线程定义的。处理多线程进程中的信号屏蔽字，需要使用另一个函数。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;函数-sigpending&quot;&gt;函数 sigpending&lt;/h1&gt;

&lt;p&gt;sigpending 函数返回一个信号集，对于调用进程而言，其中的各个信号是阻塞的、不能传送的。因此，该信号当前是未决的。该信号集通过 set 参数返回。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Apue/APUE_10/APUE_10_12.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;函数-sigaction&quot;&gt;函数 sigaction&lt;/h1&gt;

&lt;p&gt;sigaction 函数的功能是：检查 或 修改 （或 检查并修改）与指定信号相关联的处理动作。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Apue/APUE_10/APUE_10_13.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;参数 signo 是要检测或修改其具体动作的信号编号。&lt;/p&gt;

&lt;p&gt;如果 act 指针参数非空，那么就要修改信号的动作。&lt;/p&gt;

&lt;p&gt;如果 oact 指针参数非空，那么系统经由 oact 指针返回该信号的上一个动作。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;参数 act 和 参数 oact 使用的结构内容，如下：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Apue/APUE_10/APUE_10_14.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Tue, 16 Jul 2019 00:59:32 +0800</pubDate>
        <link>http://localhost:4000/apue/2019/07/16/Apue-Chapter-10-c.html</link>
        <guid isPermaLink="true">http://localhost:4000/apue/2019/07/16/Apue-Chapter-10-c.html</guid>
        
        
        <category>apue</category>
        
      </item>
    
      <item>
        <title>[Apue]Chapter 10 - b</title>
        <description>&lt;h1 id=&quot;函数-signal&quot;&gt;函数 signal&lt;/h1&gt;

&lt;p&gt;UNIX 系统信号机制最简单的接口是 signal 函数。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Apue/APUE_10/APUE_10_2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;signo 返回值是一个函数地址，该函数的参数是整型。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
signal 函数参数：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;signo 参数是信号名(SIGXXXX)。signo 是一个整型数。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;func 是函数指针。func 的值是常量 SIG_IGN、常量SIG_DFL ，或着是 当接收到这个信号后，要调用的函数的地址。
&lt;br /&gt;&lt;br /&gt;
如果制定SIG_IGN，则向内核表示忽略此信号（SIGKILL 和 SIGSTOP 不能被忽略）。
&lt;br /&gt;&lt;br /&gt;
如果制定SIG_DFL，则表示，接收到这个信号后的动作是系统默认动作。
&lt;br /&gt;&lt;br /&gt;
当func 参数是函数的地址时，那么在信号发生时，调用该函数。我们称这种处理为 ‘捕捉该信号”；称这个函数为 “信号处理函数” 或 ”信号捕捉函数“。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;不可靠的信号&quot;&gt;不可靠的信号&lt;/h1&gt;

&lt;p&gt;不可靠的信号是指，信号可能会丢失。一个信号发生了，但进程却可能一直不知道这一点。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;早期版本有一个问题：在进程每次接收到信号，然后进行处理时，将该信号动作重置为默认值。
例如：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Apue/APUE_10/APUE_10_3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;这段代码的一个问题是：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;从信号发生后，一直到信号处理程序调用 signal 函数，这中间有一个时间窗口。在此段时间中，可能会发生另一次中断信号。第二个信号会造成执行默认动作，而对中断信号的默认动作是终止该进程。这种类型的程序段在大多数情况下会正常工作，使得我们认为它们是正确无误的，而实际上却并非如此。&lt;/p&gt;

&lt;p&gt;我们可以对每种信号只捕捉一次，从而回避这一点。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;早期版本的另外一个问题：在进程不希望某种信号发生时，它不能关闭该信号。例如：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Apue/APUE_10/APUE_10_4.png&quot; alt=&quot;它捕捉一个信号，然后设置一个表示该信号已发生的标志&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;这段代码的含义：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;进程调用 pause 函数使自己休眠，直到捕捉到一个信号后苏醒。当捕捉到信号时，信号处理程序将标志 sig_int_flag 设置为非 0 值。从信号处理程序返回后，内核自动将该进程唤醒，它检测到该标志为非 0，然后执行它所需做的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;这段代码的问题是：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在检测sig_int_flag 之后、调用 pause 之前会产生一个时间窗口。如果在这段时间内发生信号，那么此进程在调用 pause 时，可能将永久休眠（假定此信号不会再次产生）。于是，这次发生的信号也就丢失了。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;中断的系统调用&quot;&gt;中断的系统调用&lt;/h1&gt;

&lt;p&gt;早期Unix 系统的一个特性是：如果进程在执行一个低速系统调用，在阻塞期间捕捉到一个信号，则该低速系统调用就被中断，不再继续执行。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;低速系统调用是可能会让进程永远阻塞的一类系统调用，包括：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;如果某些类型文件的数据不存在，则读操作可能会使调用者永远阻塞。这里的某些类型文件指，读管道、终端设备和网络设备。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果这些数据不能被相同的类型文件立即接受，那么写操作可能会使调用者永远阻塞。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在某种条件发生之前，打开某些类型文件，这可能会发生阻塞。比如，打开一个终端设备时，需要先等待与它连接的调制解调器的应答。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;pause 函数 和 wait 函数。按照pause 的定义，它使调用进程休眠，直到捕捉到一个信号苏醒。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;某些进程间通信函数。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;在这些低速系统调用中，有一个值得注意的例外：与磁盘 I/O 有关的系统调用。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;虽然读、写一个磁盘文件可能暂时阻塞调用者，但是除非发生硬件错误，I/O 操作总会很快返回，并且使调用者不再处于阻塞状态。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;为了帮助应用程序不必处理被中断的系统调用，4.2BSD 引进了（某些被中断系统调用的）自动重启动。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;引入自动重启动功能的一个理由是&lt;/strong&gt;：有时用户不知道使用的输入、输出设备是否是低速设备。如果在程序中捕捉信号，而且系统并不提供重启动功能， 则对每次读、写系统调用就要进行是否出错返回的测试；如果是被中断的，则再调用读、写系统调用&lt;/p&gt;

&lt;p&gt;自动重启动的系统调用有：ioctl、read、readv、write、writev、wait 和 waitpid。前5个函数只有对低速设备进行操作时，才会被信号中断。而wait 和 waitpid 在捕捉到信号时，总是被中断。&lt;/p&gt;

&lt;p&gt;因为这种自动重启动的处理方式也会带来问题，某些应用程序不希望这些函数被中断后重启动。因此，4.3BSD 允许进程基于每个信号禁用此功能。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;可重入函数&quot;&gt;可重入函数&lt;/h1&gt;

&lt;p&gt;不可重入的例子：&lt;/p&gt;

&lt;p&gt;进程捕捉到信号，对该信号进行处理时，进程正在执行的正常指令序列就会被临时中断（信号处理程序）。它会先执行该信号处理程序中的指令。如果进程正在malloc，从其堆中分配存储空间。而此时，进程捕捉到信号，从而先执行信号处理程序。因为进程调用了malloc，那么这种情况下会发生什么事情呢？&lt;/p&gt;

&lt;p&gt;这可能会对进程造成破坏。因为malloc 通常为它分配的存储空间维护一个链表，而插入信号处理程序时，进程可能正在更改此链表。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
又例如，若进程正在执行getpwnam这种将其结果存放在静态存储单元中的函数，其间插入执行信号处理程序，它又调用这样的函数，则返回给正常调用者的信息 可能会被 返回给信号处理程序的信息 覆盖。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;可重入的函数如下表：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Apue/APUE_10/APUE_10_5.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;大多数函数是不可重入的原因是：&lt;/p&gt;

&lt;p&gt;（a）它们使用静态数据结构。&lt;/p&gt;

&lt;p&gt;（b）它们调用 malloc 或 free。&lt;/p&gt;

&lt;p&gt;（c）它们是标准 I/O 函数。标准 I/O 库的很多实现都以不可重入的方式使用全剧数据结构。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;注意：&lt;/p&gt;

&lt;p&gt;（1）即使信号处理程序调用的是可重入函数，但是由于每个县城只有一个 errno 变量，因此信号处理程序会修改原先值。&lt;/p&gt;

&lt;p&gt;（2）可重入函数列表中没有 longjmp 和 siglongjmp 的原因是：因为主例程以非可重入方式正在更新一个数据结构时，它可能产生信号。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;sigcld-语义&quot;&gt;SIGCLD 语义&lt;/h1&gt;

&lt;p&gt;SIGCLD 和 SIGCHLD 这两个信号很容易混淆。&lt;/p&gt;

&lt;p&gt;SIGCLD 是 System V 的一个信号名，而SIGCHLD 是 BSD 的信号，它们两个的语音不相同。POSIX.1 采用 BSD 的SIGCHLD 信号。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;SIGCLD&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果用 signal 或 sigset 设置信号配置，则基于 SVR4 的系统继承了这一具有问题色彩的传统（即兼容性限制）。对于 SIGCLD 的早期处理方式是：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（1）&lt;/strong&gt;如果进程将该信号的配置设置为 SIG_IGN ，那么调用进程的子进程将不会产生僵死进程。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;这与 SIG_DFL 信号的默认动作 “忽略” 不同。&lt;/p&gt;

&lt;p&gt;子进程在终止时，将它的状态丢弃。如果调用进程继续调用一个 wait 函数，那么它将阻塞到所有子进程终止，最后该 wait 会返回-1，并将它 errno 设置为 ECHILD。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（2）&lt;/strong&gt;如果将 SIGCLD 的配置设置为捕捉，那么内核会立即检查是否有子进程准备好 被等待。如果是的话，那么调用 SIGCD 处理程序。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;SIGCHLD&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;POSIX.1 未说明在 SIGCHLD 被忽略时应产生的后果，所以这种行为是允许的。 Single UNIX Specification 的 XSI 扩展选项要求对于 SIGCHLD 支持这种行为。&lt;/p&gt;

&lt;p&gt;在 4.4BSD 中，如果 SIGCHLD 的配置设置为忽略， 那么总是产生僵死进程。如果要避免僵死进程，那么必须等待子进程。&lt;br /&gt;在 SVR4 中，如果调用 signal 或 sigset 将 SIGCHLD 的配置设置为忽略，那么决不会产生僵死进程。&lt;/p&gt;

&lt;p&gt;使用 sigaction 可设置 SA_NOCLDWAIT 标志（见图 10-6）以避免进程僵死。本书讨论的 4
种平台都支持这一点。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;可靠信号术语和语义&quot;&gt;可靠信号术语和语义&lt;/h1&gt;

&lt;p&gt;当造成信号的事件发生时，为进程产生一个信号 （或 向进程发送一个信号）。当一个信号产生时，内核通常在进程表中，以某种形式设置一个标志。&lt;/p&gt;

&lt;p&gt;当对信号采取了这种动作时，我们说，这是向进程&lt;strong&gt;递送&lt;/strong&gt;了一个信号。&lt;br /&gt;在信号产生（generation）和 递送（delivery）之间的时间间隔内，称信号是&lt;strong&gt;未决的&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;事件，它可以是硬件异常（如 除以0）、软件条件（如 alarm 定时期超时）、终端产生的信号 或 调用 kill 函数。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;进程可以选用 “阻塞信号递送”。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果进程&lt;strong&gt;产生&lt;/strong&gt;了一个阻塞信号，对该信号的动作是系统默认动作 或 捕捉该信号，那么此进程将该信号保持为&lt;strong&gt;未决状态&lt;/strong&gt;。这将会持续到此进程对该信号解除阻塞，或者 对此信号的动作更改为忽略。&lt;/p&gt;

&lt;p&gt;内核在&lt;strong&gt;发送&lt;/strong&gt;一个被阻塞的信号给进程时，才决定对信号的处理方式。因此，在信号发送到进程之前，仍可以改变对该信号的动作。进程可以调用 sigpending 函数来判断哪些信号是设置为阻塞，并且处于未决状态的。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;在进程解除对某个信号的阻塞之前，如果这个信号发生了多次，那么会发生什么呢？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;POSIX.1 允许系统发送该信号一次 或 多次。如果发送该信号多次，则称 这些信号进行了排队。但是，除了支持 POSIX.1 实时扩展的系统，否则大多数 UNIX 并不对信号排队，而是只递送这种信号一次。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如果有多个信号要发送给一个进程，那么会发生什么呢？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;POSIX.1 并没有规定这些信号的发送顺序。但是 POSIX.1 基础部分建议：在其他信号之前，发送与进程当前状态有关的信号，如 SIGSEGV。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;每个进程都有一个信号屏蔽字（signal mask），它规定了，当前要阻塞发送到该进程的信号集。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;对于每种可能会阻塞的信号，该屏蔽字中，都有一位与之对应。&lt;br /&gt;对于某种信号，如果它的对应位已设置，则它当前是被阻塞的。&lt;/p&gt;

&lt;p&gt;进程可以调用 sigprocmask 来检测和更改它当前信号屏蔽字。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;信号集&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;由于信号编号可能会超过一个整型所包含的二进制位数，因此，POSIX.1 定义了一个新数据类型 sigset_t。&lt;/p&gt;

&lt;p&gt;这个新数据类型可以容纳一个信号集，而信号屏蔽字就可以存放在信号集中。（此数据类型就是信号集的实现）&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;函数-kill-和-raise&quot;&gt;函数 kill 和 raise&lt;/h1&gt;

&lt;p&gt;kill 函数将信号发送给进程 （或 进程组）。raise 函数则允许进程向自身发送信号。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Apue/APUE_10/APUE_10_6.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;kill 的 pid 参数有以下 4 种不同的情况：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;pid &amp;gt; 0&lt;/strong&gt; &lt;br /&gt; 将该信号发送给进程ID为 pid参数 的进程。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;pid == 0&lt;/strong&gt; &lt;br /&gt; 将该信号发送给一些进程。这些进程与发送进程属于同一进程组，而且发送进程有权限向这些进程发送信号。&lt;br /&gt; &lt;br /&gt; 注意，这些进程不包括实现定义的系统进程集。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;pid &amp;lt; 0&lt;/strong&gt; &lt;br /&gt; 将该信号发送给一些进程。这些进程的进程组ID等于 pid 参数绝对值，而且发送进程有权限向这些进程发送信号。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;pid = -1&lt;/strong&gt; &lt;br /&gt; 将该信号发送给一些进程。这些进程是发送进程有权限向它们发送信号的。&lt;br /&gt; &lt;br /&gt; 注意，这些进程不包括系统进程集中的进程。（与 pid == 0 的注意事项一样。）&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;函数-alarm-和-pause&quot;&gt;函数 alarm 和 pause&lt;/h1&gt;

&lt;p&gt;使用alarm 函数可以设置一个定时器（闹钟时间），在将来的某个时刻，这个定时器会超时。当这个定时期超时时，内核产生 SIGALRM 信号。如果忽略 或 不捕捉此信号，那么它的默认动作时终止调用该alarm 函数的进程。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Apue/APUE_10/APUE_10_7.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;参数 seconds 的值是产生信号 SIGALRM 的条件，该条件是需要经过的时钟秒数。&lt;/p&gt;

&lt;p&gt;当这一时刻达到时，信号由内核产生。由于进程调度的延迟，所以还需要一个时间间隔才能让进程得到控制，使得进程能够处理该信号。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;每个进程只能有一个闹钟时间&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果在调用 alarm时，之前已经为该进程注册了闹钟时间，并且还没有超时。那么，该闹钟时间剩余的值将会作为本次调用 alarm 函数的返回值，并且，以前注册的闹钟时间被新值代替。&lt;/p&gt;

&lt;p&gt;如果以前注册的闹钟时间还没有超时，并且本次 alarm 函数的 seconds 参数为0。那么，取消以前的闹钟时间，之前剩余的值作为 alarm 函数的返回值。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt; &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;虽然，SIGALRM 的默认动作是终止进程，但是大多数使用闹钟的进程捕捉此信号。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当我们想捕捉 SIGALRM 信号时，必须在调用 alarm 函数之前，安装该信号的处理程序。&lt;/p&gt;

&lt;p&gt;如果我们先调用 alarm 函数，在安装 SIGALRM 处理程序之前，已经接收到 SIGALRM 信号。那么进程将终止。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;pause 函数&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;它会让调用进程挂起，直到捕捉到一个信号。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Apue/APUE_10/APUE_10_8.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;只有执行了一个信号处理程序，并且从此程序返回时，pause才返回。这种情况下，pause 返回 -1，errno 设置为 EINTR。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://waterwoodfountainhead.github.io/apue/2019/07/15/Apue-Chapter-10-c.html&quot;&gt;进入下一篇：《Chapter 10 - c》&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Tue, 16 Jul 2019 00:50:32 +0800</pubDate>
        <link>http://localhost:4000/apue/2019/07/16/Apue-Chapter-10-b.html</link>
        <guid isPermaLink="true">http://localhost:4000/apue/2019/07/16/Apue-Chapter-10-b.html</guid>
        
        
        <category>apue</category>
        
      </item>
    
      <item>
        <title>[Apue]Chapter 10 - a</title>
        <description>&lt;h1 id=&quot;信号概念&quot;&gt;信号概念&lt;/h1&gt;

&lt;p&gt;信号是软件中断。信号提供了一种处理异步事件的方法。&lt;/p&gt;

&lt;p&gt;每个信号都有一个名字。这些名字都以3个字符SIG开头。&lt;/p&gt;

&lt;p&gt;在头文件&lt;signal.h&gt;中，信号名都被定义为正整数常量（信号编号）。不存在编号为0的信号。不过，kill 函数对信号编号0有特殊应用。POSIX.1 将此种信号编号值称为空信号。&lt;/signal.h&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;有很多条件可以产生信号:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;当用户按下某些终端键时，使终端产生的信号。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;硬件异常产生信号：除数为0、无效的内存引用等。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;进程调用 kill(2) 函数，可以将任意信号发送给另一个进程(或 进程组)。&lt;br /&gt;&lt;br /&gt;&lt;strong&gt;不过，它是有限制的：&lt;/strong&gt;接受信号的进程和发送信号的进程，它们的所有者必须相同。或者，发送信号的进程的所有者是超级用户。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;用户可以用 kill(1) 命令将信号发送给其他进程。此命令只是 kill函数的接口。它常用于终止一个失控的后台进程。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当检测到某种软件条件已经发生，并将其通知有关进程时，也会产生信号。这里指的不是硬件产生条件(比如，除以0)，而是软件条件。例如：SIGURG——在网络连接上传来带外的数据时产生，等等。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;进程不能测试一个变量来判断是否发生了一个信号，而是告诉内核进行处理。&lt;strong&gt;在某个信号出现时，可以告诉内核按下列3种方式之一进行处理：&lt;/strong&gt;（称为信号的处理，或与信号相关的动作）&lt;/p&gt;

&lt;p&gt;（1）忽略此信号。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;有两种信号不能被忽略——SIGKILL 和 SIGSTOP。原因是，它们向内核和超级用户提供了让进程终止(或 停止) 的可靠方法。&lt;/p&gt;

&lt;p&gt;如果忽略某些硬件异常所产生的信号，进程的运行行为是为定义的。比如：非法内存引用 或 除以0。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;（2）捕捉信号。&lt;/p&gt;

&lt;p&gt;为了捕捉信号，要通知内核在某种信号发生时，调用一个用户函数。在用户函数中，可以执行用户自己对这种事件的处理。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;（3）执行系统默认动作。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;对大多数信号而言，它们的系统默认动是终止该进程。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;下图列出所有信号的名字，说明了那些系统支持此信号，还有说明了这些信号的系统默认动作。&lt;/p&gt;

&lt;p&gt;列表中的点号表示这个信号定义为基本 POSIX.1规范部分。“XSI” 表示该信号定义在XSI扩展部分。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Apue/APUE_10/APUE_10_1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图中，一部分信号的默认动作是“终止+core”，这会产生一个core文件。那么，如何避免产生core文件呢？&lt;/p&gt;

&lt;p&gt;（a）进程是设置用户ID的，而且当前用户并非程序文件的所有者。&lt;/p&gt;

&lt;p&gt;（b）进程是设置组ID的，并且当前用户并非该程序文件的所有者。&lt;/p&gt;

&lt;p&gt;（c）用户没有写当前工作目录的权限。&lt;/p&gt;

&lt;p&gt;（d）文件已存在，而且用户对该文件设有写权限。&lt;/p&gt;

&lt;p&gt;（e）文件太大。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;上图中，SIGBUS——硬件故障   是对应实现定义的硬件故障。APUE p272 - 276页（实际页数为p252 - 256页）将进一步详细说明一些信号。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://waterwoodfountainhead.github.io/apue/2019/07/15/Apue-Chapter-10-b.html&quot;&gt;进入下一篇：《Chapter 10 - b》&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 16 Jul 2019 00:38:32 +0800</pubDate>
        <link>http://localhost:4000/apue/2019/07/16/Apue-Chapter-10-a.html</link>
        <guid isPermaLink="true">http://localhost:4000/apue/2019/07/16/Apue-Chapter-10-a.html</guid>
        
        
        <category>apue</category>
        
      </item>
    
      <item>
        <title>[Unp]Chapter 5</title>
        <description>&lt;p&gt;#&lt;/p&gt;

&lt;p&gt;讲TIME_WAIT前，我们需要了解下&lt;a href=&quot;https://waterwoodfountainhead.github.io/unp/2019/06/26/Unp-Nouns.html&quot;&gt;迷途(Nouns第12条)&lt;/a&gt;和TCP连接终止的过程，如图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_2/UNP2.6.1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;TCP的终结需要4个分节：&lt;/p&gt;

&lt;p&gt;（1）客户端首先调用close，我们称该端执行主动关闭（active close）。该端的TCP于是发送一个FIN分节，表示数据发送完毕。&lt;/p&gt;

&lt;p&gt;（2）接收到这个FIN的对端执行被动关闭（passive close）。这个FIN由TCP确认。服务端接收FIN意味着服务端的应用进程在相应连接上再无额外数据可接收。&lt;/p&gt;

&lt;p&gt;（3）一段时间后，接收到这个文件结束符的应用进程将调用close关闭它的套接字。这导致它的TCP也发送一个FIN。&lt;/p&gt;

&lt;p&gt;（4）接收这个最终FIN的客户端的TCP（即执行主动关闭的那一端）确认这个FIN。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;time_wait状态&quot;&gt;TIME_WAIT状态&lt;/h1&gt;

&lt;p&gt;先介绍下TIME_WAIT状态：这个状态的持续时间是最长分节生命期（maximum segment lifetime，MSL）的两倍，有时候称之为2MSL。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;那么，TIME_WAIT状态有什么作用呢？&lt;/p&gt;

&lt;p&gt;(1) 可靠地实现TCP全双工连接的终止；&lt;/p&gt;

&lt;p&gt;假设最终的ACK丢失了来解释。服务器将重新发送它的最终那个FIN，因此客户必须维护状态信息，以允许它重新发送最终那个ACK。要是客户不维护状态信息，它将响应以一个RST（另外一种类型的TCP分节），该分节将被服务器解释成一个错误。如果TCP打算执行所有必要的工作以彻底终止某个连接上两个方向的数据流（即全双工关闭），那么它必须正确处理连接终止序列4个分节中任何一个分节丢失的情况。&lt;/p&gt;

&lt;p&gt;这也说明了执行主动关闭的那一端(客户端)由于要重传最后一个ACK，所以是处于TIME_WAIT状态。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;(2) 允许老的重复分节在网络中消逝。&lt;/p&gt;

&lt;p&gt;有时候一个连接可能会在关闭后，又在相同的ip地址和端口之间建立一个连接。因此TCP必须防止这个连接的老的重复分组在该连接已终止后再现，以免被误解成属于同一连接的某个新的化身。&lt;/p&gt;

&lt;p&gt;为此，TCP将不给处于TIME_WAIT状态的连接发起新的化身。既然TIME_WAIT状态的持续时间是MSL的2倍，这就足以让某个方向上的分组最多存活MSL秒即被丢弃，另一个方向上的应答最多存活MSL秒也被丢弃。通过实施这个规则，我们就能保证每成功建立一个TCP连接时，来自该连接先前化身的老的重复分组都已在网络中消逝了。&lt;/p&gt;
</description>
        <pubDate>Tue, 02 Jul 2019 10:00:00 +0800</pubDate>
        <link>http://localhost:4000/unp/2019/07/02/Unp-Chapter-5.html</link>
        <guid isPermaLink="true">http://localhost:4000/unp/2019/07/02/Unp-Chapter-5.html</guid>
        
        
        <category>unp</category>
        
      </item>
    
      <item>
        <title>[Unp]Chapter 4</title>
        <description>&lt;h1 id=&quot;概述&quot;&gt;概述&lt;/h1&gt;

&lt;p&gt;下图给出在一对TCP客户与服务器进程之间发生的一些典型事件的时间表。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_4/UNP4.1.1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;socket-函数&quot;&gt;socket 函数&lt;/h1&gt;

&lt;p&gt;为了执行网络I/O，进程必须做的第一件事情就是调用socket函数，指定通信协议类型（使用IPv4的TCP、使用IPv6的UDP、Unix域字节流协议等）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_4/UNP4.2.1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;family参数&lt;/strong&gt;：它指明协议族，它是下图所示的某个常值。该参数也往往被称为协议域。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_4/UNP4.2.2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;type参数&lt;/strong&gt;：指明套接字类型，它是下图中所示的某个常值。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_4/UNP4.2.3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;protocol参数&lt;/strong&gt;：应设为下图所示的某个协议类型常值，或者设为0，以选择所给定family和type组合的系统默认值。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_4/UNP4.2.4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;不过，并非所有套接字 family 与 type 的组合都是有效的，下图给出了一些有效的组合和对应的真正协议。其中标为“是”的项也是有效的，但还没有找到便捷的缩略词。而空白项则是无效组合。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_4/UNP4.2.5.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;对比 AF_xxx 和 PF_xxx&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;AF_ 前缀表示地址族，PF_ 前缀表示协议族。&lt;/p&gt;

&lt;p&gt;头文件&amp;lt;sys/socket.h&amp;gt;中为一给定协议定义的 PF_ 值总是与此协议的 AF_ 值相等。尽管这种相等关系并不一定永远成立。为与现存代码保持一致，我们仅使用 AF_ 常值，不过，在调用 socket 时，我们可能会碰到 PF_ 值。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;connect-函数&quot;&gt;connect 函数&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_4/UNP4.3.1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;（1）sockfd是由socket函数返回的套接字描述符，第二个、第三个参数分别是一个指向套接字地址结构的指针和该结构的大小。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;（2）客户在调用函数connect前不必非得调用bind函数（我们在下一节介绍该函数），因为如果需要的话，内核会确定源IP地址，并选择一个临时端口作为源端口。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;（3）如果是TCP套接字，调用connect函数仅在连接建立成功或出错时才返回，其中出错返回可能有以下几种情况：&lt;/p&gt;

&lt;p&gt;①若TCP客户没有收到SYN分节的响应，则返回ETIMEDOUT错误。当我们调用connect函数时，4.4BSD内核发送一个SYN，若无响应则等待6s后再发送一个，若仍无响应则等待24s后再发送一个（TCPv2第828页）。若总共等了75s后，它仍未收到响应则返回本错误。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;②若对客户的SYN的响应是RST（表示复位），则表明该服务器主机在我们指定的端口上没有进程在等待与之连接（例如服务器进程也许没在运行）。这是一种硬错误（hard error），客户一接收到RST就马上返回ECONNREFUSED错误。&lt;/p&gt;

&lt;p&gt;RST是TCP在发生错误时发送的一种TCP分节。产生RST的三个条件是：目的地为某端口的SYN到达，然而该端口上没有正在监听的服务器（如前所述）；TCP想取消一个已有连接；TCP接收到一个根本不存在的连接上的分节。（TCPv1第246～250页有更详细的信息。）&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;③若客户发出的SYN在中间的某个路由器上引发了一个“destination unreachable”（目的地不可达）ICMP错误，则认为是一种软错误（soft error）。&lt;/p&gt;

&lt;p&gt;客户主机内核保存该消息，并按第一种情况中所述的时间间隔继续发送SYN。若在某个规定的时间（4.4BSD规定75s）后仍未收到响应，则把保存的消息（即ICMP错误）作为EHOSTUNREACH或ENETUNREACH错误返回给进程。&lt;/p&gt;

&lt;p&gt;还有两种情形也是有可能的：一是按照本地系统的转发表，根本没有到达远程系统的路径；二是connect调用根本不等待就返回。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;通过一个例子更好的理解上面三种情况：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;首先指定本地主机（127.0.0.1），它正在运行对应的时间获取服务器程序，我们观察正常的输出：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_4/UNP4.3.2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;接着指定本地子网（192.168.1/24）上其主机ID（100）并不存在的一个IP地址，这样当客户主机发出ARP请求（要求那个不存在的主机响应以其硬件地址）时，它将永远收不到ARP响应：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_4/UNP4.3.3.png&quot; alt=&quot;（err_sys函数以直观可读的字符串消息表示了ETIMEDOUT错误的含义）&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然后，我们指定一个没有运行时间获取服务器程序的主机（其实是一个本地路由器）：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_4/UNP4.3.4.png&quot; alt=&quot;（服务器主机立刻响应以一个RST分节）&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最后，我们指定一个因特网中不可到达的IP地址，那么路由器就会返回主机不可达的ICMP错误：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_4/UNP4.3.5.png&quot; alt=&quot;（connect也在等待规定的一段时间之后才返回EHOSTUNREACH错误）&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;bind-函数&quot;&gt;bind 函数&lt;/h1&gt;

&lt;p&gt;bind 函数把一个本地协议地址赋予一个套接字。对于网际网协议，协议地址是32位的IPv4地址或128位的IPv6地址与16位的TCP或UDP端口号的组合。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_4/UNP4.4.1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;第二个参数是一个指向特定于协议的地址结构的指针，第三个参数是该地址结构的长度。从bind函数返回的一个常见错误是EADDRINUSE（“Address already in use”，地址已使用）。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;对于TCP，调用bind函数可以指定一个端口号，或指定一个IP地址，也可以两者都指定，还可以都不指定。因此，有两点需要注意：&lt;/p&gt;

&lt;p&gt;（1）如果一个TCP客户或服务器未曾调用 bind捆绑一个端口，当调用 connect 或 listen 时，内核就要为相应的套接字选择一个临时端口。让内核来选择临时端口对于TCP客户来说是正常的，除非应用需要一个预留端口（图2-10）；然而对于TCP服务器来说却极为罕见，因为服务器是通过它们的众所周知端口被大家认识的。&lt;/p&gt;

&lt;p&gt;不过，有一个例外——远程过程调用（Remote Procedure Call，RPC）服务器。由内核为它们的监听套接字选择一个临时端口，而该端口随后通过RPC端口映射器进行注册。客户在connect这些服务器之前，必须与端口映射器联系以获取它们的临时端口。这种情况也适用于使用UDP的RPC服务器。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;（2）进程可以把一个特定的IP地址捆绑到它的套接字上，不过这个IP地址必须属于其所在主机的网络接口之一。&lt;/p&gt;

&lt;p&gt;对于TCP客户端来说，这就为在该套接字上发送的IP数据报指派了源IP地址。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;对于TCP服务器，这就限定该套接字只接收那些目的地为这个IP地址的客户连接。TCP客户通常不把IP地址捆绑到它的套接字上。当连接套接字时，内核将根据所用外出网络接口来选择源IP地址，而所用外出接口则取决于到达服务器所需的路径（TCPv2第737页）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果TCP服务器没有把IP地址捆绑到它的套接字上，内核就把客户发送的SYN的目的IP地址作为服务器的源IP地址（TCPv2第943页）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;下图汇总了根据预期的结果，来设置sin_addr和sin_port或者sin6_addr和sin6_port的值：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_4/UNP4.4.2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;对于上图的一些说明：&lt;/p&gt;

&lt;p&gt;（1）如果指定端口号为0，内核会在bind被调用时选择一个临时端口。然而，如果指定IP地址为通配地址，内核将会等到（TCP）套接字已连接 或 已经在（UDP）套接字上发出数据报时，它才选择一个本地IP地址。&lt;/p&gt;

&lt;p&gt;对于IPv4来说，通配地址由常值INADDR_ANY来指定，其值一般为0（由于是网络字节序还是主机字节序，INADDR_ANY的值（为0）都一样，因此使用htonl并非必需）。它告知内核去选择IP地址。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_4/UNP4.4.3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;（2）对于IPv6，我们就不能这么做了，因为128位的IPv6地址是存放在一个结构中的。（在C语言中，赋值语句的右边无法表示常值结构。）为了解决这个问题，我们改写为：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_4/UNP4.4.4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;系统 预先 分 配 in6addr_any 变量并将其 初始 化为常值 IN6ADDR_ANY_INIT。头文件&amp;lt;netinet/in.h&amp;gt;中含有in6addr_any的extern声明。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;（3）如果让内核来为套接字选择一个临时端口号，那么必须注意，函数bind并不返回所选择的
值。实际上，由于bind函数的第二个参数有const限定词，它无法返回所选之值。为了得到内
核所选择的这个临时端口值，必须调用函数getsockname来返回协议地址。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;listen-函数&quot;&gt;listen 函数&lt;/h1&gt;

&lt;p&gt;listen函数仅由TCP服务器调用，它做两件事情：&lt;/p&gt;

&lt;p&gt;（1）当socket函数创建一个套接字时，它被假设为一个主动套接字，而 listen 函数把这个未连接的套接字转换成一个被动套接字，指示内核应接受指向该套接字的连接请求。&lt;/p&gt;

&lt;p&gt;根据下图，调用listen导致套接字从CLOSED状态转换到LISTEN状态。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_4/UNP4.5.1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;(2) 本函数的第二个参数规定了内核应该为相应套接字排队的最大连接个数。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_4/UNP4.5.2.png&quot; alt=&quot;（本函数通常应该在调用socket和bind这两个函数之后，并在调用accept函数之前调用）&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为了理解其中的backlog参数，我们必须认识到内核为任何一个给定的监听套接字维护两个队列：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;(1) 未完成连接队列（incomplete connection queue），每个这样的SYN分节对应其中一项：已由某个客户发出并到达服务器，而服务器正在等待完成相应的TCP三路握手过程。这些套接字处于SYN_RCVD状态。&lt;/p&gt;

&lt;p&gt;(2) 已完成连接队列（completed connection queue），每个已完成TCP三路握手过程的客户对
应其中一项。这些套接字处于ESTABLISHED状态。&lt;/p&gt;

&lt;p&gt;这两种状态如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_4/UNP4.5.3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;关于这两个队列的处理，以下几点需要考虑：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;（1）listen函数的backlog参数曾被规定为这两个队列总和的最大值。&lt;/p&gt;

&lt;p&gt;（2）源自Berkeley的实现给backlog增设了一个模糊因子（fudge factor）。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;把它乘以1.5得到未处理队列最大长度（TCPv1第257页和TCPv2第462页）。举例来说，通常指定为5的backlog值实际上允许最多有8项在排队。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果我们把backlog看成是内核能为某套接字排队的最大已完成连接数目，那么增加模糊因子的理由是，把队列中的未完成连接也计算在内。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;（3）不要把backlog定义为0，因为不同的实现对此有不同的解释。如果你不想让任何客户连接到你的监听套接字上，那就关掉该监听套接字。&lt;/p&gt;

&lt;p&gt;（4）在三路握手顺利完成的前提下，未完成连接队列中的任何一项的存留时间就是一个RTT。而RTT的值取决于特定的客户与服务器。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;TCPv3的14.4节指出，对于一个Web服务器，许多客户与单个服务器之间的中值RTT为187ms。（既然出现一些大值可能显著扭曲均值，对于该统计量通常使用中值。）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;（5）现如今，服务器一天可能要处理几百万个连接，这个4.2BSD支持的最大值 (backlog价为5) 就根本不够了（TCPv3第187～192页）。繁忙的HTTP服务器必须指定一个大得多的backlog值，而且较新的内核必须支持较大的backlog值。&lt;/p&gt;

&lt;p&gt;因此，指定较大backlog值的理由在于：随着客户SYN分节的到达，未完成连接队列中的项数可能增长，它们等着三路握手的完成。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;（6）当一个客户端的SYN到达时，若这些队列是满的，服务端TCP就忽略该分节（TCPv2第930～931页），也就是不发送RST。这么做是因为：这种情况是暂时的，客户端TCP将重发SYN，期望不久就能在这些队列中找到可用空间。&lt;/p&gt;

&lt;p&gt;另外，客户端无法区别响应SYN的RST究竟意味着 “该端口没有服务器在监听” ，还是意味着 “该端口有服务器在监听，不过它的队列满了”。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;（7）在三路握手完成之后，但在服务器调用accept之前到达的&lt;strong&gt;数据&lt;/strong&gt;应在服务器TCP中排队，最大数据量为相应已连接套接字的接收缓冲区大小。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;实现原理&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;每当在未完成连接队列中创建一项时，来自监听套接字的参数就复制到即将建立的连接中。连接的创建机制是完全自动的，无需服务器进程插手。&lt;/p&gt;

&lt;p&gt;下图展示了用这两个队列建立连接时所交换的分组。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_4/UNP4.5.4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;（1）当来自客户的SYN到达时，TCP在未完成连接队列中创建一个新项。&lt;/p&gt;

&lt;p&gt;（2）然后响应以三路握手的第二个分节：服务器的SYN响应，其中捎带对客户SYN的ACK。&lt;/p&gt;

&lt;p&gt;（3）这个新项一直保留在未完成连接队列中，直到三路握手的第三个分节（客户对服务器SYN的ACK）到达或者该项超时为止。（源自Berkeley的实现为这些未完成连接的项设置的超时值为75 s。&lt;/p&gt;

&lt;p&gt;（4）如果三路握手正常完成，该项就从未完成连接队列移到已完成连接队列的队尾。&lt;/p&gt;

&lt;p&gt;（5）当进程调用 accept 时，已完成连接队列中的队头项将返回给进程，或者如果该队列为空，那么进程将被投入睡眠，直到TCP在该队列中放入一项才唤醒它。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;不同的操作系统，backlog 的意义解释也是不同的，如下图：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_4/UNP4.5.4.png&quot; alt=&quot;FreeBSD的算法是backlog值本身加1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;accept-函数&quot;&gt;accept 函数&lt;/h1&gt;

&lt;p&gt;accept函数由TCP服务器调用，用于从已完成连接队列队头返回下一个已完成连接。如果已完成连接队列为空，那么进程被投入睡眠（假定套接字为默认的阻塞方式）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_4/UNP4.6.1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;关于accept 函数有关说明：&lt;/p&gt;

&lt;p&gt;（1）参数 cliaddr 和 addrlen 用来返回已连接的对端进程（客户）的协议地址。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;（2）addrlen是&lt;a href=&quot;https://waterwoodfountainhead.github.io/unp/2019/06/27/Unp-Chapter-3.html&quot;&gt;值—结果参数&lt;/a&gt;：调用前，我们将由 * addrlen 所引用的整数值置为由cliaddr所指的套接字地址结构的长度。返回时，该整数值即为由内核存放在该套接字地址结构内的确切字节数。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;（3）如果accept成功，那么其返回值是由内核自动生成的一个全新描述符，代表与所返回客户
的TCP连接。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;（4）accept的第一个参数是监听套接字（listening socket）描述符（由socket创建，随后用作bind和listen的第一个参数的描述符）。它的返回值是已连接套接字（connected socket）描述符。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;区分这两个套接字非常重要：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;监听套接字：一个服务器通常仅仅创建一个监听套接字，它在该服务器的生命期内一直存在。&lt;/p&gt;

&lt;p&gt;已连接套接字：内核为服务器进程接受的客户连接创建一个已连接套接字（也就是说对于它的TCP三路握手过程已经完成）。当服务器完成对某个给定客户的服务时（调用close），相应的已连接套接字就被关闭。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;（5）accept 函数最多返回三个值：&lt;/p&gt;

&lt;p&gt;①可能是新套接字描述符。&lt;/p&gt;

&lt;p&gt;②可能是出错指示的整数、客户进程的协议地址（由 cliaddr指针参数所指）以及该地址的大小（由 addrlen指针参数所指）。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;并发服务器&quot;&gt;并发服务器&lt;/h1&gt;

&lt;p&gt;使用 fork创建一个典型的并发服务器轮廓，如图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_4/UNP4.8.1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当一个连接建立时，accept返回，服务器接着调用fork，然后由子进程服务客户（通过已连接套接字connfd），父进程则等待另一个连接（通过监听套接字listenfd）。既然新的客户由子进程提供服务，父进程就关闭已连接套接字。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为什么上图程序中父进程对 connfd 调用 close 没有终止它与客户的连接呢？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们知道每个文件或套接字都有一个引用计数。socket返回后与listenfd关联的文件表项的引用计数值为1。accept返回后与connfd关联的文件表项的引用计数值也为1。&lt;/p&gt;

&lt;p&gt;在fork返回后，这两个描述符就在父进程与子进程间共享（也就是被复制），因此与这两个套接字相关联的文件表项各自的访问计数值均为2。&lt;/p&gt;

&lt;p&gt;当父进程关闭connfd时，它只是把相应的引用计数值从2减为1。该套接字真正的清理和资源释放
要等到其引用计数值到达0时才发生。既然引用计数值仍大于0，这个close调用并不引发TCP的四分组连接终止序列。这会在稍后子进程也关闭connfd时发生。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如果父进程对每个由accept返回的已连接套接字都不调用close，那么并发服务器中将会发生什么？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;没有一个客户连接会被终止。父进程最终将耗尽可用描述符，因为任何进程在任何时刻可拥有的打开着的描述符数通常是有限制的。同时，这将妨碍TCP连接终止序列的发生，导致连接一直打开着。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;close-函数&quot;&gt;close 函数&lt;/h1&gt;

&lt;p&gt;Unix close函数也用来关闭套接字，并终止TCP连接。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_4/UNP4.9.1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;close的默认行为是把该套接字标记成已关闭，然后立即返回到调用进程。该套接字描述符不能再由调用进程使用，也就是说它不能再作为read或write的第一个参数。&lt;/p&gt;

&lt;p&gt;然而TCP将尝试发送（已排队并等待发送到对端的）数据，发送完毕后正常进行TCP连接终止序列。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;getsockname-和-getpeername-函数&quot;&gt;getsockname 和 getpeername 函数&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/images/Unp/UNP_4/UNP4.10.1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;getsockname函数：返回与某个套接字关联的本地协议地址。&lt;/p&gt;

&lt;p&gt;getpeername 函数：返回与某个套接字关联的外地协议地址。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这两个函数的最后一个参数都是 &lt;strong&gt;值-结果参数&lt;/strong&gt;。这就是说，这两个函数都得装填由 localaddr 或 peeraddr指针所指的套接字地址结构。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;需要这两个函数的理由如下：&lt;/p&gt;

&lt;p&gt;（1）在一个没有调用 bind函数的TCP客户端上，connect成功返回后，getsockname用于返回（由内核赋予）该连接的本地IP地址和本地端口号。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;（2）在以端口号 0 调用bind（告知内核去选择本地端口号）后，getsockname用于返回由内核赋予的本地端口号。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;（3）getsockname可用于获取某个套接字的地址族。例如：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sockfd_to_family&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sockfd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;	&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sockaddr_storage&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ss&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;socklen_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;len&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ss&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getsockname&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sockfd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SA&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ss&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ss&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ss_family&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;11&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;第5行：由于不清楚要分配的套接字地址结构的类型，于是采用sockaddr_storage这个通用结构。因为它能够承载系统支持的任何套接字地址结构。&lt;/p&gt;

&lt;p&gt;第7-10行：我们调用getsockname返回地址族。既然POSIX规范允许对未绑定的套接字调用getsockname，该函数应该适合任何已打开的套接字描述符。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;（4）在一个以通配IP地址调用bind的TCP服务器上，与某个客户的连接一旦建立（accept成功返回），getsockname就可以用于返回（由内核赋予）该连接的本地IP地址。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;在这样的调用中，套接字描述符参数必须是已连接套接字的描述符，而不是监听套接字的描述符。&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;（5）当一个服务器是由调用过accept的某个进程通过调用exec执行程序时，它能够获取客户身份的唯一途径便是调用getpeername。&lt;/p&gt;
</description>
        <pubDate>Fri, 28 Jun 2019 10:00:00 +0800</pubDate>
        <link>http://localhost:4000/unp/2019/06/28/Unp-Chapter-4.html</link>
        <guid isPermaLink="true">http://localhost:4000/unp/2019/06/28/Unp-Chapter-4.html</guid>
        
        
        <category>unp</category>
        
      </item>
    
  </channel>
</rss>
