---
layout: post
title:  "[Old_Linux]boot.s"
subtitle: "bootsect.s的框架程序"
date:   2019-09-23 10:00:00 +0800
categories: [old_linux]
---

! <br>
! boot.s <br>
!<br>


! .globl是汇编指示符。汇编指示符以一个字符‘.’开始，不会在编译时产生任何代码。汇编指示符由一个伪操作码，后跟0个或多个操作数组成。<br>
! .globl伪操作符用于定义后面的标号标识符(如，begtext...)是外部的还是全局的，即使不使用也要强制引入。<br>
**.globl begtext,begdata,begbss,endtext,enddata,endbss**<br><br><br>



! 下面的语句除了定义 3 个标号外，还定义了3个伪操作符：.text、.data、.bss 。<br>
! 他们分别对应汇编程序产生的目标文件中的 3 个段：正文段(.text)、数据段(.data)、未初始化数据段(.bss)。<br>
! .text 用于标识正文段的开始位置，并把当前段切换到 text段<br>
! .data 用于标识数据段的开始位置，并把当前段切换到 data段<br>
! .bss 用于标识一个未初始化数据段的开始，并把当前段改变成 bss段<br>
**.text**<br>
**begtext:**<br>
**.data**<br>
**begdata:**<br>
**.bss**<br>
**begbss:**<br>
**.text**<br><br><br>



! 定义了一个赋值语句 “BOOTSEC = 0x07c0”<br>
! BOOTSEC 被定义为0x07c0，BOOTSEC是符号常量<br>
**BOOTSEC = 0x07c0**<br><br><br>



! 标识符 entry是保留关键字，它迫使链接器 ld86 在生成的可执行文件中包括其后面指定的标号 start。<br>
! 通常在链接多个目标文件生成一个可执行文件时，应该在其中一个汇编程序中用关键字 entry指定一个入口标号，用来调试。<br>
! 在正式文件中去掉<br>
**entry start**<br><br><br>


**start:**<br><br><br>


! 这是一个段间远跳转的语句，跳转到下一条指令<br>
! 由于当 BIOS把程序加载到物理内存 0x7c00处并跳转到该处时，所有段寄存器(包括 CS)默认值都为0，即 CS：IP=0x7c00<br>
! 使用段间远跳转 是为了给 CS赋段值 0x7c0。语句执行后，CS：IP=0x07C0:0X0005。 0x7c0 等于 0x07c0。<br>
	**jmpi	go,BOOTSEC !段间跳转**<br><br><br>


! 这两条语句分别给 DS 和 ES 段寄存器赋值，让它们都指向 0X7C0段。好处是方便对于程序中的数据(字符串) 进行寻址<br>
! AX、BX、CX、DX这四个主要用于存放数据，称为数据寄存器。数据寄存器按16位使用时，主要用于存放数据，也可临时时用于存放地址。<br>
**go:	mov	ax,cs**<br>
	**mov	ds,ax**<br>
	**mov	es,ax**<br><br><br>


! MOV指令用于把 ah 寄存器中 0x7c0 段值的高字节(0x07) 存放到内存中字符串 msgl最后一个 '.'位置处。<br>
! 这么做将导致 BIOS中断在显示字符时，鸣叫一声。并且说明间接操作数的用法。书中p36页列举出其他寻址方式。<br>
	**mov	[msgl+17],ah**<br><br><br>


! 下面五个语句分别用于把立即数放到相应寄存器中。<br>
! 立即数前一定要加‘#’，否则将作为内存地址使用，从而让语句变成绝对寻址语句。<br>
! 五个语句的意思分别是：<br>
! 1.一共显示20个字符；<br>
! 2.字符串将显示在屏幕第17行，第5列处；<br>
! 3.字符显示属性为红色；<br>
! 4.指向要显示的字符串(中断调用要求)；<br>
! 5.写字符串，并移动光标到串结尾处。<br>
	**mov	cx,#20**<br>
	**mov	dx,#0x1004**<br>
	**mov	bx,#0x000c**<br>
	**mov	bp,#msgl**<br>
	**mov	ax,#0x1301**<br><br><br>


! BIOS 屏幕显示中断调用 int 0x10, 使用其功能19(0x13)、子功能1(0x01)<br>
! 该中断作用是，把一字符串(msgl)写到屏幕指定位置处。<br>
	**int	0x10**<br><br><br>


! 该语句是跳转语句，跳转到loop1语句中，可以看出这是一个死循环<br>
! 采用死循环是为了让显示内容能够停留在屏幕上而不被删除。<br>
**loop1:	jmp	loop1**<br><br><br>


! 这两条语句定义了字符串 msgl。<br>
! 定义字符串需要使用伪操作符 ‘.ascii’，并且需要使用双引号括住字符串。这个伪操作符还会自动在字符串后添加一个NULL(0)字符。<br>
! 第二条语句定义了回车和换行(13,10)字符，定义字符需要是使用伪操作符 ‘.byte’，并且需要使用单引号把字符括住。当然也可以使用字符的ASCII 码(13,10)<br>
**msgl:	.ascii	"Loading system ..."**<br>
	**.byte	13,10**<br><br><br>


! 伪操作符语句".org" 定义了当前汇编的位置。<br>
! 这条语句会把汇编器编译过程中当前段的 位置计数器 给调整为该伪操作符语句上给出的值。<br>
! 它把位置计数器设为 510，并在第二条语句放置了有效引导扇区标志字 0xAA55。<br>
**.org 510**<br>
	**.word 0xAA55**<br><br><br>


! 放置了三个标号endtext、enddata、endbss，用来表示三个段的结束位置。<br>
! 这么设置可以用来在链接多个目标模块时，区分各个模块中各段的开始和结束位置。<br>
**.text**<br>
**endtext:**<br>
**.data**<br>
**enddata:**<br>
**.bss**<br>
**endbss:**<br><br><br>






































