---
layout: post
title:  "[Unp]Chapter 24"
subtitle: "带外数据"
date:   2019-07-19 01:00:00 +0800
categories: [unp]
---


# 概述

许多传输层有 带外数据 （out-of-band  data）的概念，也称它为 经加速数据（expedited data）。

带外数据的想法是；在一个连接的某端发生了重要事情，该端希望迅速通告它对端。“迅速” 意味着这种通知会在排队等待发送的数据（等待的数据称“带内数据”）之前发送。

因此，带外数据的一个特性是，它具有比普通数据更高的优先级。同时，带外数据会被映射到已有的连接当中。

<br><br>

# TCP 带外数据

TCP 没有真正意义上的带外数据。不过，可以通过紧急模式（urgent mode）来实现。

<br><br>

**从发送端的角度观察带外数据的发送**

假设一个进程往一个 TCP 套接字的发送缓冲区中写入 N 字节数据，并且标记出来。如下图：

![](/images/Unp/UNP_24/UNP_1.png)

接着，该进程以 MSG_OOB 标记调用 send 函数，它写出一个含有 ASCII 字符 a 的单字节第外数据：

![](/images/Unp/UNP_24/UNP_2.png)

最后，TCP 把这个数据放置在套接字发送缓冲区的下一个可用位置。并且， 在 OOB 标志的下一个位置中，设置该连接的 TCP 紧急指针（urgent pointer）。如下图：

![](/images/Unp/UNP_24/UNP_3.png)

TCP 紧急指针对应一个 TCP 序列号，它是最后一个数据字节对应的序列号加 1。其中的  “最后一个数据字节”  指的是，使用 MSG_OOB 标志写出的数据字节。（即，带外字节）

<br><br>

**TCP 紧急模式的一个重要特性**

TCP 首部指出发送端进入紧急模式，即，伴随紧急偏移的 URG 标志（携带紧急指针）已经设置。但是，紧急指针所指的实际数据字节，它不一定会伴随 URG 发送出去。

即使因为接收端的套接字接收缓冲区已满，导致向其 TCP 发送端通告一个值为 0 的窗口，紧急通知照样发送出去，但是它不会伴随任何数据。

由于这个特性，有很多应用程序使用 TCP 紧急模式。哪怕数据的流动会因为 TCP 的流量控制而停止，但是紧急通知却总是能发送到对端 TCP。

<br><br>

**关于 “紧急指针” 和 “紧急偏移”**

上面特性提到在这两个术语，因此需要解释此含义。在 TCP 层次上，它们是不同的。TCP 首部的16位值称为 紧急指针 。它必须加上同一个首部中的序列号字段才能获得32位的紧急指针。

在同一个首部中，只有称为 URG 标志的位已经设置的前提下，TCP 才会检查紧急偏移。

<br><br>

**如果我们发送多字节的带外数据，情况会怎么样呢?**

![](/images/Unp/UNP_24/UNP_4.png)

在这个例子中，TCP 的紧急指针指向最后的字节紧后的位置，也就是说，最后的那个字节（字母c）被认为是带外字节。

<br>

---

<br>

**从接收端的角度观察带外数据的接收**

**（1）当收到一个设置了 URG  标志的分节时，接收端 TCP 检查紧急指针，用来确定它是否指向新的带外数据。**

发送端 TCP 往往发送多个含有 URG 标志的分节，并且此分节也含有多个紧急指针指向的同一个数据字节。在这些分节中，只有第一个到达的会导致通知接收进程有新的带外数据到达。

<br>

**（2）当有新的紧急指针到达时，接收进程被通知到。**

首先，内核给接收套接字的属主进程发送SIGURG信号。前提是，接收进程 或 其他进程 曾调用 fcntl 或 ioctl  为这个套接字建立了属主，而且该属主进程已经为这个信号建立了信号处理函数。

其次，如果接收进程阻塞在 select 调用中，用以等待这个套接字描述符出现一个异常条件的话，select调用就返回。

注意：只有一个OOB标记，如果新的 OOB 字节在旧的 OOB 字节被读取之前就到达，旧的 OOB 字节会被丢弃。

<br>

**（3）当实际数据字节（字节由紧急指针指向）到达接收端 TCP 时，该数据字节既可能被拉出带外，也可能被留在带内，即在线（inline）留存。**

<br>

* ### SO_OOBINLINE 套接字选项默认情况下是禁止的。

对于这样的接收端套接字，该数据字节并不放入套接字接收缓冲区，而是被放入该连接的一个独立的单字节带外缓冲区（TCPv2第986～988页）。

接收进程从单字节缓冲区读入数据的唯一方法是：指定 MSG_OOB 标志调用 recv、recvfrom 或 recvmsg。

<br>

* ### 如果接收进程开启了 SO_OOBINLINE 套接字选项。

由TCP紧急指针指向的 实际数据字节 会被留在 套接字接收缓冲区中。

这种情况下，接收进程不能指定 MSG_OOB 标志读入该数据字节。相反，接收进程通过检查该连接的带外标记（out-of-band mark），用以获悉何时访问到这个数据字节。

<br><br>

**接收进程会发生错误的各种情况：**

**（1）**如果接收进程请求读入带外数据（通过指定MSG_OOB标志），但是对端尚未发送任何带外数据，读入操作将返回EINVAL。

<br>

**（2）**在接收进程 被告知 对端发送了一个带外字节（通过SIGURG或select手段）的前提下。

如果接收进程试图读入该字节，但是，该字节尚未到达。那么读入操作将返回EWOULDBLOCK。

接收进程此时能做的是，从套接字接收缓冲区读入数据（要是没有存放这些数据的空间，可能还得丢弃它们），以便在该缓冲区中腾出空间，继而允许对端TCP发送出那个带外字节。

<br>

**（3）** 如果 接收进程 试图多次读入 同一个带外字节，读入操作将返回EINVAL。

<br>

**（4）**如果 接收进程 已经开启了SO_OOBINLINE套接字选项，后来试图通过 指定 MSG_OOB 标志 读入带外数据，读入操作将返回EINVAL。

<br><br>

# sockatmark 函数

在从套接字读入期间，接收进程通过调用 sockatmark 函数确定是否处于带外标记。

![](/images/Unp/UNP_24/UNP_5.png)

<br><br>

# 带外标记的四个特性：（综合前面提及的，并加入新的特性）

<br>

**（1）带外标记总是指向 紧随普通数据最后一个字节后面 的位置。**

这意味着

如果带外数据在线接收，并且下一个准备读入的字节，发送端是使用 MSG_OOB 标记发送它的话。那么，sockatmark 函数返回真。

如果 SO_OOBINLINE 套接字选项没有开启，并且下一个准备读入的字节，它是紧跟在带外数据后面发送到这里的话。那么，sockatmark 函数返回真。

<br><br>

**（2）读操作总是停在带外标记上（TCPv2第519～520页）。**

这意味着

假设在套接字接收缓冲区中有100个字节，不过在带外标记之前只有5个字节。如果进程执行一个请求100个字节的 read 调用，那么返回的是带外标记之前的5个字节。

这种在带外标记上强制停止读操作的做法，它使得进程能够调用 sockatmark 来确定缓冲区指针是否处于带外标记。

<br><br>

**（3）即使因为流量控制而停止发送数据了，TCP 仍然发送带外数据的通知（即它的紧急指针）。**

<br><br>

**（4）在带外数据到达之前，接收进程可能被通知，通知内容为发送进程已经发送了带外数据（使用 SIGURG 信号或通过 select ）。**

如果接收进程接着指定 MSG_OOB 调用 recv ，而带外数据却尚未到达，recv 将返回 EWOULDBLOCK 错误。

在**从接收端的角度观察带外数据的接收**中详细描述。

<br><br>

# 关于心搏函数的设计

讲解一个简单的心搏函数。这个函数的功能是，它可以发现对端主机 或 到对端的通信路径的过早失效。

<br><br>

**在讲解这些函数之前，必须提出一些警告：**

（1）如果使用 TCP 的保持存活特性（ SO_KEEPALIVE 套接字选项）来提供这种功能，那么 TCP 得在连接已经闲置2小时之后，它才发送一个保持存活探测段。

关于这种方法，接下来还有一个问题：如何把保持存活的参数改为一个小得多的值（往往是在秒钟的量级），以便更快地检测到失效。

尽管缩短 TCP 的保持存活的参数在许多系统上确实可行（见TCPv1的附录E），但是，这些参数通常是按照内核，而不是按照每个套接字维护的。因此改动它们将影响所有开启该选项的套接字。另外，保持存活选项的用意绝不是这个目的（高频率地轮询）。

<br>

（2）两个端系统之间短暂的连接性丢失并非总是坏事。

TCP一开始就设计成能够对付临时断连，比如，源自Berkeley的TCP实现将重传8～10分钟才放弃某个连接。较新的IP路由协议（例如 OSPF ）能够发现链接的失效，并且有可能在短时间内（譬如在秒钟量级上）启用候选的路径。

<br><br>

**我们使用 TCP 紧急模式周期地轮询**

客户每隔1秒钟向服务器发送一个带外字节。服务器收取该字节会导致它向客户发回一个带外字节。

每端都需要知道对端是否不复存在 或者 不再可达。客户和服务器每1秒钟就递增它们的 cnt 变量一次，每收到一个带外字节，然后把该变量重置为0。如果该计数器达到5，那就认定连接失效，也就是说本进程已有5秒钟没有收到来自对端的带外字节。

当有带外字节到达时，客户和服务器都使用 SIGURG 信号得以通知。

详情参考 UNP24-14的代码。







