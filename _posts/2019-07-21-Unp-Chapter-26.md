---
layout: post
title:  "[Unp]Chapter 26"
subtitle: "线程"
date:   2019-07-21 10:00:00 +0800
categories: [unp]
---


# 概述

父进程 accept 一个连接，fork 一个子进程，该子进程处理与该连接的客户之间的通信。尽管这种范式多少年来一直用得挺好。但是，fork 调用却存在一些问题：

<br>
（1）fork 是昂贵的。如今实现使用 写时复制（copy-on-write）的技术。在子进程切实需要自己的副本之前，它避免了把父进程的数据空间复制到子进程。然而即便有这样的优化措施， fork 仍然是昂贵的。

（2）fork 返回之后，父子进程之间信息的传递需要进程间通信（IPC）机制。

<br>

线程有助于解决这两个问题。线程有时称为 轻权进程（lightweight process），因为线程比进程 “权重轻些”，速度比进程的创建快10～100倍。

不过，在同一进程内，所有线程共享相同的全局内存。这使得线程之间易于共享信息，然而这种简易性，它会产生同步（synchronization）问题。

<br>

此外，同一进程内的所有线程除了共享全局变量外还共享：

* 进程指令；
* 大多数数据；
* 打开的文件（即描述符）；
* 信号处理函数和信号处置；
* 当前工作目录；
* 用户ID和组ID。

不过每个线程有各自的：
* 线程ID；
* 寄存器集合，包括程序计数器和栈指针；
* 栈（用于存放局部变量和返回地址）；
* errno；
* 信号掩码；
* 优先级。

<br>

本文章讲解的是 POSIX 线程，也称为 Pthread。

<br><br>

# 基本线程函数：创建和终止

讲解5个基本线程函数。

<br>

**pthread_create 函数**

当一个程序由 exec 启动执行时，称为 初始线程（initial thread）或 主线程（main thread）的单个线程就创建了。其余线程则由 pthread_create 函数创建。

![](/images/Unp/UNP_26/UNP_1.png)

**一个进程内的每个线程都由一个线程 ID（thread ID）标识，其数据类型为 pthread_t （往往是unsigned int）。**如果新的线程成功创建，其 ID 就通过 tid 指针返回。

<br>

**每个线程都有许多属性（attribute）：**优先级、初始栈大小、是否应该成为一个守护线程等等。这可以在创建线程时，我们通过初始化一个取代默认设置的 pthread_attr_t 变量，把它用来指定这些属性。通常情况下，我们采纳默认设置，这时我们把 attr 参数指定为空指针。

<br>

**创建一个线程时，我们最后指定的参数是，由该线程执行的函数及其参数。**该线程通过调用这个函数开始执行，然后，显式地终止（通过调用pthread_exit），或者隐式地终止（通过让该函数返回）。

该函数的地址由func参数指定，该函数的唯一调用参数是指针 arg。

如果我们需要给该函数传递多个参数，我们就得把它们打包成一个结构，然后把这个结构的地址作为单个参数传递给这个起始函数.

<br>

**注意func和arg的声明。** func 所指函数作为参数，它接受一个通用指针(void * )，又作为返回值返回一个通用指针(void * )。这使得我们可以把一个指针传递给线程（指针指向我们期望的任何内容），又允许线程返回一个指针（指针同样指向我们期望的任何内容）。

<br>

通常情况下，Pthread函数的返回值成功时为0，出错时为某个非0值。与套接字函数及大多数系统调用出错时返回-1

























































































