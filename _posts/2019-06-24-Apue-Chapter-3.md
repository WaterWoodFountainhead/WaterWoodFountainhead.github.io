---
layout: post
title:  "[Apue]Chapter 3"
subtitle: "文件IO"
date:   2019-06-24 00:38:32 +0800
categories: [apue]
---



# 文件描述符
概念：所有打开的文件都通过文件描述符，它是一个非负整数。

原理 ：当打开一个现有文件或创建一个新文件时，内核向进程返回一个文件描述符。当读写一个文件时，使用open或creat返回的文件描述符标识该文件，将其作为参数传给read或write。

补充：每个进程创建的时候都会打开三个文件：stdin(描述符0)，stdout(描述符1)和stderr(描述符2)。这三个文件对应符号常量 STDIN_FILENO、STDOUT_ FILENO、STDERR_ FILENO。

<br><br>

# 函数Open 和 Openat

![](/images/Apue/APUE_3/Unix3.3.1.png)

( “...”参数表示剩下的参数是可变的)

作用：调用Open或Openat函数可以打开或创建一个文件。不过，Openat的出现是希望解决两个问题：

（1）让线程可以使用相对路径名打开目录中的文件，而不局限于只能打开当前工作目录。

（2）避免TOCTTOU错误，也称time-of-check-to-time-of-use (两个函数调用，其中一个的调用依赖另外一个调用的结果，那么这是不好的。)

<br><br>

# 函数Creat

![](/images/Apue/APUE_3/Unix3.4.1.png)

作用：调用creat函数创建一个新文件，并用只写方式打开。

<br><br>

# 函数Close

![](/images/Apue/APUE_3/Unix3.5.1.png)

作用：调用close函数关闭进程中一个打开的文件。关闭一个文件时还会释放该进程加在该文件上的所有记录锁。

需要注意的是，内核中的资源不会被立刻释放掉，假设有一个或多个进程的多个文件文件描述符指向同一个内核的资源，那么只有当最后一个文件描述符被close时，内核的资源才会被释放。

<br><br>

# 函数Lseek

![](/images/Apue/APUE_3/Unix3.6.1.png)

作用：调用lseek可以显示地为一个打开文件设置偏移量。

由于Lseek只将当前的文件偏移量记录在内核中，所以并不会引起任何I/O操作。而且，偏移量是可以大于文件的当前长度。如果在偏移量后写入字节将加长该文件，就会在文件中构成一个空洞，没有被实际写入文件的所有字节由0 表示。空洞是否占用硬盘空间是由文件系统决定的。因为lseek使用的偏移量是用off_t类型表示的，所以实现需要根据各自平台选择大小合适的数据类型。

<br><br>

# 函数Read

![](/images/Apue/APUE_3/Unix3.7.1.png)

作用：调用read函数从打开文件中读数据。

<br><br>

# 函数Write

![](/images/Apue/APUE_3/Unix3.8.1.png)

作用：调用 write 函数向打开文件写数据。

<br>

由于wirte是文件I/O，文件I/O是一种带有缓冲区的操作函数，而在实际的操作过程中，势必会出现阻塞与非阻塞(网络)相关的问题：

write函数首先将进程需要发送的数据先放在进程缓冲区中，然后向socket的发送缓冲区进行拷贝。但是，可能会出现这样情况，即当进程缓冲区中的数据量大于此时发送缓冲区中所能接受的数据量时，若此时处于阻塞模式，应用进程将会被挂起，直到进程缓冲区中的数据全部拷贝到发送缓冲区中，注意此时内核也不会返回write函数，因此，在阻塞模式下，若write函数正常返回，这也并不代表数据已经完成被对方进程接收，至多只能说明数据已经被发送缓冲区完全接受；若是处于非阻塞模式，此时write操作将会失败，内核会立即返回EAGAIN错误，有时候在某些地方说会返回EWOULDBLOCK错误，其实它们都一样，只是分别用于不同的系统，前者主要是出现于GNU系统，后者主要出现在类BSD系统。

<br><br>

# 文件共享

Unix系统支持在不同进程间共享打开文件。内核用三种数据结构来表示打开文件，如图所示：

![](/images/Apue/APUE_3/Unix3.10.1.png)

（1）：文件描述符表，它里面包含 标志(文件描述符标志)和文件指针(指向一个文件表项的指针)。

（2）：文件表，它里面包含 文件状态标志(读，写，添写，同步和非阻塞等)，当前文件偏移量和v节点指针(指向该文件v节点表项的指针)。

（3）：v节点表项，它里面包含文件类型和对此文件进行各种操作函数的指针。同时，它还包含i节点。这些信息的作用是在打开文件时从磁盘上读入内存。注意，Linux没有使用v节点。

<br>如果两个独立的进程各自打开了同一文件，文件关系如下图：

![](/images/Apue/APUE_3/Unix3.10.2.png)

>之所以每个进程都能获得自己的进程和文件表项，是因为可以使每个进程都有自己对该文件的当前偏移量。文件描述符标志只应用于一个进程的一个描述符;而文件状态标志则应用于指向给定的文件表项的任何进程中的所有描述符。

对上图的进一步说明：

（1）A进程每次写入后，在文件表项中的当前文件偏移量将会增加(由写入的字节数决定)。如果这导致当前文件偏移量超出了当前文件超度，那么该文件将会加长。

（2）如果用具有追加写标志的文件执行写操作时，对应标志(O_APPEND) 会被设置到文件表项的文件状态标志中。当进行写操作时，文件表项的当前文件偏移量会被设置为i节点表项中的当前文件长度。

（3）如果一个文件用lseek函数定位到文件当前的尾端，那么文件表项的当前文件偏移量会被设置为i节点表项中的当前文件长度。

<br><br>

# 原子操作

原子操作（atomic operation）指的是由多步组成的一个操作。如果该操作原子地执行，则要么执行完所有步骤，要么一步也不执行，不可能只执行所有步骤的一个子集。

<br>

XSI扩展允许原子性地定位并执行I/O——Pread和Pwrite：

![](/images/Apue/APUE_3/Unix3.11.1.png)

调用praed相当于调用lseek后调用read，注意：（Pwrite与Pread类似）

（1）调用pread时，无法中断其定位和读操作。

（2）不更新当前文件偏移量，也就是从固定位置读取。

<br><br>

# 函数Dup和Dup2

![](/images/Apue/APUE_3/Unix3.12.1.png)

作用：可用来复制一个现有的文件描述符。如下图所示：（Dup后的文件数据结构）

![](/images/Apue/APUE_3/Unix3.12.2.png)

注意：调用dup函数等同于先调用<label style="color:red">fcntl(fd, F_DUPFD, 0)</label> ，而调用 dup2 等同于调用 <label style="color:red">close(fd2)</label> 和 <label style="color:red">fcntl(fd, F_DUPFD, fd2)</label> 。 Dup2 是一个原子操作，它与 funtl 有一些不同的 ettno 。

<br><br>

# 函数Sync、Fsync和Fdatasync

首先要引入一个概念：延迟写，即，传统的UNIX实现在内核中设有缓冲区高速缓存或页面高速缓存，大多数磁盘I/O都通过缓冲进行。

我们将数据写入文件时，内核通常先将该数据复制到其中一个缓冲区中。如果该缓冲区尚未写满，则并不将其排入输出队列。而是等待其写满或者当内核需要重用该缓冲区以便存放其他磁盘块数据时，再将该缓冲排入输出队列，然后待其到达队首时，才进行实际的I/O操作。

延迟写减少了磁盘读写次数，但是却降低了文件内容的更新速度，使得欲写到文件中的数据在一段时间内并没有写到磁盘上。当系统发生故障时，这种延迟可能造成文件更新内容的丢失。为了保证磁盘上实际文件系统与缓冲区高速缓存中内容的一致性，UNIX系统提供了Sync、Fsync和Fdatasync三个函数。

![](/images/Apue/APUE_3/Unix3.13.1.png)

sync 只是将所有修改过的块缓冲区排入写队列，然后就返回，它并不等待实际写磁盘操作结束。

一般情况下，名为 update 的系统守护进程周期性地调用（一般每隔 30 秒） sync 函数。这就保证了定期冲洗（flush）内核的块缓冲区。命令 sync(1)也调用 sync 函数。

Fsync 函数只对由文件描述符 fd 指定的一个文件起作用，并且等待写磁盘操作结束才返回。Fsync 可用于数据库这样的应用程序，这种应用程序需要确保修改过的块立即写到磁盘上。

Fdatasync 函数类似于 fsync，但它只影响文件的数据部分。而除数据外， fsync 还会同步更新文件的属性。我经过查阅资料后，由于篇幅原因，因此自己另整理了一份：（点击下面标题进入）

[《深刻探讨Sync、Fsync和Fdatasync》](https://waterwoodfountainhead.github.io/apue/2019/06/23/Apue-Linux-Sync-Fsync-and-Fdatasync.html)

<br><br>

# 函数Fcntl

![](/images/Apue/APUE_3/Unix3.14.1.png)

作用：(关于cmd参数的详解见APUE p66)

（1）复制一个已有的描述符（cmd = F_DUPFD 或 F_DUPFD_CLOEXEC）。

（2）获取/设置文件描述符标志（cmd = F_GETFD 或 F_SETFD）。

（3）获取/设置文件状态标志（cmd = F_GETFL 或 F_SETFL）。

（4）获取/设置异步 I/O 所有权（cmd = F_GETOWN 或 F_SETOWN）。

（5）获取/设置记录锁（cmd = F_GETLK、 F_SETLK 或 F_SETLKW）。

<br>

**关于同步写和延迟写**

当支持同步写时，系统时间和时钟时间会显著增加。如果同步写所用的系统时间不比延迟写增加的多时，要么操作系统对延迟写和同步写操作的工作量相同;要么 O_SYNC 标志并没有起到期望的作用，在这种情况下，Linux 操作系统并不允许我们用 fcntl 设置 O_SYNC 标志，而是显示失败但没有返回出错（如果在文件打开时能指定该标志，我们应该遵重这个标志的）。

同步写比延迟写所消耗的时间增加了很多，而且在同步写后再调用函数 fsync 并不产生测量结果上的显著差别。不过，在延迟写后增加一个 fsync 函数调用，测量结果的差别也不大。其可能原因是，在向某个文件写入新数据时，操作系统已经将以前写入的数据都冲洗到了磁盘上，所以在调用函数 fsync 时只需要做很少的工作。

<br><br>

# 函数ioctl

![](/images/Apue/APUE_3/Unix3.15.1.png)

作用：它是设备驱动程序中设备控制接口函数，一个字符设备驱动通常会实现设备打开、关闭、读、写等功能，在一些需要细分的情境下，如果需要扩展新的功能，通常以增设 ioctl() 命令的方式实现。

<br>

**对于用户态程序的ioctl**

在实际应用中，ioctl 最常见的 errorno 值为 ENOTTY（error not a typewriter），顾名思义，即第一个参数 fd 指向的不是一个字符设备，不支持 ioctl 操作，这时候应该检查前面的 open 函数是否出错或者设备路径是否正确。

<br>

**对于驱动程序的ioctl**
![](/images/Apue/APUE_3/Unix3.15.2.png)
unlocked_ioctl，顾名思义，应该在无大内核锁（BKL）的情况下调用；compat_ioctl，compat 全称 compatible（兼容的），主要目的是为 64 位系统提供 32 位 ioctl 的兼容方法，也是在无大内核锁的情况下调用。

<br><br>

# /dev/fd 目录

概念：/dev/fd文件主要由shell使用，它允许作为路径名被程序作为参数调用。打开文件/dev/fd/n 等效于复制描述符n (假设描述符n是打开的)。

如果你在一个程序调用creat，并且路径名参数是<label style="color:red">/dev/fd/1</label>。虽然，程序可以工作，但是，你一定要小心。你在 Linux 上这么做必须非常小心，因为 Linux 实现使用指向实际文件的符号链接，所以在<label style="color:red">/dev/fd</label>文件上使用 creat 会导致底层文件被截断。<label style="color:red">/dev/fd</label> 在Linux实现中是个例外，它把文件描述符映射成指向底层物理文件的符号链接。
