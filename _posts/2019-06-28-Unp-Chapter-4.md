---
layout: post
title:  "[Unp]Chapter 4"
subtitle: "基本TCP套接字编程"
date:   2019-06-28 10:00:00 +0800
categories: [unp]
---

# 概述

下图给出在一对TCP客户与服务器进程之间发生的一些典型事件的时间表。

![](/images/Unp/UNP_4/UNP4.1.1.png)

<br><br>

# socket 函数

为了执行网络I/O，进程必须做的第一件事情就是调用socket函数，指定通信协议类型（使用IPv4的TCP、使用IPv6的UDP、Unix域字节流协议等）。

![](/images/Unp/UNP_4/UNP4.2.1.png)

**family参数**：它指明协议族，它是下图所示的某个常值。该参数也往往被称为协议域。

![](/images/Unp/UNP_4/UNP4.2.2.png)

<br>

**type参数**：指明套接字类型，它是下图中所示的某个常值。

![](/images/Unp/UNP_4/UNP4.2.3.png)

<br>

**protocol参数**：应设为下图所示的某个协议类型常值，或者设为0，以选择所给定family和type组合的系统默认值。

![](/images/Unp/UNP_4/UNP4.2.4.png)

<br>

不过，并非所有套接字 family 与 type 的组合都是有效的，下图给出了一些有效的组合和对应的真正协议。其中标为“是”的项也是有效的，但还没有找到便捷的缩略词。而空白项则是无效组合。

![](/images/Unp/UNP_4/UNP4.2.5.png)

<br><br>

**对比 AF_xxx 和 PF_xxx**

AF_ 前缀表示地址族，PF_ 前缀表示协议族。

头文件<sys/socket.h>中为一给定协议定义的 PF_ 值总是与此协议的 AF_ 值相等。尽管这种相等关系并不一定永远成立。为与现存代码保持一致，我们仅使用 AF_ 常值，不过，在调用 socket 时，我们可能会碰到 PF_ 值。

<br><br>

# connect 函数

![](/images/Unp/UNP_4/UNP4.3.1.png)

（1）sockfd是由socket函数返回的套接字描述符，第二个、第三个参数分别是一个指向套接字地址结构的指针和该结构的大小。

<br>

（2）客户在调用函数connect前不必非得调用bind函数（我们在下一节介绍该函数），因为如果需要的话，内核会确定源IP地址，并选择一个临时端口作为源端口。

<br>

（3）如果是TCP套接字，调用connect函数仅在连接建立成功或出错时才返回，其中出错返回可能有以下几种情况：

①若TCP客户没有收到SYN分节的响应，则返回ETIMEDOUT错误。当我们调用connect函数时，4.4BSD内核发送一个SYN，若无响应则等待6s后再发送一个，若仍无响应则等待24s后再发送一个（TCPv2第828页）。若总共等了75s后，它仍未收到响应则返回本错误。

<br>

②若对客户的SYN的响应是RST（表示复位），则表明该服务器主机在我们指定的端口上没有进程在等待与之连接（例如服务器进程也许没在运行）。这是一种硬错误（hard error），客户一接收到RST就马上返回ECONNREFUSED错误。

RST是TCP在发生错误时发送的一种TCP分节。产生RST的三个条件是：目的地为某端口的SYN到达，然而该端口上没有正在监听的服务器（如前所述）；TCP想取消一个已有连接；TCP接收到一个根本不存在的连接上的分节。（TCPv1第246～250页有更详细的信息。）

<br>

③若客户发出的SYN在中间的某个路由器上引发了一个“destination unreachable”（目的地不可达）ICMP错误，则认为是一种软错误（soft error）。

客户主机内核保存该消息，并按第一种情况中所述的时间间隔继续发送SYN。若在某个规定的时间（4.4BSD规定75s）后仍未收到响应，则把保存的消息（即ICMP错误）作为EHOSTUNREACH或ENETUNREACH错误返回给进程。

还有两种情形也是有可能的：一是按照本地系统的转发表，根本没有到达远程系统的路径；二是connect调用根本不等待就返回。

<br><br>

**通过一个例子更好的理解上面三种情况：**

首先指定本地主机（127.0.0.1），它正在运行对应的时间获取服务器程序，我们观察正常的输出：

![](/images/Unp/UNP_4/UNP4.3.2.png)

接着指定本地子网（192.168.1/24）上其主机ID（100）并不存在的一个IP地址，这样当客户主机发出ARP请求（要求那个不存在的主机响应以其硬件地址）时，它将永远收不到ARP响应：

![（err_sys函数以直观可读的字符串消息表示了ETIMEDOUT错误的含义）](/images/Unp/UNP_4/UNP4.3.3.png)

然后，我们指定一个没有运行时间获取服务器程序的主机（其实是一个本地路由器）：

![（服务器主机立刻响应以一个RST分节）](/images/Unp/UNP_4/UNP4.3.4.png)

最后，我们指定一个因特网中不可到达的IP地址，那么路由器就会返回主机不可达的ICMP错误：

![（connect也在等待规定的一段时间之后才返回EHOSTUNREACH错误）](/images/Unp/UNP_4/UNP4.3.5.png)

<br><br>

# bind 函数

bind 函数把一个本地协议地址赋予一个套接字。对于网际网协议，协议地址是32位的IPv4地址或128位的IPv6地址与16位的TCP或UDP端口号的组合。

![](/images/Unp/UNP_4/UNP4.4.1.png)

第二个参数是一个指向特定于协议的地址结构的指针，第三个参数是该地址结构的长度。从bind函数返回的一个常见错误是EADDRINUSE（“Address already in use”，地址已使用）。

<br><br>

对于TCP，调用bind函数可以指定一个端口号，或指定一个IP地址，也可以两者都指定，还可以都不指定。因此，有两点需要注意：

（1）如果一个TCP客户或服务器未曾调用 bind捆绑一个端口，当调用 connect 或 listen 时，内核就要为相应的套接字选择一个临时端口。让内核来选择临时端口对于TCP客户来说是正常的，除非应用需要一个预留端口（图2-10）；然而对于TCP服务器来说却极为罕见，因为服务器是通过它们的众所周知端口被大家认识的。

不过，有一个例外——远程过程调用（Remote Procedure Call，RPC）服务器。由内核为它们的监听套接字选择一个临时端口，而该端口随后通过RPC端口映射器进行注册。客户在connect这些服务器之前，必须与端口映射器联系以获取它们的临时端口。这种情况也适用于使用UDP的RPC服务器。

<br>

（2）进程可以把一个特定的IP地址捆绑到它的套接字上，不过这个IP地址必须属于其所在主机的网络接口之一。

对于TCP客户端来说，这就为在该套接字上发送的IP数据报指派了源IP地址。

>对于TCP服务器，这就限定该套接字只接收那些目的地为这个IP地址的客户连接。TCP客户通常不把IP地址捆绑到它的套接字上。当连接套接字时，内核将根据所用外出网络接口来选择源IP地址，而所用外出接口则取决于到达服务器所需的路径（TCPv2第737页）。

>如果TCP服务器没有把IP地址捆绑到它的套接字上，内核就把客户发送的SYN的目的IP地址作为服务器的源IP地址（TCPv2第943页）。

<br><br>

**下图汇总了根据预期的结果，来设置sin_addr和sin_port或者sin6_addr和sin6_port的值：**

![](/images/Unp/UNP_4/UNP4.4.2.png)

对于上图的一些说明：

（1）如果指定端口号为0，内核会在bind被调用时选择一个临时端口。然而，如果指定IP地址为通配地址，内核将会等到（TCP）套接字已连接 或 已经在（UDP）套接字上发出数据报时，它才选择一个本地IP地址。

对于IPv4来说，通配地址由常值INADDR_ANY来指定，其值一般为0（由于是网络字节序还是主机字节序，INADDR_ANY的值（为0）都一样，因此使用htonl并非必需）。它告知内核去选择IP地址。

![](/images/Unp/UNP_4/UNP4.4.3.png)

<br>

（2）对于IPv6，我们就不能这么做了，因为128位的IPv6地址是存放在一个结构中的。（在C语言中，赋值语句的右边无法表示常值结构。）为了解决这个问题，我们改写为：

![](/images/Unp/UNP_4/UNP4.4.4.png)

系统 预先 分 配 in6addr_any 变量并将其 初始 化为常值 IN6ADDR_ANY_INIT。头文件<netinet/in.h>中含有in6addr_any的extern声明。

<br>

（3）如果让内核来为套接字选择一个临时端口号，那么必须注意，函数bind并不返回所选择的
值。实际上，由于bind函数的第二个参数有const限定词，它无法返回所选之值。为了得到内
核所选择的这个临时端口值，必须调用函数getsockname来返回协议地址。

<br><br>

# listen 函数

listen函数仅由TCP服务器调用，它做两件事情：

（1）当socket函数创建一个套接字时，它被假设为一个主动套接字，而 listen 函数把这个未连接的套接字转换成一个被动套接字，指示内核应接受指向该套接字的连接请求。

根据下图，调用listen导致套接字从CLOSED状态转换到LISTEN状态。

![](/images/Unp/UNP_4/UNP4.5.1.png)

<br>

(2) 本函数的第二个参数规定了内核应该为相应套接字排队的最大连接个数。

![（本函数通常应该在调用socket和bind这两个函数之后，并在调用accept函数之前调用）](/images/Unp/UNP_4/UNP4.5.2.png)

<br><br>

**为了理解其中的backlog参数，我们必须认识到内核为任何一个给定的监听套接字维护两个队列：**

(1) 未完成连接队列（incomplete connection queue），每个这样的SYN分节对应其中一项：已由某个客户发出并到达服务器，而服务器正在等待完成相应的TCP三路握手过程。这些套接字处于SYN_RCVD状态。

(2) 已完成连接队列（completed connection queue），每个已完成TCP三路握手过程的客户对
应其中一项。这些套接字处于ESTABLISHED状态。

这两种状态如下图所示：

![](/images/Unp/UNP_4/UNP4.5.3.png)

<br><br>

**关于这两个队列的处理，以下几点需要考虑：**

（1）listen函数的backlog参数曾被规定为这两个队列总和的最大值。

（2）源自Berkeley的实现给backlog增设了一个模糊因子（fudge factor）。

>把它乘以1.5得到未处理队列最大长度（TCPv1第257页和TCPv2第462页）。举例来说，通常指定为5的backlog值实际上允许最多有8项在排队。

如果我们把backlog看成是内核能为某套接字排队的最大已完成连接数目，那么增加模糊因子的理由是，把队列中的未完成连接也计算在内。

<br>

（3）不要把backlog定义为0，因为不同的实现对此有不同的解释。如果你不想让任何客户连接到你的监听套接字上，那就关掉该监听套接字。

（4）在三路握手顺利完成的前提下，未完成连接队列中的任何一项的存留时间就是一个RTT。而RTT的值取决于特定的客户与服务器。

>TCPv3的14.4节指出，对于一个Web服务器，许多客户与单个服务器之间的中值RTT为187ms。（既然出现一些大值可能显著扭曲均值，对于该统计量通常使用中值。）

<br>

（5）现如今，服务器一天可能要处理几百万个连接，这个4.2BSD支持的最大值 (backlog价为5) 就根本不够了（TCPv3第187～192页）。繁忙的HTTP服务器必须指定一个大得多的backlog值，而且较新的内核必须支持较大的backlog值。

因此，指定较大backlog值的理由在于：随着客户SYN分节的到达，未完成连接队列中的项数可能增长，它们等着三路握手的完成。

<br>

（6）当一个客户端的SYN到达时，若这些队列是满的，服务端TCP就忽略该分节（TCPv2第930～931页），也就是不发送RST。这么做是因为：这种情况是暂时的，客户端TCP将重发SYN，期望不久就能在这些队列中找到可用空间。

另外，客户端无法区别响应SYN的RST究竟意味着 “该端口没有服务器在监听” ，还是意味着 “该端口有服务器在监听，不过它的队列满了”。

<br>

（7）在三路握手完成之后，但在服务器调用accept之前到达的**数据**应在服务器TCP中排队，最大数据量为相应已连接套接字的接收缓冲区大小。

<br><br>

**实现原理**

每当在未完成连接队列中创建一项时，来自监听套接字的参数就复制到即将建立的连接中。连接的创建机制是完全自动的，无需服务器进程插手。

下图展示了用这两个队列建立连接时所交换的分组。

![](/images/Unp/UNP_4/UNP4.5.4.png)

（1）当来自客户的SYN到达时，TCP在未完成连接队列中创建一个新项。

（2）然后响应以三路握手的第二个分节：服务器的SYN响应，其中捎带对客户SYN的ACK。

（3）这个新项一直保留在未完成连接队列中，直到三路握手的第三个分节（客户对服务器SYN的ACK）到达或者该项超时为止。（源自Berkeley的实现为这些未完成连接的项设置的超时值为75 s。

（4）如果三路握手正常完成，该项就从未完成连接队列移到已完成连接队列的队尾。

（5）当进程调用 accept 时，已完成连接队列中的队头项将返回给进程，或者如果该队列为空，那么进程将被投入睡眠，直到TCP在该队列中放入一项才唤醒它。

<br><br>

**不同的操作系统，backlog 的意义解释也是不同的，如下图：**

![FreeBSD的算法是backlog值本身加1](/images/Unp/UNP_4/UNP4.5.4.png)

<br><br>

# accept 函数

accept函数由TCP服务器调用，用于从已完成连接队列队头返回下一个已完成连接。如果已完成连接队列为空，那么进程被投入睡眠（假定套接字为默认的阻塞方式）。

![](/images/Unp/UNP_4/UNP4.6.1.png)

关于accept 函数有关说明：

（1）参数 cliaddr 和 addrlen 用来返回已连接的对端进程（客户）的协议地址。

<br><br>

（2）addrlen是[值—结果参数](https://waterwoodfountainhead.github.io/unp/2019/06/27/Unp-Chapter-3.html)：调用前，我们将由 * addrlen 所引用的整数值置为由cliaddr所指的套接字地址结构的长度。返回时，该整数值即为由内核存放在该套接字地址结构内的确切字节数。

<br><br>

（3）如果accept成功，那么其返回值是由内核自动生成的一个全新描述符，代表与所返回客户
的TCP连接。

<br><br>

（4）accept的第一个参数是监听套接字（listening socket）描述符（由socket创建，随后用作bind和listen的第一个参数的描述符）。它的返回值是已连接套接字（connected socket）描述符。

<br>

**区分这两个套接字非常重要：**

监听套接字：一个服务器通常仅仅创建一个监听套接字，它在该服务器的生命期内一直存在。

已连接套接字：内核为服务器进程接受的客户连接创建一个已连接套接字（也就是说对于它的TCP三路握手过程已经完成）。当服务器完成对某个给定客户的服务时（调用close），相应的已连接套接字就被关闭。

<br><br>

（5）accept 函数最多返回三个值：

①可能是新套接字描述符。

②可能是出错指示的整数、客户进程的协议地址（由 cliaddr指针参数所指）以及该地址的大小（由 addrlen指针参数所指）。

<br><br>

# 并发服务器

使用 fork创建一个典型的并发服务器轮廓，如图：

![](/images/Unp/UNP_4/UNP4.8.1.png)

当一个连接建立时，accept返回，服务器接着调用fork，然后由子进程服务客户（通过已连接套接字connfd），父进程则等待另一个连接（通过监听套接字listenfd）。既然新的客户由子进程提供服务，父进程就关闭已连接套接字。

<br>

**为什么上图程序中父进程对 connfd 调用 close 没有终止它与客户的连接呢？**

我们知道每个文件或套接字都有一个引用计数。socket返回后与listenfd关联的文件表项的引用计数值为1。accept返回后与connfd关联的文件表项的引用计数值也为1。

在fork返回后，这两个描述符就在父进程与子进程间共享（也就是被复制），因此与这两个套接字相关联的文件表项各自的访问计数值均为2。

当父进程关闭connfd时，它只是把相应的引用计数值从2减为1。该套接字真正的清理和资源释放
要等到其引用计数值到达0时才发生。既然引用计数值仍大于0，这个close调用并不引发TCP的四分组连接终止序列。这会在稍后子进程也关闭connfd时发生。

<br>

**如果父进程对每个由accept返回的已连接套接字都不调用close，那么并发服务器中将会发生什么？**

没有一个客户连接会被终止。父进程最终将耗尽可用描述符，因为任何进程在任何时刻可拥有的打开着的描述符数通常是有限制的。同时，这将妨碍TCP连接终止序列的发生，导致连接一直打开着。

<br><br>

# close 函数

Unix close函数也用来关闭套接字，并终止TCP连接。

![](/images/Unp/UNP_4/UNP4.9.1.png)

close的默认行为是把该套接字标记成已关闭，然后立即返回到调用进程。该套接字描述符不能再由调用进程使用，也就是说它不能再作为read或write的第一个参数。

然而TCP将尝试发送（已排队并等待发送到对端的）数据，发送完毕后正常进行TCP连接终止序列。

<br><br>

# getsockname 和 getpeername 函数

![](/images/Unp/UNP_4/UNP4.10.1.png)

getsockname函数：返回与某个套接字关联的本地协议地址。

getpeername 函数：返回与某个套接字关联的外地协议地址。

<br>

**注意：**

这两个函数的最后一个参数都是 **值-结果参数**。这就是说，这两个函数都得装填由 localaddr 或 peeraddr指针所指的套接字地址结构。

<br><br>

需要这两个函数的理由如下：

（1）在一个没有调用 bind函数的TCP客户端上，connect成功返回后，getsockname用于返回（由内核赋予）该连接的本地IP地址和本地端口号。

<br>

（2）在以端口号 0 调用bind（告知内核去选择本地端口号）后，getsockname用于返回由内核赋予的本地端口号。

<br>

（3）getsockname可用于获取某个套接字的地址族。例如：

```c
1 int
2 sockfd_to_family(int sockfd)
3 {
4	struct sockaddr_storage ss;
5	socklen_t len;
6
7	len = sizeof(ss);
8	if (getsockname(sockfd, (SA *) &ss, &len) < 0)
9		return(-1);
10	return(ss.ss_family);
11 }
```

第5行：由于不清楚要分配的套接字地址结构的类型，于是采用sockaddr_storage这个通用结构。因为它能够承载系统支持的任何套接字地址结构。

第7-10行：我们调用getsockname返回地址族。既然POSIX规范允许对未绑定的套接字调用getsockname，该函数应该适合任何已打开的套接字描述符。

<br>

（4）在一个以通配IP地址调用bind的TCP服务器上，与某个客户的连接一旦建立（accept成功返回），getsockname就可以用于返回（由内核赋予）该连接的本地IP地址。

**注意：**在这样的调用中，套接字描述符参数必须是已连接套接字的描述符，而不是监听套接字的描述符。

<br>

（5）当一个服务器是由调用过accept的某个进程通过调用exec执行程序时，它能够获取客户身份的唯一途径便是调用getpeername。
