---
layout: post
title:  "[Unp]Chapter 25"
subtitle: "信号驱动式 I/O"
date:   2019-07-20 07:00:00 +0800
categories: [unp]
---


# 概述

信号驱动式 I/O 是指：进程预先告知内核，使得当某个描述符上发生某事时，内核使用信号通知相关进程。

它通常定义为，进程执行 I/O 系统调用（譬如读或写）告知内核启动某个 I/O 操作，内核启动 I/O 操作后立即返回到进程。

<br><br>

# 套接字的信号驱动式 I/O

<br>

**针对一个套接字使用信号驱动式I/O（SIGIO），它需要进程执行以下3个步骤：**

（1）首先，建立 SIGIO 信号的信号处理函数。

（2）其次，设置该套接字的属主，通常使用 fcntl 的 F_SETOWN 命令设置。

（3）最后，开启该套接字的信号驱动式 I/O ，通常通过使用 fcntl 的 F_SETFL 命令打开 O_ASYNC 标志完成。

<br><br>

**确定哪些条件导致内核产生 SIGIO 信号（该信号是递交给套接字属主），这不是容易的事。这种判定取决于支撑协议。**

<br>

**对于 UDP 套接字的 SIGIO 信号**

<br>

在UDP上使用信号驱动式I/O是简单的。SIGIO信号在发生以下事件时，它会产生：

* 数据报到达套接字；

* 套接字上发生异步错误。

因此，当捕获某个 UDP 套接字的 SIGIO 信号时，我们调用 recvfrom 或者 读入到达的数据报，或者 获取发生的异步错误。UDP 套接字发生异步错误的前提是，UDP套接字已连接。

<br><br>

**对于 TCP 套接字的 SIGIO 信号**

<br>

信号驱动式 I/O 对于 TCP 套接字近乎无用。问题在于，该信号产生得过于频繁。并且，它的出现没有告诉我们发生了什么事件。

<br>

如 TCPv2 第439页所注，下列条件都可以导致 TCP 套接字产生 SIGIO 信号（假设该套接字的信号驱动式I/O已经开启）：

* 监听套接字上某个连接请求已经完成；

* 某个断连请求已经发起；

* 某个断连请求已经完成；

* 某个连接之半已经关闭；

* 数据到达套接字；

* 数据已经从套接字发送走（即输出缓冲区有空闲空间）；

* 发生某个异步错误。

<br><br>

我们只考虑对监听 TCP 套接字使用 SIGIO 。因为对于监听套接字产生 SIGIO 的唯一条件是：某个新连接的完成。

<br><br>

**信号驱动式 I/O 对于套接字的唯一现实用途是，基于 UDP 的 NTP 服务器程序。**

大多数UDP服务器都设计成 下图左侧 所示的方式。

不过，NTP 服务器却采用 下图右侧 所示的技巧。当一个新的数据报到达时，SIGIO 处理函数读入该数据报，同时记录它的到达时刻，然后将它置于进程内的另一个队列中，以便主服务器循环移走并处理。

尽管服务器代码变复杂了，却为到达数据报提供了精确的时间戳。对 NTP 服务器而言，重要的是，为每个收取的数据报记录精确的时间戳，因为该值将返送给客户，由客户用于计算到服务器的 RTT。

![](/images/Unp/UNP_25/UNP_1.png)

<br><br>

UNP 25.3后面的例子可以多去看看。



























