---
layout: post
title:  "[Apue]Chapter 10 - b"
subtitle: "信号"
date:   2019-07-16 00:50:32 +0800
categories: [apue]
---



# 函数 signal

UNIX 系统信号机制最简单的接口是 signal 函数。

![](/images/Apue/APUE_10/APUE_10_2.png)

signo 返回值是一个函数地址，该函数的参数是整型。

<br>
signal 函数参数：

* signo 参数是信号名(SIGXXXX)。signo 是一个整型数。

* func 是函数指针。func 的值是常量 SIG_IGN、常量SIG_DFL ，或着是 当接收到这个信号后，要调用的函数的地址。
<br><br>
如果制定SIG_IGN，则向内核表示忽略此信号（SIGKILL 和 SIGSTOP 不能被忽略）。
<br><br>
如果制定SIG_DFL，则表示，接收到这个信号后的动作是系统默认动作。
<br><br>
当func 参数是函数的地址时，那么在信号发生时，调用该函数。我们称这种处理为 ‘捕捉该信号”；称这个函数为 “信号处理函数” 或 ”信号捕捉函数“。

<br><br>

# 不可靠的信号

不可靠的信号是指，信号可能会丢失。一个信号发生了，但进程却可能一直不知道这一点。

<br>

早期版本有一个问题：在进程每次接收到信号，然后进行处理时，将该信号动作重置为默认值。
例如：

![](/images/Apue/APUE_10/APUE_10_3.png)

**这段代码的一个问题是：**

从信号发生后，一直到信号处理程序调用 signal 函数，这中间有一个时间窗口。在此段时间中，可能会发生另一次中断信号。第二个信号会造成执行默认动作，而对中断信号的默认动作是终止该进程。这种类型的程序段在大多数情况下会正常工作，使得我们认为它们是正确无误的，而实际上却并非如此。

我们可以对每种信号只捕捉一次，从而回避这一点。

<br><br>

早期版本的另外一个问题：在进程不希望某种信号发生时，它不能关闭该信号。例如：

![它捕捉一个信号，然后设置一个表示该信号已发生的标志](/images/Apue/APUE_10/APUE_10_4.png)

过程：

进程调用 pause 函数使自己休眠，直到捕捉到一个信号后苏醒。当捕捉到信号时，信号处理程序将标志 sig_int_flag 设置为非 0 值。从信号处理程序返回后，内核自动将该进程唤醒，它检测到该标志为非 0，然后执行它所需做的。

**这段代码的问题是：**

在检测sig_int_flag 之后、调用 pause 之前会产生一个时间窗口。如果在这段时间内发生信号，那么此进程在调用 pause 时，可能将永久休眠（假定此信号不会再次产生）。于是，这次发生的信号也就丢失了。

<br><br>

# 中断的系统调用

早期Unix 系统的一个特性是：如果进程在执行一个低速系统调用，在阻塞期间捕捉到一个信号，则该低速系统调用就被中断，不再继续执行。

<br><br>

低速系统调用是可能会让进程永远阻塞的一类系统调用，包括：

* 如果某些类型文件的数据不存在，则读操作可能会使调用者永远阻塞。这里的某些类型文件指，读管道、终端设备和网络设备。

* 如果这些数据不能被相同的类型文件立即接受，那么写操作可能会使调用者永远阻塞。

* 在某种条件发生之前，打开某些类型文件，这可能会发生阻塞。比如，打开一个终端设备时，需要先等待与它连接的调制解调器的应答。

* pause 函数 和 wait 函数。按照pause 的定义，它使调用进程休眠，直到捕捉到一个信号苏醒。

* 某些进程间通信函数。

<br>

**在这些低速系统调用中，有一个值得注意的例外：与磁盘 I/O 有关的系统调用。**

虽然读、写一个磁盘文件可能暂时阻塞调用者，但是除非发生硬件错误，I/O 操作总会很快返回，并且使调用者不再处于阻塞状态。

<br><br>

为了帮助应用程序不必处理被中断的系统调用，4.2BSD 引进了（某些被中断系统调用的）自动重启动。

**引入自动重启动功能的一个理由是**：有时用户不知道使用的输入、输出设备是否是低速设备。如果在程序中捕捉信号，而且系统并不提供重启动功能， 则对每次读、写系统调用就要进行是否出错返回的测试；如果是被中断的，则再调用读、写系统调用

自动重启动的系统调用有：ioctl、read、readv、write、writev、wait 和 waitpid。前5个函数只有对低速设备进行操作时，才会被信号中断。而wait 和 waitpid 在捕捉到信号时，总是被中断。

因为这种自动重启动的处理方式也会带来问题，某些应用程序不希望这些函数被中断后重启动。因此，4.3BSD 允许进程基于每个信号禁用此功能。

<br><br>

# 可重入函数

不可重入的例子：

进程捕捉到信号，对该信号进行处理时，进程正在执行的正常指令序列就会被临时中断（信号处理程序）。它会先执行该信号处理程序中的指令。如果进程正在malloc，从其堆中分配存储空间。而此时，进程捕捉到信号，从而先执行信号处理程序。因为进程调用了malloc，那么这种情况下会发生什么事情呢？

这可能会对进程造成破坏。因为malloc 通常为它分配的存储空间维护一个链表，而插入信号处理程序时，进程可能正在更改此链表。

<br>
又例如，若进程正在执行getpwnam这种将其结果存放在静态存储单元中的函数，其间插入执行信号处理程序，它又调用这样的函数，则返回给正常调用者的信息 可能会被 返回给信号处理程序的信息 覆盖。

<br><br>

可重入的函数如下表：

![](/images/Apue/APUE_10/APUE_10_5.png)

大多数函数是不可重入的原因是：

（a）它们使用静态数据结构。

（b）它们调用 malloc 或 free。

（c）它们是标准 I/O 函数。标准 I/O 库的很多实现都以不可重入的方式使用全剧数据结构。

<br>

注意：

（1）即使信号处理程序调用的是可重入函数，但是由于每个县城只有一个 errno 变量，因此信号处理程序会修改原先值。

（2）可重入函数列表中没有 longjmp 和 siglongjmp 的原因是：因为主例程以非可重入方式正在更新一个数据结构时，它可能产生信号。

